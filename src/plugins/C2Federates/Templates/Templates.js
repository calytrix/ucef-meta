//jshint ignore: start
/* Generated file based on ejs templates */
define([], function() {
    return {
    "class.cpp.ejs": "<% /*class(isinteraction,simname,classname,parentclassname,hlaclassname,datamembers,alldatamembers,isc2winteractionroot) ::= <<*/ %>\n// This code has been generated by the C2W code generator.\n// Do not edit manually!\n\n#include \"<%=classname%>.hpp\"\n\n<% /*classcommon(...)*/ %>\n<%-ejs.render(\n\tTEMPLATES[\"classcommon.cpp.ejs\"],{\n\t\tisinteraction: isinteraction,\n\t\tclassname: classname,\n\t\tparentclassname: parentclassname,\n\t\thlaclassname: hlaclassname,\n\t\tdatamembers: datamembers,\n\t\talldatamembers: alldatamembers\n})%>\n\n<% if(isc2winteractionroot){ %>\nvoid C2WInteractionRoot::sendInteraction( RTI::RTIambassador *rti, double time ) {\n\tif ( get_sourceFed().empty() || get_originFed().empty() ) {\n\t\tthrow C2WException( \"C2WInteractionRoot::sendInteraction:  source and/or origin federate not specified.\" );\n\t}\n\tSuper::sendInteraction( rti, time );\n}\n\nvoid C2WInteractionRoot::sendInteraction( RTI::RTIambassador *rti ) {\n\tif ( get_sourceFed().empty() || get_originFed().empty() ) {\n\t\tthrow C2WException( \"C2WInteractionRoot::sendInteraction:  source and/or origin federate not specified.\" );\n\t}\n\tSuper::sendInteraction( rti );\n}\n\t\n<%}%>\n\n<% if(datamembers && datamembers.length > 0){ %>\n<%=classname%>::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP <%=classname%>::createDatamemberHandleValuePairSet( RTI::ULong count<% if(!isinteraction){ %>, bool force <%}%> ) {\n\t<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP datamembers = Super::createDatamemberHandleValuePairSet( count + <%=datamembers.length%><% if(!isinteraction){ %>, force<%}%> );\n\n\tstd::string stringConversion;\n\t\t\n<% if(isinteraction){ %>\n\t<% /*datamembers:supplied_parameter()*/%>\n\t<% datamembers.forEach(function(datamember){ %>\n\tstringConversion = static_cast< std::string >(  TypeMedley( get_<%=datamember.name%>() )  );\n\tdatamembers->add( get_<%=datamember.name%>_handle(), stringConversion.c_str(), stringConversion.size() );\n\t<%});%>\n<% }else{ %>\n\tbool isPublished = false;\n\t<% /*datamembers:{ d |<supplied_attribute(classname=classname,datamember=d)>}*/ %>\n\t<% datamembers.forEach(function(datamember){ %>\n\ttry {\n\t\tisPublished = getPublishedAttributeHandleSet_var().isMember( get_<%=datamember.name%>_handle() );\n\t} catch ( ... ) {\n\t\tstd::cerr << \"ERROR:  <%=classname%>.createSuppliedAttributes:  could not determine if <%=datamember.name%> is published.\" << std::endl;\n\t\tisPublished = false;\n\t}\n\tif (  isPublished && _<%=datamember.name%>.shouldBeUpdated( force )  ) {\n\t\tstringConversion = static_cast< std::string >(  TypeMedley( get_<%=datamember.name%>() )  );\n\t\tdatamembers->add( get_<%=datamember.name%>_handle(), stringConversion.c_str(), stringConversion.size() );\n\t\t_<%=datamember.name%>.setHasBeenUpdated();\n\t}\n\n\t<%});%>\n<%}%>\n\treturn datamembers;\n}\n<%}%>\n",
    "class.hpp.ejs": "<% /*class(isinteraction,simname,classname,parentclassname,hlaclassname,datamembers,alldatamembers,isc2winteractionroot) ::= << */ %>\n/*\n * Copyright (c) 2008, Institute for Software Integrated Systems, Vanderbilt University\n * All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose, without fee, and without written agreement is\n * hereby granted, provided that the above copyright notice, the following\n * two paragraphs and the author appear in all copies of this software.\n *\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * @author Himanshu Neema\n * @author Harmon Nine\n */\n\n// This code has been generated by the C2W code generator.\n// Do not edit manually!\n\n/*\n * \tNOTE:  ALL \"if\" STATEMENTS IN THIS CODE THAT HAD THE FORM:\n *\n *  if (condition) statement;\n *\n *\tOR\n *\n *  if (condition) statement1;\n *  else           statement2;\n *\n *  HAVE BEEN CONVERTED TO THE FORMS:\n *\n *  if (condition) {\n *\t\tstatement;\n *\t}\n *\n *\tAND\n *\n *  if (condition) {\n *\t\tstatement1;\n *\t} else {\n *\t\tstatement2;\n *\t}\n *\n *\tRESPECTIVELY.  THIS IS BECAUSE THE OMNET DEBUGGER APPEARS TO HAVE A PROBLEM\n *  WITH THE NON-BRACED FORMS OF THE IF STATEMENT.  *PLEASE* DO NOT CHANGE IT BACK.\n *  -- H.S.N.\n *\n */\n\n#ifndef _<%=classname%>_CLASS\n#define _<%=classname%>_CLASS\n\n#include \"<%=parentclassname%>.hpp\"\n#include \"C2WException.hpp\"\n\n\nclass <%=classname%> : public <%=parentclassname%> {\n\npublic:\n\ttypedef <%=parentclassname%> Super;\n\ttypedef boost::shared_ptr< <%=classname%> > SP;\n\n\tstatic StringVector get_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\n\t\treturn getDatamemberNames();\n\t}\n\n\tstatic StringVector get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\n\t\treturn getAllDatamemberNames();\n\t}\n\n\t<%=classname%>( void ) { }\n\t\n\tstatic SP create( void ) { return SP( new <%=classname%> ); }\n\nprivate:\n\t<% /*datamembers:handle()*/ %>\n\t<% datamembers.forEach(function(datamember){ %>\n\tstatic int &get_<%=datamember.name%>_handle_var( void ) {\n\t\tstatic int <%=datamember.name%>_handle;\n\t\treturn <%=datamember.name%>_handle;\n\t}<%});%>\n\t\npublic:\n\t<% /*datamembers:gethandle()*/ %>\n\t<% datamembers.forEach(function(datamember){ %>\n\tstatic int get_<%=datamember.name%>_handle( void ) { return get_<%=datamember.name%>_handle_var(); }<%});%>\n\t\n<% /*classcommon(...)*/ %>\n<%-ejs.render(\n\tTEMPLATES[\"classcommon.hpp.ejs\"],{\n\t\tisinteraction: isinteraction,\n\t\tclassname: classname,\n\t\tparentclassname: parentclassname,\n\t\thlaclassname: hlaclassname,\n\t\tdatamembers: datamembers,\n\t\talldatamembers: alldatamembers\n})%>\n\n<% if(isc2winteractionroot){ %>\npublic:\n\tvoid sendInteraction( RTI::RTIambassador *rti, double time );\n\tvoid sendInteraction( RTI::RTIambassador *rti );\n\t\n<%}%>\n\n<% if(isinteraction){ %>\nprivate:\n\t<% /*datamembers:interactionmembers()*/ %>\n\t<% datamembers.forEach(function(datamember){ %>\n\t<%- helpers.cppjavaTypeMap(datamember.parameterType) %> _<%=datamember.name%>;\n\t<%});%>\npublic:\n\t<% /*datamembers:interactiongetters()*/ -%>\n\t<% datamembers.forEach(function(datamember){ %>\n\tvoid set_<%=datamember.name%>( <%- helpers.cppjavaArgumentTypeMap(datamember.parameterType) %> <%=datamember.name%> ) { _<%=datamember.name%> = <%=datamember.name%>; }\n\t<%- helpers.cppjavaArgumentTypeMap(datamember.parameterType) %> get_<%=datamember.name%>( void ) const { return _<%=datamember.name%>; }\n\t<%});%>\n<% }else{ %>\npublic:\n\t<% alldatamembers.forEach(function(attribute){ %>\n\t<% /*alldatamembers:{ a |<publish(classname=classname,attribute=a)> }*/ %>\n\tstatic void publish_<%=attribute.name%>( void ) {\n\t\tgetPublishAttributeNameVector().push_back( \"<%=attribute.name%>\" );\n\t}\n\tstatic void unpublish_<%=attribute.name%>( void ) {\n\t\tgetPublishAttributeNameVector().erase( std::remove( getPublishAttributeNameVector().begin(), getPublishAttributeNameVector().end(), \"<%=attribute.name%>\" ), getPublishAttributeNameVector().end() );\n\t}\n\t<% /*alldatamembers:{ a |<subscribe(classname=classname,attribute=a)> }*/ %>\n\tstatic void subscribe_<%=attribute.name%>( void ) {\n\t\tgetSubscribeAttributeNameVector().push_back( \"<%=attribute.name%>\" );\n\t}\n\tstatic void unsubscribe_<%=attribute.name%>(void ) {\n\t\tgetSubscribeAttributeNameVector().erase( std::remove( getSubscribeAttributeNameVector().begin(), getSubscribeAttributeNameVector().end(), \"<%=attribute.name%>\" ), getSubscribeAttributeNameVector().end() );\n\t}\n\t<%});%>\nprivate:\n\t<% /*datamembers:objectmembers()*/ %>\n\t<% datamembers.forEach(function(datamember){ %>\n\tAttribute< int, <%- helpers.cppjavaTypeMap(datamember.parameterType) %> > _<%=datamember.name%>;\n\t<%});%>\npublic:\n\t<% datamembers.forEach(function(datamember){ %>\n\t<% /*datamembers:objectsetters()*/ %>\n\tvoid set_<%=datamember.name%>( <%- helpers.cppjavaArgumentTypeMap(datamember.parameterType) %> <%=datamember.name%> ) {\n\t\t_<%=datamember.name%>.setValue( <%=datamember.name%> );\n\t\t_<%=datamember.name%>.setTime( getTime() );\n\t}\n\t<% /*datamembers:objectgetters()*/ %>\n\t<%- helpers.cppjavaArgumentTypeMap(datamember.parameterType) %> get_<%=datamember.name%>( void ) const {\n\t\treturn _<%=datamember.name%>.getValue();\n\t}\n\t<% /*datamembers:objecttimegetters()*/ %>\n\tdouble get_<%=datamember.name%>_time( void ) {\n\t\treturn _<%=datamember.name%>.getTime();\n\t}\n\t<%});%>\n<%}%>\n\n\t<%=classname%>( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) : Super( datamemberMap ) { }\n\t\n\t<%=classname%>( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &logicalTime ) : Super( datamemberMap, logicalTime ) { }\n\t\n\t<% if(datamembers && datamembers.length > 0){ %>\npublic:\n\tTypeMedley get<%=isinteraction?\"Parameter\":\"Attribute\"%>( const std::string &datamemberName ) const {\n\t\t<% /*first(datamembers):startgetbyname()*/ %>\n\t\t<% for(var i = 0; i<datamembers.length; i++ ){ %>\n\t\t<%= i == 0  ? 'if' : 'else if' %> ( \"<%=datamembers[i].name%>\" == datamemberName ) {\n\t\t\treturn TypeMedley( get_<%=datamembers[i].name%>() );\n\t\t}<%}%> else {\n\t\t\treturn Super::get<%=isinteraction?\"Parameter\":\"Attribute\"%>( datamemberName );\n\t\t}\n\t}\n\t\n\tTypeMedley get<%=isinteraction?\"Parameter\":\"Attribute\"%>( int datamemberHandle ) const {\n\t\t<% /*first(datamembers):startgetbyhandle()*/ %>\n\t\t<% for(var i = 0; i<datamembers.length; i++ ){ %>\n\t\t<%= i == 0  ? 'if' : 'else if'%> ( get_<%=datamembers[i].name%>_handle() == datamemberHandle ) {\n\t\t\treturn TypeMedley( get_<%=datamembers[i].name%>() );\n\t\t}<%}%> else {\n\t\t\treturn Super::get<%=isinteraction?\"Parameter\":\"Attribute\"%>( datamemberHandle );\n\t\t}\n\t}\n\nprotected:\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( int param_handle, const std::string &val ) {\n\t\tbool retval = true;\t\t\n\t\t<% /*first(datamembers):startif()*/ %>\n\t\t<% for(var i = 0; i<datamembers.length; i++ ){ %>\n\t\t<%= i == 0  ? 'if' : 'else if'%> ( param_handle == get_<%=datamembers[i].name%>_handle() ) {\n\t\t\tset_<%=datamembers[i].name%>(  TypeMedley( val )  );\n\t\t}<%}%> else {\n\t\t\tretval = Super::set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( param_handle, val );\n\t\t}\n\t\treturn retval;\n\t}\n\t\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( const std::string &datamemberName, const std::string &val ) {\n\t\tbool retval = true;\n\t\t<% /*first(datamembers):startifstring()*/ %>\n\t\t<% for(var i = 0; i<datamembers.length; i++ ){ %>\n\t\t<%= i == 0  ? 'if' : 'else if'%> ( \"<%=datamembers[i].name%>\" == datamemberName ) {\n\t\t\tset_<%=datamembers[i].name%>(  TypeMedley( val )  );\n\t\t}<%}%> else {\n\t\t\tretval = Super::set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, val );\n\t\t}\n\t\t\n\t\treturn retval;\n\t}\n\t\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( const std::string &datamemberName, const TypeMedley &val ) {\n\t\tbool retval = true;\n\t\t<% /*first(datamembers):startifname()*/ %>\n\t\t<% for(var i = 0; i<datamembers.length; i++ ){ %>\n\t\t<%= i == 0  ? 'if' : 'else if'%> ( \"<%=datamembers[i].name%>\" == datamemberName ) {\\\n\t\t\tset_<%=datamembers[i].name%>( val );\n\t\t}<%}%> else {\n\t\t\tretval = Super::set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, val );\n\t\t}\n\t\t\n\t\treturn retval;\n\t}\n\n\tvirtual <%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP createDatamemberHandleValuePairSet( RTI::ULong count<% if(!isinteraction){%>, bool force <%}%> );\n\n\tvirtual <%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP createDatamemberHandleValuePairSet( <% if(!isinteraction){%> bool force <%}%>) {\n\t\treturn createDatamemberHandleValuePairSet( 0<% if(!isinteraction){%>, force<%}%> );\n\t}\n\t<%}%>\n\t\n};\n\ntypedef <%=classname%>::SP <%=classname%>SP;\n\nstatic bool call_<%=classname%>_static_init = <%=classname%>::static_init();\n\nstd::ostream &operator<<( std::ostream &os, <%=classname%>::SP entitySP );\nstd::ostream &operator<<( std::ostream &os, const <%=classname%> &entity );\n#endif\n",
    "class.java.ejs": "<% /*class(isinteraction,simname,classname,parentclassname,hlaclassname,datamembers,alldatamembers,isc2winteractionroot) */%>\n// This code has been generated by the C2W code generator.\n// Do not edit manually!\n\npackage <%=simname%>;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport hla.rti.*;\n<% if(simname !== 'c2w.hla'){ %>\nimport c2w.hla.*;\n<% } %>\n/**\n* The <%=classname%> class implements the <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> in the\n* <%=simname%> simulation.\n*/\npublic class <%=classname%> extends <%=parentclassname%> {\n\n\t/**\n\t* Default constructor -- creates an instance of the <%=classname%> <%=isinteraction?\"interaction\":\"object\"%>\n\t* class with default <%=isinteraction?\"parameter\":\"attribute\"%> values.\n\t*/\n\tpublic <%=classname%>() { }\n\n\t<% /*datamembers:handle()*/ %>\n\t<% datamembers.forEach(function(datamember){ %>\n\tprivate static int _<%=datamember.name%>_handle;<%});%>\n\t<% /*datamembers:gethandle()*/ %>\n\t<% datamembers.forEach(function(datamember){ %>\n\t/**\n\t* Returns the handle (RTI assigned) of the \"<%=datamember.name%>\" <%=isinteraction?\"parameter\":\"attribute\"%> of\n\t* its containing <%=isinteraction?\"interaction\":\"object\"%> class.\n\t*\n\t* @return the handle (RTI assigned) of the \"<%=datamember.name%>\" <%=isinteraction?\"parameter\":\"attribute\"%>\n\t*/\n\tpublic static int get_<%=datamember.name%>_handle() { return _<%=datamember.name%>_handle; }\n\t<%});%>\n\t<% /*classcommon(...)*/ %>\n\t<%- ejs.render(TEMPLATES[\"classcommon.java.ejs\"],\n\t\t{\tisinteraction: isinteraction,\n\t\t\tclassname: classname,\n\t\t\tparentclassname: parentclassname,\n\t\t\thlaclassname: hlaclassname,\n\t\t\tdatamembers: datamembers,\n\t\t\talldatamembers: alldatamembers\n\t}) %>\n\t\n<% if(isc2winteractionroot){%>\n\t@Override\n\tpublic void sendInteraction( RTIambassador rti, double time ) throws Exception {\n\t\tif (  get_sourceFed() == null || \"\".equals( get_sourceFed() ) || get_originFed() == null || \"\".equals( get_originFed() )  ) {\n\t\t\tthrow new Exception( \"C2WInteractionRoot.sendInteraction:  source and/or origin federate not specified.\" );\n\t\t}\n\t\tsuper.sendInteraction( rti, time );\n\t}\n\n\t@Override\n\tpublic void sendInteraction( RTIambassador rti ) throws Exception {\n\t\tif (  get_sourceFed() == null || \"\".equals( get_sourceFed() ) || get_originFed() == null || \"\".equals( get_originFed() )  ) {\n\t\t\tthrow new Exception( \"C2WInteractionRoot.sendInteraction:  source and/or origin federate not specified.\" );\n\t\t}\n\t\tsuper.sendInteraction( rti );\n\t}\n<%}%>\n\n<% if(isinteraction){ %>\n\t<% datamembers.forEach(function(parameter){ %>\n\t<% /*datamembers:interactionmembers()*/ %>\n\tprivate <%=parameter.parameterType%> _<%=parameter.name%> = <%-helpers.initialvalue(parameter.parameterType)%>;<%});%>\n\n\t<% datamembers.forEach(function(parameter){ %>\n\t<% /*datamembers:interactionsetters()*/ %>\n\t/**\n\t* Set the value of the \"<%=parameter.name%>\" parameter to \"value\" for this parameter.\n\t*\n\t* @param value the new value for the \"<%=parameter.name%>\" parameter\n\t*/\n\tpublic void set_<%=parameter.name%>( <%=parameter.parameterType%> value ) { _<%=parameter.name%> = value; }\n\t<% /*datamembers:interactiongetters()*/ %>\n\t/**\n\t* Returns the value of the \"<%=parameter.name%>\" parameter of this interaction.\n\t*\n\t* @return the value of the \"<%=parameter.name%>\" parameter\n\t*/\n\tpublic <%=parameter.parameterType%> get_<%=parameter.name%>() { return _<%=parameter.name%>; }\n\t<%});%>\n<% }else{ %>\n\t<% alldatamembers.forEach(function(attribute){ %>\n\t<% /* alldatamembers:{ a |<publish(attribute=a)> } */ %>\n\t/**\n\t* Publishes the \"<%=attribute.name%>\" attribute of the attribute's containing object\n\t* class for a federate.\n\t* Note:  This method only marks the \"<%=attribute.name%>\" attribute for publication.\n\t* To actually publish the attribute, the federate must (re)publish its containing\n\t* object class.\n\t* (using <objectClassName>.publish( RTIambassador rti ) ).\n\t*/\n\tpublic static void publish_<%=attribute.name%>() {\n\t\t_publishAttributeNameSet.add( \"<%=attribute.name%>\" );\n\t}\n\n\t/**\n\t* Unpublishes the \"<%=attribute.name%>\" attribute of the attribute's containing object\n\t* class for a federate.\n\t* Note:  This method only marks the \"<%=attribute.name%>\" attribute for unpublication.\n\t* To actually publish the attribute, the federate must (re)publish its containing\n\t* object class.\n\t* (using <objectClassName>.publish( RTIambassador rti ) ).\n\t*/\n\tpublic static void unpublish_<%=attribute.name%>() {\n\t\t_publishAttributeNameSet.remove( \"<%=attribute.name%>\" );\n\t}\n\t<% /* alldatamembers:{ a |<subscribe(attribute=a)> } */ %>\n\t/**\n\t* Subscribes a federate to the \"<%=attribute.name%>\" attribute of the attribute's\n\t* containing object class.\n\t* Note:  This method only marks the \"<%=attribute.name%>\" attribute for subscription.\n\t* To actually subscribe to the attribute, the federate must (re)subscribe to its\n\t* containing object class.\n\t* (using <objectClassName>.subscribe( RTIambassador rti ) ).\n\t*/\n\tpublic static void subscribe_<%=attribute.name%>() {\n\t\t_subscribeAttributeNameSet.add( \"<%=attribute.name%>\" );\n\t}\n\n\t/**\n\t* Unsubscribes a federate from the \"<%=attribute.name%>\" attribute of the attribute's\n\t* containing object class.\n\t* Note:  This method only marks the \"<%=attribute.name%>\" attribute for unsubscription.\n\t* To actually unsubscribe to the attribute, the federate must (re)subscribe to its\n\t* containing object class.\n\t* (using <objectClassName>.subscribe( RTIambassador rti ) ).\n\t*/\n\tpublic static void unsubscribe_<%=attribute.name%>() {\n\t\t_subscribeAttributeNameSet.remove( \"<%=attribute.name%>\" );\n\t}\n\t<%});%>\n\n\t<% datamembers.forEach(function(datamember){ %>\n\t<% /*datamembers:objectmembers()*/ %>\n\tprivate Attribute< <%= helpers.primitive2object(datamember.parameterType) %> > _<%=datamember.name%> =\n \t\tnew Attribute< <%= helpers.primitive2object(datamember.parameterType) %> >(  new <%= helpers.primitive2object(datamember.parameterType)%>( <%-helpers.initialvalue(datamember.parameterType)%> )  );\n\t<% /*datamembers:objectsetters()*/ %>\n\t/**\n\t* Set the value of the \"<%=datamember.name%>\" attribute to \"value\" for this object.\n\t*\n\t* @param value the new value for the \"<%=datamember.name%>\" attribute\n\t*/\n\tpublic void set_<%=datamember.name%>( <%=datamember.parameterType%> value ) {\n\t\t_<%=datamember.name%>.setValue( value );\n\t\t_<%=datamember.name%>.setTime( getTime() );\n\t}\n\t<% /*datamembers:objectgetters()*/ %>\n\t/**\n\t* Returns the value of the \"<%=datamember.name%>\" attribute of this object.\n\t*\n\t* @return the value of the \"<%=datamember.name%>\" attribute\n\t*/\n\tpublic <%=datamember.parameterType%> get_<%=datamember.name%>() {\n\t\treturn _<%=datamember.name%>.getValue();\n\t}\n\t<% /*datamembers:objecttimegetters()*/ %>\n\t/**\n\t* Returns the current timestamp of the \"<%=datamember.name%>\" attribute of this object.\n\t* \n\t* @return the current timestamp of the \"<%=datamember.name%>\" attribute\n\t*/\n\tpublic double get_<%=datamember.name%>_time() {\n\t\treturn _<%=datamember.name%>.getTime();\n\t}\n\t<%});%>\n<% } %>\n\n\tprotected <%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, boolean initFlag ) {\n\t\tsuper( datamemberMap, false );\n\t\tif ( initFlag ) set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>s( datamemberMap );\n\t}\n\t\n\tprotected <%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime, boolean initFlag ) {\n\t\tsuper( datamemberMap, logicalTime, false );\n\t\tif ( initFlag ) set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>s( datamemberMap );\n\t}\n\n\n\t/**\n\t* Creates an instance of the <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class, using\n\t* \"datamemberMap\" to initialize its <%=isinteraction?\"parameter\":\"attribute\"%> values.\n\t* \"datamemberMap\" is usually acquired as an argument to an RTI federate\n\t* callback method, such as \"receiveInteraction\".\n\t*\n\t* @param datamemberMap data structure containing initial values for the\n\t* <%=isinteraction?\"parameter\":\"attribute\"%>s of this new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance\n\t*/\n\tpublic <%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\n\t\tthis( datamemberMap, true );\n\t}\n\t\n\t/**\n\t* Like {@link #<%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap )}, except this\n\t* new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance is given a timestamp of\n\t* \"logicalTime\".\n\t*\n\t* @param datamemberMap data structure containing initial values for the\n\t* <%=isinteraction?\"parameter\":\"attribute\"%>s of this new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance\n\t* @param logicalTime timestamp for this new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class\n\t* instance\n\t*/\n\tpublic <%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime ) {\n\t\tthis( datamemberMap, logicalTime, true );\n\t}\n\n\t/**\n\t* Creates a new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance that is a duplicate\n\t* of the instance referred to by <%=classname%>_var.\n\t*\n\t* @param <%=classname%>_var <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance of which\n\t* this newly created <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance will be a\n\t* duplicate\n\t*/\n\tpublic <%=classname%>( <%=classname%> <%=classname%>_var ) {\n\t\tsuper( <%=classname%>_var );\n\t\t<% /*datamembers:{ d |<rticlasscopyvalue(classname=classname,datamember=d)>}*/ %>\n\t\t<% datamembers.forEach(function(datamember){ %>\n\t\tset_<%=datamember.name%>( <%=classname%>_var.get_<%=datamember.name%>() );<%});%>\n\t}\n\n<% if(datamembers && datamembers.length > 0){ %>\n\t/**\n\t* Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose name is \"datamemberName\"\n\t* for this <%=isinteraction?\"interaction\":\"object\"%>.\n\t*\n\t* @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be\n\t* returned\n\t* @return value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose name is \"datamemberName\"\n\t* for this <%=isinteraction?\"interaction\":\"object\"%>\n\t*/\n\tpublic Object get<%= isinteraction ? \"Parameter\" : \"Attribute\" %>( String datamemberName ) {\n\t\t<% /*first(datamembers):startgetbyname()*/ %>\n\t\t<% /*rest(datamembers):continuegetbyname()*/ %>\n\t\t<% for(var i = 0; i<datamembers.length; i++ ){ %>\n\t\t<%= i == 0  ? 'if' : 'else if'%> (  \"<%=datamembers[i].name%>\".equals( datamemberName )  ) return <%=helpers.get(datamembers[i].parameterType, datamembers[i].name)%>;<%}%>\n\t\telse return super.get<%= isinteraction ? \"Parameter\" : \"Attribute\" %>( datamemberName );\n\t}\n\t\n\t/**\n\t* Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose handle (RTI assigned)\n\t* is \"datamemberHandle\" for this <%=isinteraction?\"interaction\":\"object\"%>.\n\t*\n\t* @param datamemberHandle handle (RTI assigned) of <%=isinteraction?\"parameter\":\"attribute\"%> whose\n\t* value is to be returned\n\t* @return value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose handle (RTI assigned) is\n\t* \"datamemberHandle\" for this <%=isinteraction?\"interaction\":\"object\"%>\n\t*/\n\tpublic Object get<%= isinteraction ? \"Parameter\" : \"Attribute\" %>( int datamemberHandle ) {\n\t\t<% /*first(datamembers):startgetbyhandle()*/ %>\n\t\t<% /*rest(datamembers):continuegetbyhandle()*/ %>\t\t\n\t\t<% for(var i = 0; i<datamembers.length; i++ ){ %>\n\t\t<%= i == 0  ? 'if' : 'else if'%> ( get_<%=datamembers[i].name%>_handle() == datamemberHandle ) return <%=helpers.get(datamembers[i].parameterType, datamembers[i].name)%>;<%}%>\n\t\telse return super.get<%= isinteraction ? \"Parameter\" : \"Attribute\" %>( datamemberHandle );\n\t}\n\t\n\tprotected boolean set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( int param_handle, String val ) {\n\t\tboolean retval = true;\t\t\n\t\t<% /*first(datamembers):startif()*/ %>\n\t\t<% /*rest(datamembers):continueif()*/ %>\t\n\t\t<% for(var i = 0; i<datamembers.length; i++ ){ %>\n\t\t<%= i == 0  ? 'if' : 'else if'%> ( param_handle == get_<%=datamembers[i].name%>_handle() ) set_<%=datamembers[i].name%>( <%=helpers.set(datamembers[i].parameterType)%> );<%}%>\n\t\telse retval = super.set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( param_handle, val );\n\t\t\n\t\treturn retval;\n\t}\n\t\n\tprotected boolean set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( String datamemberName, String val ) {\n\t\tboolean retval = true;\n\t\t<% /*first(datamembers):startifstring()*/ %>\n\t\t<% /*rest(datamembers):continueifstring()*/ %>\t\n\t\t<% for(var i = 0; i<datamembers.length; i++ ){ %>\n\t\t<%= i == 0  ? 'if' : 'else if'%> (  \"<%=datamembers[i].name%>\".equals( datamemberName )  ) set_<%=datamembers[i].name%>( <%=helpers.set(datamembers[i].parameterType)%> );<%}%>\t\n\t\telse retval = super.set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( datamemberName, val );\n\t\t\n\t\treturn retval;\n\t}\n\t\n\tprotected boolean set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( String datamemberName, Object val ) {\n\t\tboolean retval = true;\n\t\t<% /*first(datamembers):startifname()*/ %>\n\t\t<% /*rest(datamembers):continueifname()*/ %>\n\t\t<% for(var i = 0; i<datamembers.length; i++ ){ %>\n\t\t<%= i == 0  ? 'if' : 'else if'%> (  \"<%=datamembers[i].name%>\".equals( datamemberName )  ) set_<%=datamembers[i].name%>( (<%= helpers.primitive2object(datamembers[i].parameterType)%>)val );<%}%>\t\t\n\t\telse retval = super.set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( datamemberName, val );\n\t\t\n\t\treturn retval;\n\t}\n\n\tprotected Supplied<%= isinteraction ? \"Parameter\" : \"Attribute\" %>s createSuppliedDatamembers(<%= isinteraction ? \"\" :\" boolean force \" %>) {\n\t\tSupplied<%= isinteraction ? \"Parameter\" : \"Attribute\" %>s datamembers = super.createSuppliedDatamembers(<%= isinteraction ? \"\" : \" force \"%>);\n\n\t<%if(isinteraction){%>\n\t\t<% /*datamembers:supplied_parameter()*/ %>\n\t\t<% datamembers.forEach(function(datamember){ %>\n\t\t\tdatamembers.add( get_<%=datamember.name%>_handle(), <%=helpers.supplied(datamember.parameterType, datamember.name)%>.getBytes() );\n\t\t<%});%>\n\t<%}else{%>\n\t\tboolean isPublished = false;\n\t\t<% /* datamembers:{ d |<%supplied_attribute(hlaclassname=hlaclassname,datamember=d)>} */ %>\n\t\t<% datamembers.forEach(function(datamember){ %>\n\t\t\ttry {\n\t\t\t\tisPublished = _publishedAttributeHandleSet.isMember( get_<%=datamember.name%>_handle() );\n\t\t\t} catch ( Exception e ) {\n\t\t\t\tSystem.err.println( \"ERROR:  <%=hlaclassname%>.createSuppliedAttributes:  could not determine if <%=datamember.name%> is published.\" );\n\t\t\t\tisPublished = false;\n\t\t\t}\n\t\t\tif (  isPublished && _<%=datamember.name%>.shouldBeUpdated( force )  ) {\n\t\t\t\tdatamembers.add( get_<%=datamember.name%>_handle(), <%=helpers.supplied(datamember.parameterType, datamember.name)%>.getBytes() );\n\t\t\t\t_<%=datamember.name%>.setHasBeenUpdated();\n\t\t\t}<%});%>\n\t<%}%>\n\t\treturn datamembers;\n\t}\n<%}%>\n\t\n\tpublic void copyFrom( Object object ) {\n\t\tsuper.copyFrom( object );\n\t\tif ( object instanceof <%=classname%> ) {\n\t\t\t<%=classname%> data = (<%=classname%>)object;\n\t\t\t<% /*datamembers:copydatamember();separator = \"\\n\"*/ %>\n\t\t\t<% datamembers.forEach(function(datamember){ %>\n\t\t\t\t_<%=datamember.name%> = data._<%=datamember.name%>;<%});%>\n\t\t\t\n\t\t}\n\t}\n}\n",
    "classcommon.cpp.ejs": "<% /*classcommon(isinteraction,classname,parentclassname,hlaclassname,datamembers,alldatamembers) ::= << */ %>\n\nvoid <%=classname%>::init( RTI::RTIambassador *rti ) {\n\tstatic bool isInitialized = false;\n\tif ( isInitialized ) {\n\t\treturn;\n\t}\n\tisInitialized = true;\n\n\t<% if(parentclassname){ %><%=parentclassname%>::init( rti );<%}%>\n\n\tbool isNotInitialized = true;\n\twhile( isNotInitialized ) {\n\t\ttry {\n\t\t\tgetHandle() = rti->get<%=isinteraction?\"Interaction\":\"Object\"%>ClassHandle( \"<%=hlaclassname%>\" );\n\t\t\tisNotInitialized = false;\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\n\t\t\tstd::cerr << getInitErrorMessage() << \"Federate Not Execution Member\" << std::endl;\n\t\t\treturn;\t\t\t\t\n\t\t} catch ( RTI::NameNotFound & ) {\n\t\t\tstd::cerr << getInitErrorMessage() << \"Name Not Found\" << std::endl;\n\t\t\treturn;\t\t\t\t\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << getInitErrorMessage() << \"Exception caught ... retry\" << std::endl;\n\t\t}\n\t}\n\n\tgetClassNameHandleMap().insert(  std::make_pair( \"<%=classname%>\", get_handle() )  );\n\tgetClassHandleNameMap().insert(  std::make_pair( get_handle(), \"<%=classname%>\" )  );\n\n<% if(datamembers){ %>\n\tisNotInitialized = true;\n\twhile( isNotInitialized ) {\n\t\ttry {\t\t\n\t\t\t<% /*datamembers:handle_init()*/ %>\n\t\t\t<% datamembers.forEach(function(datamember){ %>\n\t\t\tget_<%=datamember.name%>_handle_var() = rti->get<%=isinteraction?\"Parameter\":\"Attribute\"%>Handle( \"<%=datamember.name%>\", get_handle() );<%});%>\n\t\t\tisNotInitialized = false;\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\n\t\t\tstd::cerr << getInitErrorMessage() << \"Federate Not Execution Member\" << std::endl;\n\t\t\treturn;\t\t\t\t\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\n\t\t\tstd::cerr << getInitErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\n\t\t\treturn;\t\t\t\t\n\t\t} catch ( RTI::NameNotFound & ) {\n\t\t\tstd::cerr << getInitErrorMessage() << \"Name Not Found\" << std::endl;\n\t\t\treturn;\t\t\t\t\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << getInitErrorMessage() << \"Exception caught ... retry\" << std::endl;\n\t\t}\n\t}\n\t<% datamembers.forEach(function(datamember){ %>\n\t<% /*datamembers: { d |<initDatamemberNameHandleMap(classname=classname,datamember=d)>}*/ %>\n\tgetDatamemberNameHandleMap().insert(  std::make_pair( \"<%=classname%>,<%=datamember.name%>\", get_<%=datamember.name%>_handle() )  );\n\t<% /*datamembers:initDatamemberHandleNameMap()*/ %>\n\tgetDatamemberHandleNameMap().insert(  std::make_pair( get_<%=datamember.name%>_handle(), \"<%=datamember.name%>\" )  );\n\t<% /*datamembers:initDatamemberTypeMap()*/ %>\n\tgetDatamemberTypeMap().insert( std::make_pair(\"<%=datamember.name%>\", \"<%=datamember.parameterType%>\") );\n\t<%});%>\n<%}%>\n}\n\nvoid <%=classname%>::publish( RTI::RTIambassador *rti ) {\n\tif ( getIsPublished() ) {\n\t\treturn;\n\t}\n\n\tinit( rti );\n\n<% if(!isinteraction){ %>\t\n\tgetPublishedAttributeHandleSet_var().empty();\n\tfor( StringVector::iterator stsItr = getPublishAttributeNameVector().begin() ; stsItr != getPublishAttributeNameVector().end() ; (void)++stsItr ) {\n\t\ttry {\n\t\t\tgetPublishedAttributeHandleSet_var().add(  getDatamemberNameHandleMap().find( \"<%=classname%>,\" + *stsItr )->second  );\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << getPublishErrorMessage() << \"Could not publish \\\"\" << *stsItr + \"\\\" attribute.\" << std::endl;\n\t\t}\n\t}\n<%}%>\n\n\tbool isNotPublished = true;\n\twhile( isNotPublished ) {\n\t\ttry {\n\t\t\trti->publish<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle()<% if(!isinteraction){ %>, getPublishedAttributeHandleSet_var()<%}%> );\n\t\t\tisNotPublished = false;\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\n\t\t\tstd::cerr << getPublishErrorMessage() << \"Federate Not Execution Member\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\n\t\t\tstd::cerr << getPublishErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << getPublishErrorMessage() << \"Exception caught ... retry\" << std::endl;\n\t\t}\n\t}\n\n\tgetIsPublished() = true;\n}\n\nvoid <%=classname%>::unpublish( RTI::RTIambassador *rti ) {\n\tif ( !getIsPublished() ) {\n\t\treturn;\n\t}\n\n\tinit( rti );\n\n\tbool isNotUnpublished = true;\n\twhile( isNotUnpublished ) {\n\t\ttry {\n\t\t\trti->unpublish<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle() );\n\t\t\tisNotUnpublished = false;\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\n\t\t\tstd::cerr << getUnpublishErrorMessage() + \"Federate Not Execution Member\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\n\t\t\tstd::cerr << getUnpublishErrorMessage() + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotPublished & ) {\n\t\t\tstd::cerr << getUnpublishErrorMessage() + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Published\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << getUnpublishErrorMessage() << \"Exception caught ... retry\" << std::endl;\n\t\t}\n\t}\n\n\tgetIsPublished() = false;\n}\n\nvoid <%=classname%>::subscribe( RTI::RTIambassador *rti ) {\n\tif ( getIsSubscribed() ) {\n\t\treturn;\n\t}\n\n\tinit( rti );\n<% if(!isinteraction){ %>\t\n\tgetSubscribedAttributeHandleSet_var().empty();\n\tfor(  StringVector::iterator sstItr = getSubscribeAttributeNameVector().begin() ; sstItr != getSubscribeAttributeNameVector().end() ; (void)++sstItr  ) {\n\t\ttry {\n\t\t\tgetSubscribedAttributeHandleSet_var().add(  getDatamemberNameHandleMap().find( \"<%=classname%>,\" + *sstItr )->second  );\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << getSubscribeErrorMessage() << \"Could not subscribe to \\\"\" << *sstItr << \"\\\" attribute.\" << std::endl;\n\t\t}\n\t}\n<%}%>\n\t\n\tbool isNotSubscribed = true;\n\twhile( isNotSubscribed ) {\n\t\ttry {\n\t\t\trti->subscribe<% if(isinteraction){ %>InteractionClass( get_handle() )<% }else{ %>ObjectClassAttributes( get_handle(), getSubscribedAttributeHandleSet_var() )<%}%>;\n\t\t\tisNotSubscribed = false;\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\n\t\t\tstd::cerr << getSubscribeErrorMessage() << \"Federate Not Execution Member\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\n\t\t\tstd::cerr << getSubscribeErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << getSubscribeErrorMessage() << \"Exception caught ... retry\" << std::endl;\n\t\t}\n\t}\n\n\tgetIsSubscribed() = true;\n}\n\t\nvoid <%=classname%>::unsubscribe( RTI::RTIambassador *rti ) {\n\tif ( !getIsSubscribed() ) {\n\t\treturn;\n\t}\n\n\tinit( rti );\n\t\n\tbool isNotUnsubscribed = true;\n\twhile( isNotUnsubscribed ) {\n\t\ttry {\n\t\t\trti->unsubscribe<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle() );\n\t\t\tisNotUnsubscribed = false;\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\n\t\t\tstd::cerr << getUnsubscribeErrorMessage() << \"Federate Not Execution Member\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\n\t\t\tstd::cerr << getUnsubscribeErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotSubscribed & ) {\n\t\t\tstd::cerr << getUnsubscribeErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Subscribed\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << getUnsubscribeErrorMessage() << \"Exception caught ... retry\" << std::endl;\n\t\t}\n\t}\n\n\tgetIsSubscribed() = false;\n}\n\nbool <%=classname%>::static_init( void ) {\n\tstatic bool isInitialized = false;\n\tif ( isInitialized ) {\n\t\treturn true;\n\t}\n\tisInitialized = true;\n\t\n\tgetClassNameSet().insert( \"<%=classname%>\" );\n\t\n\tgetClassNameFactoryMap().insert(  std::make_pair( \"<%=classname%>\", &<%=classname%>::factory )  );\n\tgetClassNamePublishMap().insert(   std::make_pair(  \"<%=classname%>\", (PubsubFunctionPtr)( &<%=classname%>::publish )  )   );\n\tgetClassNameUnpublishMap().insert(   std::make_pair(  \"<%=classname%>\", (PubsubFunctionPtr)( &<%=classname%>::unpublish )  )   );\n\tgetClassNameSubscribeMap().insert(   std::make_pair(  \"<%=classname%>\", (PubsubFunctionPtr)( &<%=classname%>::subscribe )  )   );\n\tgetClassNameUnsubscribeMap().insert(   std::make_pair(  \"<%=classname%>\", (PubsubFunctionPtr)( &<%=classname%>::unsubscribe )  )   );\n\n\tgetDatamemberClassNameVectorPtrMap().insert(  std::make_pair( \"<%=classname%>\", &getDatamemberNames() )  );\n\tgetAllDatamemberClassNameVectorPtrMap().insert(  std::make_pair( \"<%=classname%>\", &getAllDatamemberNames() )  );\n\t\n\t<% /*datamembers:initDatamemberNameSet()*/ %>\n\t<% datamembers.forEach(function(datamember){ %>\n\t<% if(!datamember.hidden){%>getDatamemberNames().push_back( \"<%=datamember.name%>\" );<%}%><%});%>\n\t<% /*alldatamembers:initAllDatamemberNameSet()*/ %>\n\t<% datamembers.forEach(function(datamember){ %>\n\tgetAllDatamemberNames().push_back( \"<%=datamember.name%>\" );<%});%>\n\n<% if(!isinteraction){ %>\n\tgetClassNamePublishAttributeNameVectorPtrMap().insert(  std::make_pair( \"<%=classname%>\", &getPublishAttributeNameVector() )  );\n\tgetClassNameSubscribeAttributeNameVectorPtrMap().insert(  std::make_pair( \"<%=classname%>\", &getSubscribeAttributeNameVector() )  );\n\t\n\tgetClassNamePublishedAttributesPtrMap().insert(  std::make_pair( \"<%=classname%>\", &getPublishedAttributeHandleSet_var() )  );\n\tgetClassNameSubscribedAttributesPtrMap().insert( std::make_pair( \"<%=classname%>\", &getSubscribedAttributeHandleSet_var() )  );\n<%}%>\n\n\treturn true;\n}\n\nstd::ostream &operator<<( std::ostream &os, <%=classname%>::SP entitySP ) {\n\treturn os << *entitySP;\n}\nstd::ostream &operator<<( std::ostream &os, const <%=classname%> &entity ) {\n\treturn os << \"<%=classname%>(\" <% alldatamembers.forEach(function(datamember,i){ %><% if( i > 0){%> << \", \"<%}%> << \"<%=datamember.name%>:\" << entity.get_<%=datamember.name%>()<%});%>\t<< \")\";\n}\n",
    "classcommon.hpp.ejs": "<% /*classcommon(isinteraction,classname,parentclassname,hlaclassname,datamembers,alldatamembers) ::= <<*/ %>\nprivate:\n\tstatic int &getHandle( void ) {\n\t\tstatic int handle;\n\t\treturn handle;\n\t}\n\npublic:\n\tstatic int get_handle( void ) { return getHandle(); }\n\tstatic std::string get_class_name( void ) { return \"<%=classname%>\"; }\n\nprivate:\n\tstatic StringVector &getDatamemberNames( void ) {\n\t\tstatic StringVector datamemberNames;\n\t\treturn datamemberNames;\n\t}\n\n\tstatic StringVector &getAllDatamemberNames( void ) {\n\t\tstatic StringVector allDatamemberNames;\n\t\treturn allDatamemberNames;\n\t}\n\n<% if(!isinteraction){ %>\nprivate:\n\tstatic RTI::AttributeHandleSet &getPublishedAttributeHandleSet_var( void ) {\n\t\tstatic RTI::AttributeHandleSet *publishedAttributeHandleSetPtr = RTI::AttributeHandleSetFactory::create( <%= alldatamembers.length %> );\n\t\treturn *publishedAttributeHandleSetPtr;\n\t}\n\tstatic StringVector &getPublishAttributeNameVector( void ) {\n\t\tstatic StringVector publishAttributeNameVector;\n\t\treturn publishAttributeNameVector;\n\t}\t\n\t\n\tstatic RTI::AttributeHandleSet &getSubscribedAttributeHandleSet_var( void ) {\n\t\tstatic RTI::AttributeHandleSet *subscribedAttributeHandleSet = RTI::AttributeHandleSetFactory::create( <%= alldatamembers.length %> );\n\t\treturn *subscribedAttributeHandleSet;\n\t}\n\tstatic StringVector &getSubscribeAttributeNameVector( void ) {\n\t\tstatic StringVector subscribeAttributeNameVector;\n\t\treturn subscribeAttributeNameVector;\n\t}\t\n<%}%>\n\nprivate:\n<% if(isinteraction){ %>\n\tstatic InteractionRoot::SP factory( void ) {\n\t\treturn InteractionRoot::SP( new <%=classname%>() );\n\t}\n<% }else{ %>\n\tstatic ObjectRoot::SP factory( void ) {\n\t\treturn ObjectRoot::SP( new <%=classname%>() );\n\t}\n<%}%>\n\n\tstatic std::string &getInitErrorMessage( void ) {\n\t\tstatic std::string initErrorMessage( \"Error:  <%=classname%>:  could not initialize:  \" );\n\t\treturn initErrorMessage;\n\t}\n\nprotected:\n\tstatic void init( RTI::RTIambassador *rti );\n\t\nprivate:\n\tstatic bool &getIsPublished( void ) {\n\t\tstatic bool isPublished = false;\n\t\treturn isPublished;\n\t}\n\t\n\tstatic std::string &getPublishErrorMessage( void ) {\n\t\tstatic std::string publishErrorMessage = \"Error:  <%=classname%>:  could not publish:  \";\n\t\treturn publishErrorMessage;\n\t}\n\t\npublic:\n\tstatic void publish( RTI::RTIambassador *rti );\n\t\nprivate:\n\tstatic std::string &getUnpublishErrorMessage( void ) {\n\t\tstatic std::string unpublishErrorMessage = \"Error:  <%=classname%>:  could not unpublish:  \";\n\t\treturn unpublishErrorMessage;\n\t}\n\npublic:\n\tstatic void unpublish( RTI::RTIambassador *rti );\n\nprivate:\n\tstatic bool &getIsSubscribed( void ) {\n\t\tstatic bool isSubscribed = false;\n\t\treturn isSubscribed;\n\t}\n\tstatic std::string &getSubscribeErrorMessage( void ) {\n\t\tstatic std::string subscribedErrorMessage = \"Error:  <%=classname%>:  could not subscribe:  \";\n\t\treturn subscribedErrorMessage;\n\t}\n\npublic:\n\tstatic void subscribe( RTI::RTIambassador *rti );\n\t\t\nprivate:\n\tstatic std::string getUnsubscribeErrorMessage( void ) {\n\t\tstatic std::string unsubscribeErrorMessage = \"Error:  <%=classname%>:  could not unsubscribe:  \";\n\t\treturn unsubscribeErrorMessage;\n\t}\n\t\npublic:\n\tstatic void unsubscribe( RTI::RTIambassador *rti );\n\t\n\tstatic bool static_init( void );\n\t\n\tstatic bool match( int handle ) { return handle == get_handle(); }\n\n\tvirtual int getClassHandle( void ) const { return get_handle(); }\n\tvirtual std::string getClassName( void ) const { return get_class_name(); }\n\tvirtual StringVector get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names( void ) const { return get_<%=isinteraction?\"parameter\":\"attribute\"%>_names(); }\n\tvirtual StringVector getAll<%=isinteraction?\"Parameter\":\"Attribute\"%>Names( void ) const { return get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names(); }\n\n\tvirtual void publish<%=isinteraction?\"Interaction\":\"Object\"%>( RTI::RTIambassador *rti ) { publish( rti ); }\n\tvirtual void subscribe<%=isinteraction?\"Interaction\":\"Object\"%>( RTI::RTIambassador *rti ) { subscribe( rti ); }\n\n\tvirtual <%=isinteraction?\"Interaction\":\"Object\"%>Root::SP clone( void ) {\n\t\treturn <%=isinteraction?\"Interaction\":\"Object\"%>Root::SP(  new <%=classname%>( *this )  );\n\t}\n\n<% if(!isinteraction){%>\n\tvirtual const RTI::AttributeHandleSet &getSubscribedAttributeHandleSet( void ) { return getSubscribedAttributeHandleSet_var(); }\n<%}%>\n",
    "classcommon.java.ejs": "<% /*classcommon(isinteraction,classname,parentclassname,hlaclassname,datamembers,alldatamembers) */ %>\n\tprivate static boolean _isInitialized = false;\n\n\tprivate static int _handle;\n\n\t/**\n\t* Returns the handle (RTI assigned) of the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\n\t* Note: As this is a static method, it is NOT polymorphic, and so, if called on\n\t* a reference will return the handle of the class pertaining to the reference,\\\n\t* rather than the handle of the class for the instance referred to by the reference.\n\t* For the polymorphic version of this method, use {@link #getClassHandle()}.\n\t*/\n\tpublic static int get_handle() { return _handle; }\n\n\t/**\n\t* Returns the fully-qualified (dot-delimited) name of the <%= classname %>\n\t* <%=isinteraction?\"interaction\":\"object\"%> class.\n\t* Note: As this is a static method, it is NOT polymorphic, and so, if called on\n\t* a reference will return the name of the class pertaining to the reference,\\\n\t* rather than the name of the class for the instance referred to by the reference.\n\t* For the polymorphic version of this method, use {@link #getClassName()}.\n\t*/\n\tpublic static String get_class_name() { return \"<%=hlaclassname%>\"; }\n\n\t/**\n\t* Returns the simple name (the last name in the dot-delimited fully-qualified\n\t* class name) of the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\n\t*/\n\tpublic static String get_simple_class_name() { return \"<%= classname %>\"; }\n\n\tprivate static Set< String > _datamemberNames = new HashSet< String >();\n\tprivate static Set< String > _allDatamemberNames = new HashSet< String >();\n\n\t/**\n\t* Returns a set containing the names of all of the non-hidden <%=isinteraction?\"parameter\":\"attribute\"%>s in the\n\t* <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\n\t* Note: As this is a static method, it is NOT polymorphic, and so, if called on\n\t* a reference will return a set of parameter names pertaining to the reference,\\\n\t* rather than the parameter names of the class for the instance referred to by\n\t* the reference.  For the polymorphic version of this method, use\n\t* {@link #get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names()}.\n\t*/\n\tpublic static Set< String > get_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\n\t\treturn new HashSet< String >( _datamemberNames );\n\t}\n\n\n\t/**\n\t* Returns a set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s in the\n\t* <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\n\t* Note: As this is a static method, it is NOT polymorphic, and so, if called on\n\t* a reference will return a set of parameter names pertaining to the reference,\\\n\t* rather than the parameter names of the class for the instance referred to by\n\t* the reference.  For the polymorphic version of this method, use\n\t* {@link #get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names()}.\n\t*/\n\tpublic static Set< String > get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\n\t\treturn new HashSet< String >( _allDatamemberNames );\n\t}\n\n\n\t<% if(!isinteraction){ %>\n\tprivate static AttributeHandleSet _publishedAttributeHandleSet;\n\tprivate static Set< String > _publishAttributeNameSet = new HashSet< String >();\n\n\tprivate static AttributeHandleSet _subscribedAttributeHandleSet; \n\tprivate static Set< String > _subscribeAttributeNameSet = new HashSet< String >();\n\n\t<%}%>\n\n\tstatic {\n\t\t_classNameSet.add( \"<%= hlaclassname %>\" );\n\t\t_classNameClassMap.put( \"<%= hlaclassname %>\", <%= classname %>.class );\n\t\t\n\t\t_datamemberClassNameSetMap.put( \"<%= hlaclassname %>\", _datamemberNames );\n\t\t_allDatamemberClassNameSetMap.put( \"<%= hlaclassname %>\", _allDatamemberNames );\n\n\t\t<%/*alldatamembers:initDatamemberNameSet()*/%>\n\t\t<% alldatamembers.forEach(function(datamember){%>\n\t\t<% if(!datamember.hidden){ %>_datamemberNames.add( \"<%=datamember.name%>\" );<%}%><%}); %>\n\t\t<%/*alldatamembers:initAllDatamemberNameSet()*/%>\n\t\t<% alldatamembers.forEach(function(datamember){%>\n\t\t_allDatamemberNames.add( \"<%=datamember.name%>\" );<%}); %>\n\t\t<%/*datamembers:initDatamemberTypeMap()*/%>\n\t\t<% datamembers.forEach(function(datamember){%>\n\t\t_datamemberTypeMap.put( \"<%=datamember.name%>\", \"<%=datamember.parameterType%>\" );<%}); %>\n\t<% if(isinteraction){ %>\n\t<% }else{ %>\n\n\t\t_classNamePublishAttributeNameMap.put( \"<%= hlaclassname %>\", _publishAttributeNameSet );\n\t\t_publishedAttributeHandleSet = _factory.createAttributeHandleSet();\n\t\t_classNamePublishedAttributeMap.put( \"<%= hlaclassname %>\", _publishedAttributeHandleSet );\n\n\t\t_classNameSubscribeAttributeNameMap.put( \"<%= hlaclassname %>\", _subscribeAttributeNameSet );\n\t\t_subscribedAttributeHandleSet = _factory.createAttributeHandleSet();\n\t\t_classNameSubscribedAttributeMap.put( \"<%= hlaclassname %>\", _subscribedAttributeHandleSet );\n\t<%}%>\n\n\t}\n\n\n\tprivate static String initErrorMessage = \"Error:  <%= hlaclassname %>:  could not initialize:  \";\n\tprotected static void init( RTIambassador rti ) {\n\t\tif ( _isInitialized ) return;\n\t\t_isInitialized = true;\n\t\t\n\t\t<% if(parentclassname){ %><%=parentclassname%>.init( rti );<%}%>\n\t\t\n\t\tboolean isNotInitialized = true;\n\t\twhile( isNotInitialized ) {\n\t\t\ttry {\n\t\t\t\t_handle = rti.get<%=isinteraction?\"Interaction\":\"Object\"%>ClassHandle( \"<%= hlaclassname %>\" );\n\t\t\t\tisNotInitialized = false;\n\t\t\t} catch ( FederateNotExecutionMember f ) {\n\t\t\t\tSystem.err.println( initErrorMessage + \"Federate Not Execution Member\" );\n\t\t\t\tf.printStackTrace();\n\t\t\t\treturn;\t\t\t\t\n\t\t\t} catch ( NameNotFound n ) {\n\t\t\t\tSystem.err.println( initErrorMessage + \"Name Not Found\" );\n\t\t\t\tn.printStackTrace();\n\t\t\t\treturn;\t\t\t\t\n\t\t\t} catch ( Exception e ) {\n\t\t\t\te.printStackTrace();\n\t\t\t\ttry { Thread.sleep( 50 ); } catch( Exception e1 ) { }\t\t\t\t\t\n\t\t\t}\n\t\t}\n\n\t\t_classNameHandleMap.put( \"<%= hlaclassname %>\", get_handle() );\n\t\t_classHandleNameMap.put( get_handle(), \"<%= hlaclassname %>\" );\n\t\t_classHandleSimpleNameMap.put( get_handle(), \"<%= classname %>\" );\n\n\t\t<% if(datamembers && datamembers.length > 0){ %>\n\t\tisNotInitialized = true;\n\t\twhile( isNotInitialized ) {\n\t\t\ttry {<%/*datamembers:handle_init()*/%>\n\t\t\t\t<% datamembers.forEach(function(datamember){%>\t\t\t\n\t\t\t\t_<%=datamember.name%>_handle = rti.get<%=isinteraction?\"Parameter\":\"Attribute\"%>Handle( \"<%=datamember.name%>\", get_handle() );<%}); %>\n\t\t\t\tisNotInitialized = false;\n\t\t\t} catch ( FederateNotExecutionMember f ) {\n\t\t\t\tSystem.err.println( initErrorMessage + \"Federate Not Execution Member\" );\n\t\t\t\tf.printStackTrace();\n\t\t\t\treturn;\t\t\t\t\n\t\t\t} catch ( <%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined i ) {\n\t\t\t\tSystem.err.println( initErrorMessage + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" );\n\t\t\t\ti.printStackTrace();\n\t\t\t\treturn;\t\t\t\t\n\t\t\t} catch ( NameNotFound n ) {\n\t\t\t\tSystem.err.println( initErrorMessage + \"Name Not Found\" );\n\t\t\t\tn.printStackTrace();\n\t\t\t\treturn;\t\t\t\t\n\t\t\t} catch ( Exception e ) {\n\t\t\t\te.printStackTrace();\n\t\t\t\ttry { Thread.sleep( 50 ); } catch( Exception e1 ) { }\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\t<%/*  datamembers: { d |<initDatamemberNameHandleMap(hlaclassname=hlaclassname,datamember=d)>}  */%>\n\t\t\t<% datamembers.forEach(function(datamember){%>\n\t\t_datamemberNameHandleMap.put( \"<%=hlaclassname%>,<%=datamember.name%>\", get_<%=datamember.name%>_handle() );<%}); %>\n\t\t\t<%/*datamembers:initDatamemberHandleNameMap()*/%>\n\t\t\t<% datamembers.forEach(function(datamember){%>\n\t\t_datamemberHandleNameMap.put( get_<%=datamember.name%>_handle(), \"<%=datamember.name%>\" );<%}); %>\n\t\t<%}%>\n\t}\n\n\n\tprivate static boolean _isPublished = false;\n\tprivate static String publishErrorMessage = \"Error:  <%= hlaclassname %>:  could not publish:  \";\n\n\t/**\n\t* Publishes the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class for a federate.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic static void publish( RTIambassador rti ) {\n\t\tif ( _isPublished ) return;\n\t\t\n\t\tinit( rti );\n\n\t<% if(isinteraction){ %><% }else{ %>\t\n\t\t_publishedAttributeHandleSet.empty();\n\t\tfor( String attributeName : _publishAttributeNameSet ) {\n\t\t\ttry {\n\t\t\t\t_publishedAttributeHandleSet.add(  _datamemberNameHandleMap.get( \"<%= hlaclassname %>,\" + attributeName )  );\n\t\t\t} catch ( Exception e ) {\n\t\t\t\tSystem.err.println( publishErrorMessage + \"Could not publish \\\"\" + attributeName + \"\\\" attribute.\" );\n\t\t\t}\n\t\t}\n\t<%}%>\n\n\t\tsynchronized( rti ) {\n\t\t\tboolean isNotPublished = true;\n\t\t\twhile( isNotPublished ) {\n\t\t\t\ttry {\n\t\t\t\t\trti.publish<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle()<% if(isinteraction){ %><% }else{ %>, _publishedAttributeHandleSet<%}%> );\n\t\t\t\t\tisNotPublished = false;\n\t\t\t\t} catch ( FederateNotExecutionMember f ) {\n\t\t\t\t\tSystem.err.println( publishErrorMessage + \"Federate Not Execution Member\" );\n\t\t\t\t\tf.printStackTrace();\n\t\t\t\t\treturn;\n\t\t\t\t} catch ( <%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined i ) {\n\t\t\t\t\tSystem.err.println( publishErrorMessage + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" );\n\t\t\t\t\ti.printStackTrace();\n\t\t\t\t\treturn;\n\t\t\t\t} catch ( Exception e ) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\ttry { Thread.sleep( 50 ); } catch( Exception e1 ) { }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t_isPublished = true;\n\t}\n\n\tprivate static String unpublishErrorMessage = \"Error:  <%= hlaclassname %>:  could not unpublish:  \";\n\t/**\n\t* Unpublishes the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class for a federate.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic static void unpublish( RTIambassador rti ) {\n\t\tif ( !_isPublished ) return;\n\t\t\n\t\tinit( rti );\n\t\tsynchronized( rti ) {\n\t\t\tboolean isNotUnpublished = true;\n\t\t\twhile( isNotUnpublished ) {\n\t\t\t\ttry {\n\t\t\t\t\trti.unpublish<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle() );\n\t\t\t\t\tisNotUnpublished = false;\n\t\t\t\t} catch ( FederateNotExecutionMember f ) {\n\t\t\t\t\tSystem.err.println( unpublishErrorMessage + \"Federate Not Execution Member\" );\n\t\t\t\t\tf.printStackTrace();\n\t\t\t\t\treturn;\n\t\t\t\t} catch ( <%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined i ) {\n\t\t\t\t\tSystem.err.println( unpublishErrorMessage + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" );\n\t\t\t\t\ti.printStackTrace();\n\t\t\t\t\treturn;\n\t\t\t\t} catch ( <%=isinteraction?\"Interaction\":\"Object\"%>ClassNotPublished i ) {\n\t\t\t\t\tSystem.err.println( unpublishErrorMessage + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Published\" );\n\t\t\t\t\ti.printStackTrace();\n\t\t\t\t\treturn;\n\t\t\t\t} catch ( Exception e ) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\ttry { Thread.sleep( 50 ); } catch( Exception e1 ) { }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t_isPublished = false;\n\t}\n\n\tprivate static boolean _isSubscribed = false;\n\tprivate static String subscribeErrorMessage = \"Error:  <%= hlaclassname %>:  could not subscribe:  \";\n\t/**\n\t* Subscribes a federate to the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic static void subscribe( RTIambassador rti ) {\n\t\tif ( _isSubscribed ) return;\n\t\t\n\t\tinit( rti );\n\t<% if(isinteraction){ %><% }else{ %>\t\n\t\t_subscribedAttributeHandleSet.empty();\n\t\tfor( String attributeName : _subscribeAttributeNameSet ) {\n\t\t\ttry {\n\t\t\t\t_subscribedAttributeHandleSet.add(  _datamemberNameHandleMap.get( \"<%= hlaclassname %>,\" + attributeName )  );\n\t\t\t} catch ( Exception e ) {\n\t\t\t\tSystem.err.println( subscribeErrorMessage + \"Could not subscribe to \\\"\" + attributeName + \"\\\" attribute.\" );\n\t\t\t}\n\t\t}\n\t<%}%>\n\t\t\n\t\tsynchronized( rti ) {\n\t\t\tboolean isNotSubscribed = true;\n\t\t\twhile( isNotSubscribed ) {\n\t\t\t\ttry {\n\t\t\t\t\trti.subscribe<% if(isinteraction){ %>InteractionClass( get_handle() )<% }else{ %>ObjectClassAttributes( get_handle(), _subscribedAttributeHandleSet )<%}%>;\n\t\t\t\t\tisNotSubscribed = false;\n\t\t\t\t} catch ( FederateNotExecutionMember f ) {\n\t\t\t\t\tSystem.err.println( subscribeErrorMessage + \"Federate Not Execution Member\" );\n\t\t\t\t\tf.printStackTrace();\n\t\t\t\t\treturn;\n\t\t\t\t} catch ( <%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined i ) {\n\t\t\t\t\tSystem.err.println( subscribeErrorMessage + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" );\n\t\t\t\t\ti.printStackTrace();\n\t\t\t\t\treturn;\n\t\t\t\t} catch ( Exception e ) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\ttry { Thread.sleep( 50 ); } catch( Exception e1 ) { }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t_isSubscribed = true;\n\t}\n\n\tprivate static String unsubscribeErrorMessage = \"Error:  <%= hlaclassname %>:  could not unsubscribe:  \";\n\t/**\n\t* Unsubscribes a federate from the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic static void unsubscribe( RTIambassador rti ) {\n\t\tif ( !_isSubscribed ) return;\n\n\t\tinit( rti );\n\t\tsynchronized( rti ) {\n\t\t\tboolean isNotUnsubscribed = true;\n\t\t\twhile( isNotUnsubscribed ) {\n\t\t\t\ttry {\n\t\t\t\t\trti.unsubscribe<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle() );\n\t\t\t\t\tisNotUnsubscribed = false;\n\t\t\t\t} catch ( FederateNotExecutionMember f ) {\n\t\t\t\t\tSystem.err.println( unsubscribeErrorMessage + \"Federate Not Execution Member\" );\n\t\t\t\t\tf.printStackTrace();\n\t\t\t\t\treturn;\n\t\t\t\t} catch ( <%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined i ) {\n\t\t\t\t\tSystem.err.println( unsubscribeErrorMessage + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" );\n\t\t\t\t\ti.printStackTrace();\n\t\t\t\t\treturn;\n\t\t\t\t} catch ( <%=isinteraction?\"Interaction\":\"Object\"%>ClassNotSubscribed i ) {\n\t\t\t\t\tSystem.err.println( unsubscribeErrorMessage + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Subscribed\" );\n\t\t\t\t\ti.printStackTrace();\n\t\t\t\t\treturn;\n\t\t\t\t} catch ( Exception e ) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\ttry { Thread.sleep( 50 ); } catch( Exception e1 ) { }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t_isSubscribed = false;\n\t}\n\n\t/**\n\t* Return true if \"handle\" is equal to the handle (RTI assigned) of this class\n\t* (that is, the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class).\n\t*\n\t* @param handle handle to compare to the value of the handle (RTI assigned) of\n\t* this class (the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class).\n\t* @return \"true\" if \"handle\" matches the value of the handle of this class\n\t* (that is, the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class).\n\t*/\n\tpublic static boolean match( int handle ) { return handle == get_handle(); }\n\n\t/**\n\t* Returns the handle (RTI assigned) of this instance's <%=isinteraction?\"interaction\":\"object\"%> class .\n\t* \n\t* @return the handle (RTI assigned) if this instance's <%=isinteraction?\"interaction\":\"object\"%> class\n\t*/\n\tpublic int getClassHandle() { return get_handle(); }\n\n\t/**\n\t* Returns the fully-qualified (dot-delimited) name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class.\n\t* \n\t* @return the fully-qualified (dot-delimited) name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class\n\t*/\n\tpublic String getClassName() { return get_class_name(); }\n\n\t/**\n\t* Returns the simple name (last name in its fully-qualified dot-delimited name)\n\t* of this instance's <%=isinteraction?\"interaction\":\"object\"%> class.\n\t* \n\t* @return the simple name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class \n\t*/\n\tpublic String getSimpleClassName() { return get_simple_class_name(); }\n\n\t/**\n\t* Returns a set containing the names of all of the non-hidden<%=isinteraction?\"parameter\":\"attribute\"%>s of an\n\t* <%=isinteraction?\"interaction\":\"object\"%> class instance.\n\t*\n\t* @return set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\n\t* <%=isinteraction?\"interaction\":\"object\"%> class instance\n\t*/\n\tpublic Set< String > get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names() { return get_<%=isinteraction?\"parameter\":\"attribute\"%>_names(); }\n\n\t/**\n\t* Returns a set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\n\t* <%=isinteraction?\"interaction\":\"object\"%> class instance.\n\t*\n\t* @return set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\n\t* <%=isinteraction?\"interaction\":\"object\"%> class instance\n\t*/\n\tpublic Set< String > getAll<%=isinteraction?\"Parameter\":\"Attribute\"%>Names() { return get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names(); }\n\n\t/**\n\t* Publishes the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of the class for a federate.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic void publish<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti ) { publish( rti ); }\n\n\t/**\n\t* Unpublishes the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class for a federate.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic void unpublish<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti ) { unpublish( rti ); }\n\n\t/**\n\t* Subscribes a federate to the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic void subscribe<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti ) { subscribe( rti ); }\n\n\t/**\n\t* Unsubscribes a federate from the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic void unsubscribe<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti ) { unsubscribe( rti ); }\n\n\t<% if(isinteraction){ %><% }else{ %>\n\t/**\n\t* Returns a data structure containing the handles of all attributes for this object\n\t* class that are currently marked for subscription.  To actually subscribe to these\n\t* attributes, a federate must call <objectclassname>.subscribe( RTIambassador rti ).\n\t*\n\t* @return data structure containing the handles of all attributes for this object\n\t* class that are currently marked for subscription\n\t*/\n\tpublic AttributeHandleSet getSubscribedAttributeHandleSet() { return _subscribedAttributeHandleSet; }\n\t<%}%>\n\n\tpublic String toString() {\n\t\treturn \"<%= classname %>(\"\n\t\t\t<%/*datamembers:stringValue(); separator=\"+ \\\",\\\"\"*/%>\n\t\t\t<%var separator = false; datamembers.forEach(function(datamember){%>\n\t\t\t<%if(separator){%>+ \",\" <%}else{separator=true;}%>+ \"<%=datamember.name%>:\" + get_<%=datamember.name%>()<%});%>\n\t\t\t+ \")\";\n\t}",
    "classroot.cpp.ejs": "<% /* THIS IS THE ROOT CLASS OF EITHER THE INTERACTION OR OBJECT-CLASS HEIRARCHY (I.E. \"InteractionRoot\" OR \"ObjectRoot\") */ %>\n<% /*classroot(isinteraction) ::= <<*/ %>\n// This code has been generated by the C2W code generator.\n// Do not edit manually!\n\n/*\n * Copyright (c) 2008, Institute for Software Integrated Systems, Vanderbilt University\n * All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose, without fee, and without written agreement is\n * hereby granted, provided that the above copyright notice, the following\n * two paragraphs and the author appear in all copies of this software.\n *\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * @author Himanshu Neema\n * @author Harmon Nine\n */\n\n#include <boost/lexical_cast.hpp>\n#include \"<%=isinteraction?\"Interaction\":\"Object\"%>Root.hpp\"\n\nC2WLogger* <%=isinteraction?\"Interaction\":\"Object\"%>Root::_logger = &C2W_RTI_LOGGER_CLS::get_singleton();\n\n<% /*classcommon(classname=apMap.classfirstupper+\"Root\",hlaclassname=apMap.classfirstupper+\"Root\",...)*/ %>\n<%- ejs.render(TEMPLATES[\"classcommon.cpp.ejs\"],\n\t{\tisinteraction: isinteraction,\n\t\tclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\n\t\tparentclassname: \"\",\n\t\thlaclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\n\t\tdatamembers: [],\n\t\talldatamembers: []\n}) %>\n\n<% if(!isinteraction){ %>\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::publish( const std::string &className, const std::string &attributeName ) {\n\tNameStringVectorPtrMap::iterator camItr = getClassNamePublishAttributeNameVectorPtrMap().find( className );\n\tif ( camItr == getClassNamePublishAttributeNameVectorPtrMap().end() ) {\n\t\tstd::cerr << \"ERROR:  ObjectRoot.publish:  could not publish class \\\"\" << className << \"\\\" \\\"\" << attributeName << \"\\\" attribute.\" << std::endl;\n\t\treturn;\n\t}\n\tNameStringVectorPtrMap::iterator dnsItr = getAllDatamemberClassNameVectorPtrMap().find( className );\n\tif ( dnsItr == getAllDatamemberClassNameVectorPtrMap().end() ) {\n\t\tstd::cerr << \"ERROR:  ObjectRoot.publish:  unexpected error:  no datamember vector for class \\\"\" << className << \"\\\"\" << std::endl;\n\t\treturn;\n\t}\n\tif (  std::find ( dnsItr->second->begin(), dnsItr->second->end(), attributeName ) == dnsItr->second->end()  ) {\n\t\tstd::cerr << \"ERROR:  ObjectRoot.publish:  no datamember named \\\"\" << attributeName << \"\\\" in class \\\"\" << className << \"\\\"\" << std::endl;\n\t\treturn;\n\t}\n\tcamItr->second->push_back( attributeName );\n}\n\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::subscribe( const std::string &className, const std::string &attributeName ) {\n\tNameStringVectorPtrMap::iterator camItr = getClassNameSubscribeAttributeNameVectorPtrMap().find( className );\n\tif ( camItr == getClassNameSubscribeAttributeNameVectorPtrMap().end() ) {\n\t\tstd::cerr << \"ERROR:  ObjectRoot.subscribe:  could not subscribe class \\\"\" << className << \"\\\" \\\"\" << attributeName << \"\\\" attribute.\" << std::endl;\n\t\treturn;\n\t}\n\tNameStringVectorPtrMap::iterator dnsItr = getAllDatamemberClassNameVectorPtrMap().find( className );\n\tif ( dnsItr == getAllDatamemberClassNameVectorPtrMap().end() ) {\n\t\tstd::cerr << \"ERROR:  ObjectRoot.subscribe:  unexpected error:  no datamember vector for class \\\"\" << className << \"\\\"\" << std::endl;\n\t\treturn;\n\t}\n\tif (  std::find ( dnsItr->second->begin(), dnsItr->second->end(), attributeName ) == dnsItr->second->end()  ) {\n\t\tstd::cerr << \"ERROR:  ObjectRoot.subscribe:  no datamember named \\\"\" << attributeName << \"\\\" in class \\\"\" << className << \"\\\"\" << std::endl;\n\t\treturn;\n\t}\n\tcamItr->second->push_back( attributeName );\n}\n\n<%}%>\n\t\n<%=isinteraction?\"Interaction\":\"Object\"%>Root::SP <%=isinteraction?\"Interaction\":\"Object\"%>Root::create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) {\n\tIntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\n\tif ( ismItr == getClassHandleNameMap().end() ) {\n\t\treturn SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 );\n\t}\n\t\n\tClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( ismItr->second );\n\tif ( cfmItr == getClassNameFactoryMap().end() ) {\n\t\treturn SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 );\n\t}\n\t\n\tSP sp = (*cfmItr->second)();\n\tsp->set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\n\n\treturn sp;\n}\n\n<%=isinteraction?\"Interaction\":\"Object\"%>Root::SP <%=isinteraction?\"Interaction\":\"Object\"%>Root::create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime ) {\n\tIntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\n\tif ( ismItr == getClassHandleNameMap().end() ) {\n\t\treturn SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 );\n\t}\n\t\n\tClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( ismItr->second );\n\tif ( cfmItr == getClassNameFactoryMap().end() ) {\n\t\treturn SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 );\n\t}\n\t\n\tSP sp = (*cfmItr->second)();\n\tsp->set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\n\tsp->setTime( dlc13FedTime.getTime() );\n\n\treturn sp;\n}\n\n\n<% if(!isinteraction){ %>\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::requestUpdate( RTI::RTIambassador *rti ) {\n\tbool requestNotSubmitted = true;\n\twhile( requestNotSubmitted ) {\n\t\ttry {\t\t\n\t\t\trti->requestObjectAttributeValueUpdate( getObjectHandle(), getSubscribedAttributeHandleSet_var() );\n\t\t\trequestNotSubmitted = false;\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\n\t\t\tstd::cerr << \"ERROR: \" << getClassName() << \"request for update failed:  Federate Not Execution Member\" << std::endl;\n\t\t\treturn;\t\t\t\t\n\t\t} catch ( RTI::ObjectNotKnown & ) {\n\t\t\tstd::cerr << \"ERROR: \" << getClassName() << \"request for update failed:  Object Not Known\" << std::endl;\n\t\t\treturn;\t\t\t\t\n\t\t} catch ( RTI::AttributeNotDefined & ) {\n\t\t\tstd::cerr << \"ERROR: \" << getClassName() << \"request for update failed:  Name Not Found\" << std::endl;\n\t\t\treturn;\t\t\t\t\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << \"ERROR: \" << getClassName() << \"request for update failed:  Unknown Exception\" << std::endl;\t\t\t}\n\t}\n}\n\n<%}%>\n\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) {\n\tint size = datamemberMap.size();\n\tfor( int ix = 0 ; ix < size ; ++ix ) {\n\t\ttry {\n\t\t\tstatic RTI::ULong valueLength;\n\t\t\tchar *value = datamemberMap.getValuePointer( ix, valueLength );\n\t\t\tset<%=isinteraction?\"Parameter\":\"Attribute\"%>(  datamemberMap.getHandle( ix ), std::string( value, valueLength )  );\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << \"set<%=isinteraction?\"Parameter\":\"Attribute\"%>s: Exception caught!\" << std::endl;\n\t\t}\n\t}\n}\n\n<% if(isinteraction){ %>\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::sendInteraction( RTI::RTIambassador *rti, double time ) {\n\tbool interactionNotSent = true;\n\twhile( interactionNotSent ) {\n\t\ttry {\n\t\t\tParameterHandleValuePairSetSP datamembers = createDatamemberHandleValuePairSet( 0 );\n\t\t\trti->sendInteraction(  getClassHandle(), *datamembers, RTIfedTime( time ), 0  );\n\t\t\tcreateLog( time, true );\n\t\t\tinteractionNotSent = false;\n\t\t} catch ( RTI::InteractionClassNotDefined & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Class Not Defined\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::InteractionClassNotPublished & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Class Not Published\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::InteractionParameterNotDefined & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Parameter Not Defined\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::InvalidFederationTime & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Invalid Federation Time\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Federate Not Execution Member\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::ConcurrentAccessAttempted & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  ConcurrentAccessAttempted\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Exception caught ... retry\" << std::endl;\n#ifdef _WIN32\n\t\t\tSleep( 500 );\n#else\n\t\t\tusleep( 500000 );\n#endif\n\t\t}\n\t}\n}\n\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::sendInteraction( RTI::RTIambassador *rti ) {\n\tbool interactionNotSent = true;\n\twhile( interactionNotSent ) {\n\t\ttry {\n\t\t\tParameterHandleValuePairSetSP datamembers = createDatamemberHandleValuePairSet( 0 );\n\t\t\trti->sendInteraction(  getClassHandle(), *datamembers, 0  );\n\t\t\tcreateLog( 0, true );\n\t\t} catch ( RTI::InteractionClassNotDefined & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Class Not Defined\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::InteractionClassNotPublished & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Class Not Published\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::InteractionParameterNotDefined & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Parameter Not Defined\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Federate Not Execution Member\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( RTI::ConcurrentAccessAttempted & ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  ConcurrentAccessAttempted\" << std::endl;\n\t\t\treturn;\n\t\t} catch ( ... ) {\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Exception caught ... retry\" << std::endl;\n#ifdef _WIN32\n\t\t\tSleep( 500 );\n#else\n\t\t\tusleep( 500000 );\n#endif\n\t\t}\n\t}\n}\n\nstd::string <%=isinteraction?\"Interaction\":\"Object\"%>Root::fedName = \"\";\nbool <%=isinteraction?\"Interaction\":\"Object\"%>Root::enablePubLog = false;\nbool <%=isinteraction?\"Interaction\":\"Object\"%>Root::enableSubLog = false;\nstd::string <%=isinteraction?\"Interaction\":\"Object\"%>Root::pubLogLevel = \"\";\nstd::string <%=isinteraction?\"Interaction\":\"Object\"%>Root::subLogLevel = \"\";\n\nvoid InteractionRoot::enablePublishLog( const std::string &interaction, const std::string &fed, const std::string &thislevel, const std::string &globallevel ) {\n\tif ( globallevel.empty() ) {\n\t\treturn;\n\t}\n\tif (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {\n\t\treturn;\n\t}\n\tfedName = fed;\n\tenablePubLog = true;\n\tpubLogLevel = thislevel;\n\t_logger->addLog(interaction, fedName, true);\n}\n\nvoid InteractionRoot::enableSubscribeLog( const std::string &interaction, const std::string &fed, const std::string &thislevel, const std::string &globallevel ) {\n\tif ( globallevel.empty() ) {\n\t\treturn;\n\t}\n\tif (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {\n\t\treturn;\n\t}\n\tfedName = fed;\n\tenableSubLog = true;\n\tsubLogLevel = thislevel;\n\t_logger->addLog( interaction, fedName, false );\n}\n\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::createLog( double time, bool isPub ) {\n\tif (  ( isPub && !enablePubLog ) || ( !isPub && !enableSubLog )  ) {\n\t\treturn;\n\t}\n\n\tstd::string interactionId;\n\tif ( isPub ) {\n\t\tinteractionId = \"pub_\" + getClassName();\n\t\tif ( !fedName.empty() ) {\n\t\t\tinteractionId = fedName + \"_\" + interactionId;\n\t\t}\n\t} else {\n\t\tinteractionId = getClassName() + \"_sub\";\n\t\tif ( !fedName.empty() ) {\n\t\t\tinteractionId += \"_\" + fedName;\n\t\t}\n\t}\n\t\n\t_logger->addLog( interactionId, *this, time, pubLogLevel );\n}\n\n<%}else{%>\nvoid ObjectRoot::registerObject( RTI::RTIambassador *rti ) {\n    \n    while( !_isRegistered ) {\n        try {\n            _object_handle = rti->registerObjectInstance( getClassHandle() );\n            _isRegistered = true;\n        } catch ( RTI::ObjectClassNotDefined & ) {\n        \tstd::cerr << \"ERROR:  InteractionRoot::registerObject:  Object Class Not Defined\" << std::endl;\n            return;\n        } catch ( RTI::ObjectClassNotPublished & ) {\n        \tstd::cerr << \"ERROR:  InteractionRoot::registerObject:  Object Class Not Published\" << std::endl;\n            return;\n        } catch ( RTI::FederateNotExecutionMember & ) {\n        \tstd::cerr << \"ERROR:  InteractionRoot::registerObject:  Federate Not Execution Member\" << std::endl;\n            return;\n        } catch ( ... ) {\n        \tstd::cerr << \"InteractionRoot::registerObject:  Exception caught ... retry\" << std::endl;\n        }\n    }\n\n}\n\nvoid ObjectRoot::unregisterObject( RTI::RTIambassador *rti ) {\n    \n    while( _isRegistered ) {\n        try {\n            rti->deleteObjectInstance( getObjectHandle(), 0 );\n            _isRegistered = false;\n        } catch ( RTI::ObjectNotKnown & ) {\n        \tstd::cerr << \"ERROR:  InteractionRoot::unregisterObject:  Object Not Known\" << std::endl;\n            return;\n        } catch ( RTI::DeletePrivilegeNotHeld & ) {\n        \tstd::cerr << \"ERROR:  InteractionRoot::unregisterObject:  Delete Privilege Not Held\" << std::endl;\n            return;\n        } catch ( RTI::FederateNotExecutionMember & ) {\n        \tstd::cerr << \"ERROR:  InteractionRoot::unregisterObject:  Federate Not Execution Member\" << std::endl;\n            return;\n        } catch ( ... ) {\n        \tstd::cerr << \"InteractionRoot::unregisterObject:  Exception caught ... retry\" << std::endl;\n        }\n    }\n}\n\nvoid ObjectRoot::updateAttributeValues( RTI::RTIambassador *rti, double time, bool force ) {\n\n    AttributeHandleValuePairSetSP suppliedAttributesSP = createDatamemberHandleValuePairSet( force );\n    if ( suppliedAttributesSP->size() == 0 ) {\n    \treturn;\n    }\n\n    try {\n        rti->updateAttributeValues(  getObjectHandle(), *suppliedAttributesSP, RTIfedTime( time ), 0  );\n        createLog( time, true );\n    } catch ( RTI::ObjectNotKnown & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Object Not Known\" << std::endl;\n        return;\n    } catch ( RTI::FederateNotExecutionMember & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Federate Not Execution Member\" << std::endl;\n        return;\n    } catch ( RTI::AttributeNotDefined & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Attribute Not Defined\" << std::endl;\n        return;\n    } catch ( RTI::AttributeNotOwned & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Attribute Not Owned\" << std::endl;\n        return;\n    } catch ( RTI::ConcurrentAccessAttempted & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Concurrent Access Attempted\" << std::endl;\n        return;\n    } catch ( RTI::InvalidFederationTime & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Invalid Federation Time\" << std::endl;\n        return;\n    } catch ( ... ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  exception caught\" << std::endl;\n    }\n}\n\nvoid ObjectRoot::updateAttributeValues( RTI::RTIambassador *rti, bool force ) {\n\n    AttributeHandleValuePairSetSP suppliedAttributesSP = createDatamemberHandleValuePairSet( force );\n    if ( suppliedAttributesSP->size() == 0 ) {\n    \treturn;\n    }\n\n    try {\n        rti->updateAttributeValues( getObjectHandle(), *suppliedAttributesSP, 0 );\n        createLog( 0, true );\n    } catch ( RTI::ObjectNotKnown & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Object Not Known\" << std::endl;\n        return;\n    } catch ( RTI::FederateNotExecutionMember & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Federate Not Execution Member\" << std::endl;\n        return;\n    } catch ( RTI::AttributeNotDefined & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Attribute Not Defined\" << std::endl;\n        return;\n    } catch ( RTI::AttributeNotOwned & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Attribute Not Owned\" << std::endl;\n        return;\n    } catch ( RTI::ConcurrentAccessAttempted & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Concurrent Access Attempted\" << std::endl;\n        return;\n    } catch ( RTI::InvalidFederationTime & ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Invalid Federation Time\" << std::endl;\n        return;\n    } catch ( ... ) {\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  exception caught\" << std::endl;\n    }\n}\n\nstd::string ObjectRoot::fedName = \"\";\n\nvoid ObjectRoot::enablePublishLog(const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel) {\n\n\tif ( globallevel.empty() ) {\n\t\treturn;\n\t}\n\tif (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {\n\t\treturn;\n\t}\n\tfedName = fed;\n\tgetPubAttributeLogMap().insert(  make_pair( attribute, thislevel )  );\n\t_logger->addLog( object, attribute, fed, true );\n}\n\nvoid ObjectRoot::enableSubscribeLog( const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel ) {\n\tif ( globallevel.empty() ) {\n\t\treturn;\n\t}\n\tif (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {\n\t\treturn;\n\t}\n\tfedName = fed;\n\tgetSubAttributeLogMap().insert(  make_pair( attribute, thislevel )  );\n\t_logger->addLog( object, attribute, fed, false );\n}\n\nvoid ObjectRoot::createLog( double time, bool isPub ) {\n\n\tif ( getPubAttributeLogMap().empty() ) {\n\t\treturn;\n\t}\n\tstd::string id = isPub ? fedName + \"_pub_\" + getClassName() : getClassName() + \"_sub_\" + fedName;\n\t_logger->addLog( id, *this, time );\n}\n\n<%}%>\n",
    "classroot.hpp.ejs": "\n<% /* THIS IS THE ROOT CLASS OF EITHER THE INTERACTION OR OBJECT-CLASS HEIRARCHY (I.E. \"InteractionRoot\" OR \"ObjectRoot\") */\n/*classroot(isinteraction) ::= <<*/ %>\n/*\n * Copyright (c) 2008, Institute for Software Integrated Systems, Vanderbilt University\n * All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose, without fee, and without written agreement is\n * hereby granted, provided that the above copyright notice, the following\n * two paragraphs and the author appear in all copies of this software.\n *\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * @author Himanshu Neema\n * @author Harmon Nine\n */\n\n// This code has been generated by the C2W code generator.\n// Do not edit manually!\n\n/*\n * \tNOTE:  ALL \"if\" STATEMENTS IN THIS CODE THAT HAD THE FORM:\n *\n *  if (condition) statement;\n *\n *\tOR\n *\n *  if (condition) statement1;\n *  else           statement2;\n *\n *  HAVE BEEN CONVERTED TO THE FORMS:\n *\n *  if (condition) {\n *\t\tstatement;\n *\t}\n *\n *\tAND\n *\n *  if (condition) {\n *\t\tstatement1;\n *\t} else {\n *\t\tstatement2;\n *\t}\n *\n *\tRESPECTIVELY.  THIS IS BECAUSE THE OMNET DEBUGGER APPEARS TO HAVE A PROBLEM\n *  WITH THE NON-BRACED FORMS OF THE IF STATEMENT.  *PLEASE* DO NOT CHANGE IT BACK.\n *  -- H.S.N.\n *\n */\n\n<% if(isinteraction){ %>\n#ifndef _INTERACTION_ROOT\n#define _INTERACTION_ROOT\n<% }else{ %>\n#ifndef _OBJECT_ROOT\n#define _OBJECT_ROOT\n<%}%>\n\n#ifndef _CRT_SECURE_NO_DEPRECATE\n#define _CRT_SECURE_NO_DEPRECATE\n#endif\n\n#ifndef RTI_USES_STD_FSTREAM\n#define RTI_USES_STD_FSTREAM\n#endif\n\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <set>\n#include <map>\n#include <list>\n#include <ctype.h>\n#include <stdlib.h>\n\n#include <boost/shared_ptr.hpp>\n\n#include <TypeMedley.hpp>\n#include <StringCollections.hpp>\n\n#include \"RTI.hh\"\n#include \"fedtime.hh\"\n\n#ifdef _WIN32\n#include <windows.h>\n#else\n#include <unistd.h>\n#endif\n\n#include \"RTILogger.hpp\"\n\n#ifndef C2W_RTI_LOGGER_CLS\n#define C2W_RTI_LOGGER_CLS C2WConsoleLogger\n#endif \n\n#include \"<%=isinteraction?\"Interaction\":\"Object\"%>If.hpp\"\n\nclass <%=isinteraction?\"Interaction\":\"Object\"%>Root : public <%=isinteraction?\"Interaction\":\"Object\"%>If{\npublic:\n\ttypedef std::map< std::string, StringSet * > NameStringSetPtrMap;\n\ttypedef std::map< std::string, StringVector * > NameStringVectorPtrMap;\n\ttypedef std::map< std::string, int > StringIntegerMap;\n\ttypedef std::map< int, std::string > IntegerStringMap;\n\n\ttypedef boost::shared_ptr< <%=isinteraction?\"Interaction\":\"Object\"%>Root > SP;\n\ttypedef boost::shared_ptr< RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet > <%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP;\n\t\n\ttypedef SP (*FactoryFunctionPtr)( void );\n\ttypedef std::map< std::string, FactoryFunctionPtr > ClassNameFactoryMap;\n\n\ttypedef void (*PubsubFunctionPtr)( RTI::RTIambassador * );\n\ttypedef std::map< std::string, PubsubFunctionPtr > ClassNamePubSubMap;\n\ttypedef std::map< std::string, std::string> DatamemberTypeMap;\n\t\n\t\n<% if(!isinteraction){ %>\n\ttypedef std::map< std::string, RTI::AttributeHandleSet * > ClassNameAttributesPtrMap;\n\ttypedef std::map< int, SP > ObjectMap;\n<%}%>\n\n\tstatic DatamemberTypeMap &getDatamemberTypeMap( void ) {\n\t\tstatic DatamemberTypeMap datamemberTypeMap;\n\t\treturn datamemberTypeMap;\n\t}\n\nprotected:\n\tstatic StringSet &getClassNameSet( void ) {\n\t\tstatic StringSet classNameSet;\n\t\treturn classNameSet;\n\t}\n\n\tstatic ClassNameFactoryMap &getClassNameFactoryMap( void ) {\n\t\tstatic ClassNameFactoryMap classNameFactoryMap;\n\t\treturn classNameFactoryMap;\n\t}\n\t\n\tstatic ClassNamePubSubMap &getClassNamePublishMap( void ) {\n\t\tstatic ClassNamePubSubMap classNamePublishMap;\n\t\treturn classNamePublishMap;\n\t}\n\n\tstatic ClassNamePubSubMap &getClassNameUnpublishMap( void ) {\n\t\tstatic ClassNamePubSubMap classNameUnpublishMap;\n\t\treturn classNameUnpublishMap;\n\t}\n\n\tstatic ClassNamePubSubMap &getClassNameSubscribeMap( void ) {\n\t\tstatic ClassNamePubSubMap classNameSubscribeMap;\n\t\treturn classNameSubscribeMap;\n\t}\n\n\tstatic ClassNamePubSubMap &getClassNameUnsubscribeMap( void ) {\n\t\tstatic ClassNamePubSubMap classNameUnsubscribeMap;\n\t\treturn classNameUnsubscribeMap;\n\t}\n\n\tstatic NameStringVectorPtrMap &getDatamemberClassNameVectorPtrMap( void ) {\n\t\tstatic NameStringVectorPtrMap datamemberClassNameVectorPtrMap;\n\t\treturn datamemberClassNameVectorPtrMap;\n\t}\n\n\tstatic NameStringVectorPtrMap &getAllDatamemberClassNameVectorPtrMap( void ) {\n\t\tstatic NameStringVectorPtrMap allDatamemberClassNameVectorPtrMap;\n\t\treturn allDatamemberClassNameVectorPtrMap;\n\t}\n\n\tstatic StringIntegerMap &getClassNameHandleMap( void ) {\n\t\tstatic StringIntegerMap classNameHandleMap;\n\t\treturn classNameHandleMap;\n\t}\n\tstatic IntegerStringMap &getClassHandleNameMap( void ) {\n\t\tstatic IntegerStringMap classHandleNameMap;\n\t\treturn classHandleNameMap;\n\t}\n\n\tstatic StringIntegerMap &getDatamemberNameHandleMap( void ) {\n\t\tstatic StringIntegerMap datamemberNameHandleMap;\n\t\treturn datamemberNameHandleMap;\n\t}\n\tstatic IntegerStringMap &getDatamemberHandleNameMap( void ) {\n\t\tstatic IntegerStringMap datamemberHandleNameMap;\n\t\treturn datamemberHandleNameMap;\n\t}\n\n<% if(!isinteraction){ %>\n\tstatic NameStringVectorPtrMap &getClassNamePublishAttributeNameVectorPtrMap( void ) {\n\t\tstatic NameStringVectorPtrMap classNamePublishAttributeNameVectorPtrMap;\n\t\treturn classNamePublishAttributeNameVectorPtrMap;\n\t}\n\tstatic NameStringVectorPtrMap &getClassNameSubscribeAttributeNameVectorPtrMap( void ) {\n\t\tstatic NameStringVectorPtrMap classNameSubscribeAttributeNameVectorPtrMap;\n\t\treturn classNameSubscribeAttributeNameVectorPtrMap;\n\t}\n\t\n\tstatic ClassNameAttributesPtrMap &getClassNamePublishedAttributesPtrMap( void ) {\n\t\tstatic ClassNameAttributesPtrMap classNamePublishedAttributesPtrMap;\n\t\treturn classNamePublishedAttributesPtrMap;\n\t}\n\tstatic ClassNameAttributesPtrMap &getClassNameSubscribedAttributesPtrMap( void ) {\n\t\tstatic ClassNameAttributesPtrMap classNameSubscribedAttributesPtrMap;\n\t\treturn classNameSubscribedAttributesPtrMap;\n\t}\n\n\tstatic ObjectMap &getObjectMap( void ) {\n\t\tstatic ObjectMap objectMap;\n\t\treturn objectMap;\n\t}\n\n\ttemplate< typename S, typename T >\n\tclass Attribute {\n\tprivate:\n\t\tT _value;\n\t\tT _oldValue;\n\t\tbool _oldValueInit;\n\t\tdouble _time;\n\t\n\tpublic:\n\t\t\n\t\tAttribute( void ) : _value( 0 ), _oldValueInit( false ), _time( -1 ) { }\n\t\t\n\t\tT getValue( void ) const { return _value; }\n\t\tvoid setValue( T value ) { _value = value; }\n\t\t\n\t\tdouble getTime( void ) { return _time; }\n\t\tvoid setTime( double time ) { _time = time; }\n\t\t\n\t\tvoid setHasBeenUpdated( void ) {\n\t\t\t_oldValue = _value;\n\t\t\t_oldValueInit = true;\n\t\t}\n\t\t\n\t\tbool shouldBeUpdated( bool force ) { return force || !_oldValueInit || _oldValue != _value; }\n\t};\n\n\ttemplate< typename S >\n\tclass Attribute< S, std::string > {\n\tprivate:\n\t\tstd::string _value;\n\t\tstd::string _oldValue;\n\t\tbool _oldValueInit;\n\t\tdouble _time;\n\t\n\tpublic:\n\t\t\n\t\tAttribute( void ) : _oldValueInit( false ), _time( -1 ) { }\n\t\t\n\t\tconst std::string &getValue( void ) const { return _value; }\n\t\tvoid setValue( const std::string &value ) { _value = value; }\n\t\t\n\t\tdouble getTime( void ) { return _time; }\n\t\tvoid setTime( double time ) { _time = time; }\n\t\t\n\t\tvoid setHasBeenUpdated( void ) {\n\t\t\t_oldValue = _value;\n\t\t\t_oldValueInit = true;\n\t\t}\n\t\t\n\t\tbool shouldBeUpdated( bool force ) { return force || !_oldValueInit || _oldValue != _value; }\n\t};\n\t\n<%}%>\n\t\n<% /*classcommon(classname=apMap.classfirstupper+\"Root\",hlaclassname=apMap.classfirstupper+\"Root\",...)*/ -%>\n<%- ejs.render(\n\tTEMPLATES[\"classcommon.hpp.ejs\"],{\n\t\tisinteraction: isinteraction,\n\t\tclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\n\t\tparentclassname: \"\",\n\t\thlaclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\n\t\tdatamembers: [],\n\t\talldatamembers: []\n}) %>\npublic:\n\tstatic StringSet get_<%=isinteraction?\"interaction\":\"object\"%>_names( void ) { return getClassNameSet(); }\n\tstatic StringVector get_<%=isinteraction?\"parameter\":\"attribute\"%>_names( const std::string &className ) {\n\t\tNameStringVectorPtrMap::iterator nssItr = getDatamemberClassNameVectorPtrMap().find( className );\n\t\treturn nssItr == getDatamemberClassNameVectorPtrMap().end() ? StringVector() : *nssItr->second;\n\t}\n\t\n\tstatic StringVector get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names( const std::string &className ) {\n\t\tNameStringVectorPtrMap::iterator nssItr = getAllDatamemberClassNameVectorPtrMap().find( className );\n\t\treturn nssItr == getAllDatamemberClassNameVectorPtrMap().end() ? StringVector() : *nssItr->second;\n\t}\n\t\n\tstatic std::string get_class_name( int classHandle ) {\n\t\tIntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\n\t\treturn ismItr == getClassHandleNameMap().end() ? std::string() : ismItr->second;\n\t}\n\t\n\tstatic int get_handle( const std::string &className ) {\n\t\n\t\tStringIntegerMap::iterator simItr = getClassNameHandleMap().find( className );\n\t\tif ( simItr == getClassNameHandleMap().end() ) {\n\t\t\tstd::cerr << \"Bad class name \\\"\" << className << \"\\\" on get_handle.\" << std::endl;\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\treturn simItr->second;\n\t}\n\t\n\tstatic std::string get_<%=isinteraction?\"parameter\":\"attribute\"%>_name( int datamemberHandle ) {\n\t\tIntegerStringMap::iterator ismItr = getDatamemberHandleNameMap().find( datamemberHandle );\n\t\treturn ismItr == getDatamemberHandleNameMap().end() ? std::string() : ismItr->second;\n\t}\n\t\n\tstatic int get_<%=isinteraction?\"parameter\":\"attribute\"%>_handle( const std::string &className, const std::string &datamemberName ) {\n\t\n\t\tStringIntegerMap::iterator simItr = getDatamemberNameHandleMap().find( className + \",\" + datamemberName );\n\t\tif ( simItr == getDatamemberNameHandleMap().end() ) {\n\t\t\tstd::cerr << \"Bad <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" << datamemberName << \"\\\" for class \\\"\" << className << \"\\\" on get_<%=isinteraction?\"parameter\":\"attribute\"%>_handle.\" << std::endl;\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\treturn simItr->second;\n\t}\n\t\n\tstatic void publish( const std::string &className, RTI::RTIambassador *rti ) {\n\t\tClassNamePubSubMap::iterator cpmItr = getClassNamePublishMap().find( className );\n\t\tif ( cpmItr == getClassNamePublishMap().end() ) {\n\t\t\tstd::cerr << \"Bad class name \\\"\" << className << \"\\\" on publish.\" << std::endl;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t(*cpmItr->second)( rti );\n\t}\n\t\n\tstatic void unpublish( const std::string &className, RTI::RTIambassador *rti ) {\n\t\tClassNamePubSubMap::iterator cpmItr = getClassNameUnpublishMap().find( className );\n\t\tif ( cpmItr == getClassNameUnpublishMap().end() ) {\n\t\t\tstd::cerr << \"Bad class name \\\"\" << className << \"\\\" on unpublish.\" << std::endl;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t(*cpmItr->second)( rti );\n\t}\n\t\n\tstatic void subscribe( const std::string &className, RTI::RTIambassador *rti ) {\n\t\tClassNamePubSubMap::iterator cpmItr = getClassNameSubscribeMap().find( className );\n\t\tif ( cpmItr == getClassNameSubscribeMap().end() ) {\n\t\t\tstd::cerr << \"Bad class name \\\"\" << className << \"\\\" on subscribe.\" << std::endl;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t(*cpmItr->second)( rti );\n\t}\n\t\n\tstatic void unsubscribe( const std::string &className, RTI::RTIambassador *rti ) {\n\t\tClassNamePubSubMap::iterator cpmItr = getClassNameUnsubscribeMap().find( className );\n\t\tif ( cpmItr == getClassNameSubscribeMap().end() ) {\n\t\t\tstd::cerr << \"Bad class name \\\"\" << className << \"\\\" on unsubscribe.\" << std::endl;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t(*cpmItr->second)( rti );\n\t}\n\n<% if(!isinteraction){ %>\n\tstatic void publish( const std::string &className, const std::string &attributeName );\n\t\n\tstatic void unpublish( const std::string &className, const std::string &attributeName ) {\n\t\tNameStringVectorPtrMap::iterator camItr = getClassNamePublishAttributeNameVectorPtrMap().find( className );\n\t\tif ( camItr == getClassNamePublishAttributeNameVectorPtrMap().end() ) {\n\t\t\tstd::cerr << \"ERROR:  ObjectRoot.unpublish:  could not unpublish class \\\"\" << className << \"\\\" \\\"\" << attributeName << \"\\\" attribute.\" << std::endl;\n\t\t\treturn;\n\t\t}\n\t\tcamItr->second->erase( std::remove( camItr->second->begin(), camItr->second->end(), attributeName ), camItr->second->end() );\n\t}\n\tstatic void subscribe( const std::string &className, const std::string &attributeName );\n\t\n\tstatic void unsubscribe( const std::string &className, const std::string &attributeName ) {\n\t\tNameStringVectorPtrMap::iterator camItr = getClassNameSubscribeAttributeNameVectorPtrMap().find( className );\n\t\tif ( camItr == getClassNameSubscribeAttributeNameVectorPtrMap().end() ) {\n\t\t\tstd::cerr << \"ERROR:  ObjectRoot.unsubscribe:  could not unsubscribe class \\\"\" << className << \"\\\" \\\"\" << attributeName << \"\\\" attribute.\" << std::endl;\n\t\t\treturn;\n\t\t}\n\t\tcamItr->second->erase( std::remove( camItr->second->begin(), camItr->second->end(), attributeName ), camItr->second->end() );\n\t}\n<%}%>\n\t\npublic:\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( const std::string &className ) {\n\t\tClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( className );\n\t\treturn cfmItr == getClassNameFactoryMap().end() ? SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 ) : (*cfmItr->second)();\n\t}\n\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( const std::string &className, const RTIfedTime &dlc13FedTime ) {\n\t\tClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( className );\n\t\tif ( cfmItr == getClassNameFactoryMap().end() ) {\n\t\t\treturn SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 );\n\t\t}\n\t\t\n\t\tSP sp = (*cfmItr->second)();\n\t\tsp->setTime( dlc13FedTime.getTime() );\n\t\treturn sp;\n\t}\n\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle ) {\n\t\tIntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\n\t\treturn ismItr == getClassHandleNameMap().end() ? SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 ) : create_<%=isinteraction?\"interaction\":\"object\"%>( ismItr->second );\n\t}\n\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, const RTIfedTime &dlc13FedTime ) {\n\t\tIntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\n\t\treturn ismItr == getClassHandleNameMap().end() ? SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 ) : create_<%=isinteraction?\"interaction\":\"object\"%>( ismItr->second, dlc13FedTime );\n\t}\n\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap );\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime );\n\n\tstatic StringVector get_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\n\t\treturn StringVector();\n\t}\n\n\tstatic StringVector get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\n\t\treturn StringVector();\n\t}\n\n<% if(!isinteraction){ %>\n    static SP discover( int class_handle, int object_handle ) {\n    \n    \tSP sp = create_object( class_handle );\n    \tif ( sp != 0 ) {\n    \t\tgetObjectMap().insert(  std::make_pair( object_handle, sp )  );\n    \t}\n    \treturn sp;\n    }\n    \n    static SP reflect( int object_handle, const RTI::AttributeHandleValuePairSet &datamemberMap ) {\n    \tObjectMap::iterator obmItr = getObjectMap().find( object_handle );\n    \tif ( obmItr == getObjectMap().end() ) {\n    \t\treturn SP( (ObjectRoot *)0 );\n    \t}\n    \t\n    \tSP sp = obmItr->second;\n    \tsp->setTime( -1 );\n\t\tsp->setAttributes( datamemberMap );\n    \treturn sp;\n    }\n\n    static SP reflect(\n     int object_handle,\n     const RTI::AttributeHandleValuePairSet &datamemberMap,\n     double theTime\n    ) {\n    \tObjectMap::iterator obmItr = getObjectMap().find( object_handle );\n    \tif ( obmItr == getObjectMap().end() ) {\n    \t\treturn SP( (ObjectRoot *)0 );\n    \t}\n    \t\n    \tSP sp = obmItr->second;\n    \tsp->setTime( theTime );\n\t\tsp->setAttributes( datamemberMap );\n    \treturn sp;\n    }\n\n\tvoid requestUpdate( RTI::RTIambassador *rti );\n\n\tstatic SP getObject( int object_handle ) {\n\t\tObjectMap::iterator obmItr = getObjectMap().find( object_handle );\n\t\treturn obmItr == getObjectMap().end() ? SP( (ObjectRoot *)0 ) : obmItr->second;\n\t}\n\t\t    \n    static SP removeObject( int object_handle ) {\n\t\tObjectMap::iterator obmItr = getObjectMap().find( object_handle );\n\t\tif ( obmItr == getObjectMap().end() ) {\n\t\t\treturn SP( (ObjectRoot *)0 );\n\t\t}\n\t\t\n\t\tSP sp = obmItr->second;\n        getObjectMap().erase( obmItr );\n        return sp;\n    }\n    \n\nprivate:\n    int _object_handle;\n\n    void setObjectHandle( int object_handle ) {\n        getObjectMap().erase( object_handle );\n        _object_handle = object_handle;\n        getObjectMap().insert(  std::make_pair( object_handle, this )  );\n    }\n\npublic:\n    int getObjectHandle( void ) const { return _object_handle; }\n\t\n<%}%>\n\nprivate:\n\tdouble _time;\n\tstatic C2WLogger* _logger;\n\npublic:\t\n\tdouble getTime( void ) { return _time; }\n\t\n\tvoid setTime( double time ) { _time = time; }\n\tvoid setTime( const RTIfedTime &dlc13FedTime ) {\n\t\tsetTime( dlc13FedTime.getTime() );\n\t}\n\n\t<%=isinteraction?\"Interaction\":\"Object\"%>Root( void ) : _time( -1 )<% if(!isinteraction){%>, _isRegistered( false )<%}%> { }\n\t\n\t<%=isinteraction?\"Interaction\":\"Object\"%>Root( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) : _time( -1 )<% if(!isinteraction){%>, _isRegistered( false )<%}%> {\n\t\tset<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\n\t}\n\n\n\t<%=isinteraction?\"Interaction\":\"Object\"%>Root( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime ) : _time( dlc13FedTime.getTime() )<% if(!isinteraction){%>, _isRegistered( false )<%}%> {\n\t\tset<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\n\t}\n\n\tstatic SP create( void ) { return SP( new <%=isinteraction?\"Interaction\":\"Object\"%>Root ); }\n\tstatic SP create( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) { return SP(  new <%=isinteraction?\"Interaction\":\"Object\"%>Root( datamemberMap )  ); }\n\tstatic SP create( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime ) {\n\t\treturn SP(  new <%=isinteraction?\"Interaction\":\"Object\"%>Root( datamemberMap, dlc13FedTime )  );\n\t}\n\t\n\n\tvirtual TypeMedley get<%=isinteraction?\"Parameter\":\"Attribute\"%>( const std::string &datamemberName ) const {\n\t\tthrow std::invalid_argument( getClassName() + \" class has no <%=isinteraction?\"parameter\":\"attribute\"%> named \\\"\" + datamemberName + \"\\\"\" );\n\t}\n\t\t\n\tvirtual TypeMedley get<%=isinteraction?\"Parameter\":\"Attribute\"%>( int datamemberHandle ) const {\n\t\tthrow std::invalid_argument(\n\t\t getClassName() + \" class has no <%=isinteraction?\"parameter\":\"attribute\"%> with handle (\" + boost::lexical_cast< std::string >( datamemberHandle ) + \")\"\n\t\t);\n\t}\n\t\t\n\tvoid set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap );\n\nprivate:\n\tvoid set<%=isinteraction?\"Parameter\":\"Attribute\"%>( RTI::Handle handle, const std::string &val ) {\n\t\tif (  !set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( handle, val )  ) {\n\t\t\tstd::cerr << \"set:  bad <%=isinteraction?\"parameter\":\"attribute\"%> handle in class \\\"\" + getClassName() + \"\\\"\" << std::endl;\n\t\t}\n\t}\n\npublic:\n\tvoid set<%=isinteraction?\"Parameter\":\"Attribute\"%>( const std::string &datamemberName, TypeMedley value ) {\n\t\tif (  !set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, value )  ) {\n\t\t\tstd::cerr << \"Error:  class \\\"\" << getClassName() << \"\\\":  invalid <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" + datamemberName + \"\\\"\" << std::endl;\n\t\t}\n\t}\n\nprotected:\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( int param_handle, const std::string &val ) {\n\t\treturn false;\n\t}\n\t\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( const std::string &datamemberName, const std::string &value ) {\n\t\treturn false;\n\t}\n\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( const std::string &datamemberName, TypeMedley value ) {\n\t\treturn false;\n\t}\n\n\tvirtual <%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP createDatamemberHandleValuePairSet( RTI::ULong count<% if(!isinteraction){%>, bool force<%}%> ) {\n\t\treturn <%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP(  RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>SetFactory::create( count )  );\n\t}\n\t\n\tvirtual <%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP createDatamemberHandleValuePairSet( <% if(!isinteraction){%>bool force<%}%> ) {\n\t\treturn createDatamemberHandleValuePairSet( <% if(!isinteraction){%>force<%}%> );\n\t}\n\t\n<% if(isinteraction){ %>\npublic:\n\tvoid sendInteraction( RTI::RTIambassador *rti, double time );\n\tvoid sendInteraction( RTI::RTIambassador *rti );\n\nprivate:\n\tstatic std::string fedName;\n\t\npublic:\n\tstatic bool enablePubLog;\n\tstatic bool enableSubLog;\n\tstatic std::string pubLogLevel;\n\tstatic std::string subLogLevel;\t\n\npublic:\n\tstatic void enablePublishLog(const std::string &interaction, const std::string &fed, const std::string &thislevel, const std::string &globallevel);\n\tstatic void enableSubscribeLog(const std::string &interaction, const std::string &fed, const std::string &thislevel, const std::string &globallevel);\n\n\tvoid createLog( double time, bool isPub = true );\n\t\n<% }else{ %>\nprivate:\n    bool _isRegistered;\n\npublic:\n    void registerObject( RTI::RTIambassador *rti );\n\tvoid unregisterObject( RTI::RTIambassador *rti );\n\n    void updateAttributeValues( RTI::RTIambassador *rti, double time, bool force );\n\n    void updateAttributeValues( RTI::RTIambassador *rti, double time ) {\n    \tupdateAttributeValues( rti, time, false );\n    }\n\n    void updateAttributeValues( RTI::RTIambassador *rti, bool force );\n\n\tvoid updateAttributeValues( RTI::RTIambassador *rti ) {\n\t\tupdateAttributeValues( rti, false );\n\t}\n\nprivate:\n\tstatic std::string fedName;\n\t\npublic:\n\tstatic void enablePublishLog(const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel);\n\tstatic void enableSubscribeLog(const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel);\n\n\tstatic std::map<std::string, std::string> &getPubAttributeLogMap( void) {\n\t\tstatic std::map<std::string, std::string> pubAttributeLogMap;\n\t\treturn pubAttributeLogMap;\n\t}\n\n\tstatic std::map<std::string, std::string> &getSubAttributeLogMap( void) {\n\t\tstatic std::map<std::string, std::string> subAttributeLogMap;\n\t\treturn subAttributeLogMap;\n\t}\n\n\tvoid createLog( double time, bool isPub = true );\n\t\n<%}%>\n\n};\n\ntypedef <%=isinteraction?\"Interaction\":\"Object\"%>Root::SP <%=isinteraction?\"Interaction\":\"Object\"%>RootSP;\n\nstatic bool call_<%=isinteraction?\"Interaction\":\"Object\"%>Root_static_init = <%=isinteraction?\"Interaction\":\"Object\"%>Root::static_init();\n\nstd::ostream &operator<<( std::ostream &os, <%=isinteraction?\"Interaction\":\"Object\"%>Root::SP entitySP );\nstd::ostream &operator<<( std::ostream &os, const <%=isinteraction?\"Interaction\":\"Object\"%>Root &entity );\n#endif\n",
    "classroot.java.ejs": "<%/* THIS IS THE ROOT CLASS OF EITHER THE INTERACTION OR OBJECT-CLASS HEIRARCHY (I.E. \"InteractionRoot\" OR \"ObjectRoot\") */%>\n<%/*classroot(isinteraction)*/%>\n// This code has been generated by the C2W code generator.\n// Do not edit manually!\n\n/*\n * Copyright (c) 2016, Institute for Software Integrated Systems, Vanderbilt University\n * All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose, without fee, and without written agreement is\n * hereby granted, provided that the above copyright notice, the following\n * two paragraphs and the author appear in all copies of this software.\n *\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * @author Himanshu Neema\n * @author Harmon Nine\n */\n\npackage c2w.hla;\n\nimport hla.rti.*;\nimport hla.rti.jlc.RtiFactory;\nimport hla.rti.jlc.RtiFactoryFactory;\n\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n<% if(isinteraction){%>import java.util.concurrent.LinkedBlockingQueue;<%}%>\n\nimport org.portico.impl.hla13.types.DoubleTime;\n\n/**\n * <%=isinteraction?\"Interaction\":\"Object\"%>Root is the base class for all <%=isinteraction?\"interaction\":\"object\"%>s\n * defined in a given federation.  As such, an <%=isinteraction?\"Interaction\":\"Object\"%>Root\n * variable may refer to any type of interaction defined in the\n * federation.\n * <p/>\n * This <%=isinteraction?\"Interaction\":\"Object\"%>Root class provides the following:\n * - methods for constructing any <%=isinteraction?\"interaction\":\"object\"%> in the federation, either from\n * data provided by the RTI (for example, see\n * {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle )} or from a string argument\n * specifying the name of <%=isinteraction?\"interaction\":\"object\"%> to construct (see\n * {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( String className )}.\n * - methods for sending <% if(isinteraction){ %>an interaction<%}else{%>object updates<%}%> to the RTI (see\n * {@link <% if(isinteraction){ %>#sendInteraction( RTIambassador rti )<%}else{%>#updateAttributeValues( RTIambassador rti )<%}%>} for an example).\n * - methods for publishing/subscribing to any <% if(isinteraction){ %>interaction<%}else{%>object/object attribute<%}%> \n * defined in the federation (see\n * {@link #publish( String className, RTIambassador rti )} for example).\n * - methods for getting/setting any <%=isinteraction?\"parameter\":\"attribute\"%> in the <%=isinteraction?\"interaction\":\"object\"%> to\n * which a given <%=isinteraction?\"Interaction\":\"Object\"%>Root variable is referring\n * (see {@link #get<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName )} and\n * {@link #set<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName, Object value )}\n */\npublic class <%=isinteraction?\"Interaction\":\"Object\"%>Root implements <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface {\n\n\tprivate static int logId = 0;\n\tprivate static int _globalUniqueID = 0;\n\t\n\tprivate static int generateUniqueID() {\n\t\treturn _globalUniqueID++;\n\t}\n\t\n\tprivate int _uniqueID;\n\t\n\tpublic int getUniqueID() { return _uniqueID; }\n\t\n\tprotected static RtiFactory _factory;\n\tstatic {\n\t\tboolean factoryNotAcquired = true;\n\t\twhile( factoryNotAcquired ) {\n\t\t\ttry {\n\t\t\t\t_factory = RtiFactoryFactory.getRtiFactory( \"org.portico.dlc.HLA13RTIFactory\" );\n\t\t\t\tfactoryNotAcquired = false;\n\t\t\t} catch ( Exception e ) {\n\t\t\t\tSystem.err.println( \"ERROR: acquiring factory\" );\n\t\t\t\te.printStackTrace();\n\t\t\t\ttry { Thread.sleep( 100 ); } catch ( Exception e1 ) { }\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected static Set< String > _classNameSet = new HashSet< String >();\n\tprotected static Map< String, Class<?> > _classNameClassMap = new HashMap< String, Class<?> >();\n\tprotected static Map<  String, Set< String >  > _datamemberClassNameSetMap = new HashMap<  String, Set< String >  >();\n\tprotected static Map<  String, Set< String >  > _allDatamemberClassNameSetMap = new HashMap<  String, Set< String >  >();\n\n\tprotected static Map< String, Integer > _classNameHandleMap = new HashMap< String, Integer >();\n\tprotected static Map< Integer, String > _classHandleNameMap = new HashMap< Integer, String >();\n\tprotected static Map< Integer, String > _classHandleSimpleNameMap = new HashMap< Integer, String >();\n\t\n\tprotected static Map< String, Integer > _datamemberNameHandleMap = new HashMap< String, Integer >();\n\tprotected static Map< Integer, String > _datamemberHandleNameMap = new HashMap< Integer, String >();\n\tprotected static Map< String, String > _datamemberTypeMap = new HashMap< String, String >();\n\n<% if(isinteraction){ %><%}else{%>\n\tprotected static Map<  String, Set< String >  > _classNamePublishAttributeNameMap = new HashMap<  String, Set< String >  >();\n\tprotected static Map<  String, Set< String >  > _classNameSubscribeAttributeNameMap = new HashMap<  String, Set< String >  >();\n\n\tprotected static Map< String, AttributeHandleSet > _classNamePublishedAttributeMap = new HashMap< String, AttributeHandleSet >();\n\tprotected static Map< String, AttributeHandleSet > _classNameSubscribedAttributeMap = new HashMap< String, AttributeHandleSet >();\n\t\n    private static Map< Integer, ObjectRoot > _objectMap = new HashMap< Integer, ObjectRoot >();\n\n\tprotected static class Attribute<T> {                                                                                 // NOMELD\n\t\tprivate T _value = null;                                                                                           // NOMELD\n\t\tprivate T _oldValue = null;                                                                                        // NOMELD\n\t\tprivate boolean _oldValueInit = false;                                                                             // NOMELD\n\t\tprivate double _time = 0;                                                                                          // NOMELD\n                                                                                                                           // NOMELD\n\t\tpublic Attribute( T init ) {                                                                                       // NOMELD\n\t\t\t_value = init;                                                                                                 // NOMELD\n\t\t}                                                                                                                  // NOMELD\n\t\t                                                                                                                   // NOMELD\n\t\tpublic T getValue() { return _value; }                                                                             // NOMELD\n\t\tpublic void setValue( T value ) {                                                                                  // NOMELD\n\t\t\tif ( value == null ) return;                                                                                   // NOMELD\n\t\t\t_value = value;                                                                                                // NOMELD\n\t\t}                                                                                                                  // NOMELD\n\t\t                                                                                                                   // NOMELD\n\t\tpublic double getTime() { return _time; }                                                                          // NOMELD\n\t\tpublic void setTime( double time ) { _time = time; }                                                               // NOMELD\n\t\t                                                                                                                   // NOMELD\n\t\tpublic void setHasBeenUpdated() {                                                                                  // NOMELD\n\t\t\t_oldValue = _value;                                                                                            // NOMELD\n\t\t\t_oldValueInit = true;                                                                                          // NOMELD\n\t\t}                                                                                                                  // NOMELD\n\t\t                                                                                                                   // NOMELD\n\t\tpublic boolean shouldBeUpdated( boolean force ) { return force || !_oldValueInit || !_oldValue.equals( _value ); } // NOMELD\t\t\n\t}                                                                                                                      // NOMELD\n<%}%>\t\n\t\n\t<% /*classcommon(classname=%=isinteraction?\"Interaction\":\"Object\"%+\"Root\",hlaclassname=%=isinteraction?\"Interaction\":\"Object\"%+\"Root\",...)*/ %>\n\t<%- ejs.render(TEMPLATES[\"classcommon.java.ejs\"],\n\t\t{\n\t\t\tisinteraction: isinteraction,\n\t\t\tclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\n\t\t\tparentclassname: \"\",\n\t\t\thlaclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\n\t\t\tdatamembers: [],\n\t\t\talldatamembers: []\n\t}) %>\n\t/**\n\t* Returns a set of strings containing the names of all of the <%=isinteraction?\"interaction\":\"object\"%>\n\t* classes in the current federation.\n\t*\n\t* @return Set< String > containing the names of all <%=isinteraction?\"interaction\":\"object\"%> classes\n\t* in the current federation\n\t*/\n\tpublic static Set< String > get_<%=isinteraction?\"interaction\":\"object\"%>_names() { return new HashSet< String >( _classNameSet ); }\n\n\t/**\n\t* Returns a set of strings containing the names of all of the non-hidden <%=isinteraction?\"parameter\":\"attribute\"%>s\n\t* in the <%=isinteraction?\"interaction\":\"object\"%> class specified by className.\n\t*\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class for which to retrieve the\n\t* names of all of its <%=isinteraction?\"parameter\":\"attribute\"%>s\n\t* @return Set< String > containing the names of all <%=isinteraction?\"parameter\":\"attribute\"%>s in the\n\t* className <%=isinteraction?\"interaction\":\"object\"%> class\n\t*/\n\tpublic static Set< String > get_<%=isinteraction?\"parameter\":\"attribute\"%>_names( String className ) {\n\t\treturn new HashSet< String >(  _datamemberClassNameSetMap.get( className )  );\n\t}\n\t\n\t/**\n\t* Returns a set of strings containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s\n\t* in the <%=isinteraction?\"interaction\":\"object\"%> class specified by className.\n\t*\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class for which to retrieve the\n\t* names of all of its <%=isinteraction?\"parameter\":\"attribute\"%>s\n\t* @return Set< String > containing the names of all <%=isinteraction?\"parameter\":\"attribute\"%>s in the\n\t* className <%=isinteraction?\"interaction\":\"object\"%> class\n\t*/\n\tpublic static Set< String > get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names( String className ) {\n\t\treturn new HashSet< String >(  _allDatamemberClassNameSetMap.get( className )  );\n\t}\n\t\n\t/**\n\t* Returns the fully-qualified name of the <%=isinteraction?\"interaction\":\"object\"%> class corresponding\n\t* to the RTI-defined classHandle.\n\t*\n\t* @param classHandle handle (defined by RTI) of <%=isinteraction?\"interaction\":\"object\"%> class for\n\t* which to retrieve the fully-qualified name\n\t* @return the fully-qualified name of the <%=isinteraction?\"interaction\":\"object\"%> class that\n\t* corresponds to the RTI-defined classHandle\n\t*/\n\tpublic static String get_class_name( int classHandle ) {\n\t\treturn _classHandleNameMap.get( classHandle );\n\t}\n\n\t/**\n\t* Returns the simple name of the <%=isinteraction?\"interaction\":\"object\"%> class corresponding to the\n\t* RTI-defined classHandle.  The simple name of an <%=isinteraction?\"interaction\":\"object\"%> class is\n\t* the last name in its (dot-delimited) fully-qualified name.\n\t*\n\t* @param classHandle handle (defined by RTI) of <%=isinteraction?\"interaction\":\"object\"%> class for which\n\t* to retrieve the simple name\n\t* @return the simple name of the <%=isinteraction?\"interaction\":\"object\"%> class that corresponds to\n\t* the RTI-defined classHandle\n\t*/\n\tpublic static String get_simple_class_name( int classHandle ) {\n\t\treturn _classHandleSimpleNameMap.get( classHandle );\n\t}\n\t\n\t/**\n\t* Returns the integer handle (RTI defined) of the <%=isinteraction?\"interaction\":\"object\"%> class\n\t* corresponding to the fully-qualified <%=isinteraction?\"interaction\":\"object\"%> class name in className.\n\t*\n\t* @param className fully-qualified name of <%=isinteraction?\"interaction\":\"object\"%> class for which to\n\t* retrieve the RTI-defined integer handle\n\t* @return the RTI-defined handle of the <%=isinteraction?\"interaction\":\"object\"%> class\n\t*/\n\tpublic static int get_handle( String className ) {\n\t\n\t\tInteger classHandle = _classNameHandleMap.get( className );\n\t\tif ( classHandle == null ) {\n\t\t\tSystem.err.println( \"Bad class name \\\"\" + className + \"\\\" on get_handle.\" );\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\treturn classHandle;\t\t\n\t}\n\t\n\t/**\n\t* Returns the name of <% if(isinteraction){ %>a parameter<%}else{%>an attribute<%}%> corresponding to\n\t* its handle (RTI assigned) in datamemberHandle.\n\t*\n\t* @param datamemberHandle handle of <% if(isinteraction){ %>parameter<%}else{%>attribute<%}%> (RTI assigned)\n\t* for which to return the name\n\t* @return the name of the <% if(isinteraction){ %>parameter<%}else{%>attribute<%}%> corresponding to datamemberHandle\n\t*/\n\tpublic static String get_<%=isinteraction?\"parameter\":\"attribute\"%>_name( int datamemberHandle ) {\n\t\treturn _datamemberHandleNameMap.get( datamemberHandle );\n\t}\n\t\n\t/**\n\t* Returns the handle of <% if(isinteraction){ %>a parameter<%}else{%>an attribute<%}%> (RTI assigned) given\n\t* its <%=isinteraction?\"interaction\":\"object\"%> class name and <%=isinteraction?\"parameter\":\"attribute\"%> name\n\t*\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class\n\t* @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%>\n\t* @return the handle (RTI assigned) of the <%=isinteraction?\"parameter\":\"attribute\"%> \"datamemberName\" of <%=isinteraction?\"interaction\":\"object\"%> class \"className\"\n\t*/\n\tpublic static int get_<%=isinteraction?\"parameter\":\"attribute\"%>_handle( String className, String datamemberName ) {\n\t\n\t\tInteger datamemberHandle = _datamemberNameHandleMap.get( className + \",\" + datamemberName );\n\t\tif ( datamemberHandle == null ) {\n\t\t\tSystem.err.println( \"Bad <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" + datamemberName + \"\\\" for class \\\"\" + className + \"\\\" on get_<%=isinteraction?\"parameter\":\"attribute\"%>_handle.\" );\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t\treturn datamemberHandle;\t\t\n\t}\n\t\n\tprivate static Class<?>[] pubsubArguments = new Class<?>[] { RTIambassador.class };\n\t\n\t\n\t/**\n\t* Publishes the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" for a federate.\n\t* This can also be performed by calling the publish( RTIambassador rti )\n\t* method directly on the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" (for\n\t* example, to publish the <%=isinteraction?\"Interaction\":\"Object\"%>Root class in particular,\n\t* see {@link <%=isinteraction?\"Interaction\":\"Object\"%>Root#publish( RTIambassador rti )}).\n\t*\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class to be published for the federate\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic static void publish( String className, RTIambassador rti ) {\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\n\t\tif ( rtiClass == null ) {\n\t\t\tSystem.err.println( \"Bad class name \\\"\" + className + \"\\\" on publish.\" );\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tMethod method = rtiClass.getMethod( \"publish\", pubsubArguments );\n\t\t\tmethod.invoke( null, new Object[]{ rti } );\n\t\t} catch ( Exception e ) {\n\t\t\tSystem.err.println( \"Exception caught on publish!\" );\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\t/**\n\t* Unpublishes the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" for a federate.\n\t* This can also be performed by calling the unpublish( RTIambassador rti )\n\t* method directly on the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" (for\n\t* example, to unpublish the <%=isinteraction?\"Interaction\":\"Object\"%>Root class in particular,\n\t* see {@link <%=isinteraction?\"Interaction\":\"Object\"%>Root#unpublish( RTIambassador rti )}).\n\t*\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class to be unpublished for the federate\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic static void unpublish( String className, RTIambassador rti ) {\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\n\t\tif ( rtiClass == null ) {\n\t\t\tSystem.err.println( \"Bad class name \\\"\" + className + \"\\\" on unpublish.\" );\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tMethod method = rtiClass.getMethod( \"unpublish\", pubsubArguments );\n\t\t\tmethod.invoke( null, new Object[]{ rti } );\n\t\t} catch ( Exception e ) {\n\t\t\tSystem.err.println( \"Exception caught on unpublish!\" );\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\t/**\n\t* Subscribes federate to the <%=isinteraction?\"interaction\":\"object\"%> class names by \"className\"\n\t* This can also be performed by calling the subscribe( RTIambassador rti )\n\t* method directly on the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" (for\n\t* example, to subscribe a federate to the <%=isinteraction?\"Interaction\":\"Object\"%>Root class\n\t* in particular, see {@link <%=isinteraction?\"Interaction\":\"Object\"%>Root#subscribe( RTIambassador rti )}).\n\t*\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class to which to subscribe the federate\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic static void subscribe( String className, RTIambassador rti ) {\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\n\t\tif ( rtiClass == null ) {\n\t\t\tSystem.err.println( \"Bad class name \\\"\" + className + \"\\\" on subscribe.\" );\n\t\t\treturn;\n\t\t}\n\t\ttry {\n\t\t\tMethod method = rtiClass.getMethod( \"subscribe\", pubsubArguments );\n\t\t\tmethod.invoke( null, new Object[]{ rti } );\n\t\t} catch ( Exception e ) {\n\t\t\tSystem.err.println( \"Exception caught on subscribe!\" );\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\t/**\n\t* Unsubscribes federate from the <%=isinteraction?\"interaction\":\"object\"%> class names by \"className\"\n\t* This can also be performed by calling the unsubscribe( RTIambassador rti )\n\t* method directly on the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" (for\n\t* example, to unsubscribe a federate to the <%=isinteraction?\"Interaction\":\"Object\"%>Root class\n\t* in particular, see {@link <%=isinteraction?\"Interaction\":\"Object\"%>Root#unsubscribe( RTIambassador rti )}).\n\t*\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class to which to unsubscribe the federate\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic static void unsubscribe( String className, RTIambassador rti ) {\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\n\t\ttry {\n\t\t\tMethod method = rtiClass.getMethod( \"unsubscribe\", pubsubArguments );\n\t\t\tmethod.invoke( null, new Object[]{ rti } );\n\t\t} catch ( Exception e ) {\n\t\t\tSystem.err.println( \"Exception caught on unsubscribe!\" );\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n<% if(isinteraction){ %><%}else{%>\n\t/**\n\t* Publishes the attribute named by \"attributeName\" of the object class named\n\t* by \"className\" for a federate.  This can also be performed by calling the\n\t* publish_<attributeName>() method directly on the object class named by\n\t* \"className\".\n\t*\n\t* Note:  This method only marks the attribute named by \"attributeName\" for\n\t* publication.  The attribute doesn't actually get published until the\n\t* \"className\" object class, of which it is a member, is (re)published.  See\n\t* {@link ObjectRoot#publish( String className, RTIambassador RTI )} and\n\t* {@link ObjectRoot#publish( RTIambassador RTI )} for examples of how to\n\t* publish the object class.\n\t* \n\t* @param className name of object class for which the attribute named by\n\t* \"attributeName\" is to be published\n\t* @param attributeName name of the attribute to be published\n\t*/\n\tpublic static void publish( String className, String attributeName ) {\n\t\ttry {\n\t\t\t_classNamePublishAttributeNameMap.get( className ).add( attributeName );\n\t\t} catch ( Exception e ) {\n\t\t\tSystem.err.println( \"ERROR:  ObjectRoot.publish:  could not publish class \\\"\" + className + \"\\\" \\\"\" + attributeName + \"\\\" attribute.\" );\n\t\t\te.printStackTrace();\n\t\t}\t\t\n\t}\n\n\t/**\n\t* Unpublishes the attribute named by \"attributeName\" of the object class named\n\t* by \"className\" for a federate.  This can also be performed by calling the\n\t* unpublish_<attributeName>() method directly on the object class named by\n\t* \"className\".\n\t*\n\t* Note:  This method only marks the attribute named by \"attributeName\" for\n\t* un-publication. The attribute doesn't actually get unpublished until the\n\t* \"className\" object class, of which it is a member, is (re)published.  See\n\t* {@link ObjectRoot#publish( String className, RTIambassador RTI )} and\n\t* {@link ObjectRoot#publish( RTIambassador RTI )} for examples of how to\n\t* publish the object class.\n\t* \n\t* @param className name of object class for which the attribute named by\n\t* \"attributeName\" is to be unpublished (by a federate)\n\t* @param attributeName name of the attribute to be unpublished\n\t*/\n\tpublic static void unpublish( String className, String attributeName ) {\n\t\ttry {\n\t\t\t_classNamePublishAttributeNameMap.get( className ).remove( attributeName );\n\t\t} catch ( Exception e ) {\n\t\t\tSystem.err.println( \"ERROR:  ObjectRoot.unpublish:  could not unpublish class \\\"\" + className + \"\\\" \\\"\" + attributeName + \"\\\" attribute.\" );\n\t\t\te.printStackTrace();\n\t\t}\t\t\n\t}\n\n\t/**\n\t* Subscribe a federate to the attribute named by \"attributeName\" of the\n\t* object class named by \"className\".  This can also be performed by calling\n\t* the subscribe_<attributeName>() method directly on the object class named\n\t* by \"className\".\n\t*\n\t* Note:  This method only marks the attribute named by \"attributeName\" for\n\t* subscription.  The attribute doesn't actually get subscribed to until the\n\t* \"className\" object class, of which it is a member, is (re)subscribed to.\n\t* See {@link ObjectRoot#subscribe( String className, RTIambassador RTI )} and\n\t* {@link ObjectRoot#subscribe( RTIambassador RTI )} for examples of how to\n\t* subscribe to the object class.\n\t* \n\t* @param className name of object class for which the attribute named by\n\t* \"attributeName\" is to be subcribed\n\t* @param attributeName name of the attribute to be published\n\t*/\n\tpublic static void subscribe( String className, String attributeName ) {\n\t\ttry {\n\t\t\t_classNameSubscribeAttributeNameMap.get( className ).add( attributeName );\n\t\t} catch ( Exception e ) {\n\t\t\tSystem.err.println( \"ERROR:  ObjectRoot.subscribe:  could not subscribe to class \\\"\" + className + \"\\\" \\\"\" + attributeName + \"\\\" attribute.\" );\n\t\t\te.printStackTrace();\n\t\t}\t\t\n\t}\n\n\t/**\n\t* Unsubscribe a federate from the attribute named by \"attributeName\" of the\n\t* object class named by \"className\".  This can also be performed by calling\n\t* the unsubscribe_<attributeName>() method directly on the object class named\n\t* by \"className\".\n\t*\n\t* Note:  This method only marks the attribute named by \"attributeName\" for\n\t* unsubscription.  The attribute doesn't actually get unsubscribed from until the\n\t* \"className\" object class, of which it is a member, is (re)subscribed to.\n\t* See {@link ObjectRoot#subscribe( String className, RTIambassador RTI )} and\n\t* {@link ObjectRoot#subscribe( RTIambassador RTI )} for examples of how to\n\t* subscribe to the object class.\n\t* \n\t* @param className name of object class for which the attribute named by\n\t* \"attributeName\" is to be subcribed\n\t* @param attributeName name of the attribute to be published\n\t*/\n\tpublic static void unsubscribe( String className, String attributeName ) {\n\t\ttry {\n\t\t\t_classNameSubscribeAttributeNameMap.get( className ).remove( attributeName );\n\t\t} catch ( Exception e ) {\n\t\t\tSystem.err.println( \"ERROR:  ObjectRoot.unsubscribe:  could not unsubscribe class \\\"\" + className + \"\\\" \\\"\" + attributeName + \"\\\" attribute.\" );\n\t\t\te.printStackTrace();\n\t\t}\t\t\n\t}\n<%}%>\n\t\n\tprivate static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( Class<?> rtiClass ) {\n\t\t<%=isinteraction?\"Interaction\":\"Object\"%>Root classRoot = null;\n\t\ttry {\n\t\t\tclassRoot = (<%=isinteraction?\"Interaction\":\"Object\"%>Root)rtiClass.newInstance();\n\t\t} catch( Exception e ) {\n\t\t\tSystem.err.println( \"ERROR:  <%=isinteraction?\"Interaction\":\"Object\"%>Root:  create_<%=isinteraction?\"interaction\":\"object\"%>:  could not create/cast new <%=isinteraction?\"Interaction\":\"Object\"%>\" );\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\treturn classRoot;\n\t}\n\n\tprivate static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( Class<?> rtiClass, LogicalTime logicalTime ) {\t\n\t\t<%=isinteraction?\"Interaction\":\"Object\"%>Root classRoot = create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass );\n\t\tif ( classRoot != null ) classRoot.setTime( logicalTime );\n\t\treturn classRoot;\n\t}\n\n\tprivate static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( Class<?> rtiClass, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\n\t\t<%=isinteraction?\"Interaction\":\"Object\"%>Root classRoot = create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass );\n\t\tclassRoot.set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\n\t\treturn classRoot;\n\t}\n\t\n\tprivate static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( Class<?> rtiClass, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime ) {\n\t\t<%=isinteraction?\"Interaction\":\"Object\"%>Root classRoot = create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass );\n\t\tclassRoot.set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\n\t\tclassRoot.setTime( logicalTime );\n\t\treturn classRoot;\n\t}\n\t\n\t/**\n\t* Create an <%=isinteraction?\"interaction\":\"object\"%> that is in instance of <%=isinteraction?\"interaction\":\"object\"%> class\n\t* \"className\". An <%=isinteraction?\"Interaction\":\"Object\"%>Root reference is returned,\n\t* so to refer to the instance using a reference to a \"className\" interaction,\n\t* the returned reference must be cast down the <%=isinteraction?\"interaction\":\"object\"%> inheritance\n\t* hierarchy.\n\t* An instance of the \"className\" <%=isinteraction?\"interaction\":\"object\"%> class may also be created\n\t* by using the \"new\" operator directory on the \"className\" <%=isinteraction?\"interaction\":\"object\"%>\n\t* class.  For instance, two ways to create an <%=isinteraction?\"Interaction\":\"Object\"%>Root\n\t* instance are\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>.create_<%=isinteraction?\"interaction\":\"object\"%>( \"<%=isinteraction?\"Interaction\":\"Object\"%>Root\" ),\n\t* and\n\t* new <%=isinteraction?\"Interaction\":\"Object\"%>Root()\n\t*\n\t* @param className fully-qualified (dot-delimited) name of the <%=isinteraction?\"interaction\":\"object\"%>\n\t* class for which to create an instance\n\t* @return instance of \"className\" <%=isinteraction?\"interaction\":\"object\"%> class\n\t*/\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( String className ) {\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\n\t\tif ( rtiClass == null ) return null;\n\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass );\n\t}\n\n\t/**\n\t* Like {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( String className )}, but <%=isinteraction?\"interaction\":\"object\"%>\n\t* is created with a timestamp based on \"logicalTime\".\n\t*\n\t* @param className fully-qualified (dot-delimited) name of the <%=isinteraction?\"interaction\":\"object\"%>\n\t* class for which to create an instance\n\t* @param logicalTime timestamp to place on the new <%=isinteraction?\"interaction\":\"object\"%> class instance\n\t* @return instance of \"className\" <%=isinteraction?\"interaction\":\"object\"%> class with \"logicalTime\" time stamp.\n\t*/\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( String className, LogicalTime logicalTime ) {\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\n\t\tif ( rtiClass == null ) return null;\n\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass, logicalTime );\n\t}\n\n\t/**\n\t* Create an <%=isinteraction?\"interaction\":\"object\"%> that is in instance of <%=isinteraction?\"interaction\":\"object\"%> class\n\t* that corresponds to the \"classHandle\" handle (RTI assigned). An\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>Root reference is returned, so to refer to the\n\t* instance using a reference to a \"className\" interaction, the returned\n\t* reference must be cast down the <%=isinteraction?\"interaction\":\"object\"%> inheritance hierarchy.\n\t*\n\t* @param classHandle handle of <%=isinteraction?\"interaction\":\"object\"%> class (RTI assigned) class for\n\t* which to create an instance\n\t* @return instance of <%=isinteraction?\"interaction\":\"object\"%> class corresponding to \"classHandle\"\n\t*/\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle ) {\n\t\tClass<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );\n\t\tif ( rtiClass == null ) return null;\n\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass );\n\t}\n\n\t/**\n\t* Like {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle )}, but the <%=isinteraction?\"interaction\":\"object\"%>\n\t* is created with a timestamp based on \"logicalTime\".\n\t*\n\t* @param classHandle handle of <%=isinteraction?\"interaction\":\"object\"%> class (RTI assigned) class for\n\t* which to create an instance\n\t* @param logicalTime timestamp to place on the new <%=isinteraction?\"interaction\":\"object\"%> class instance\n\t* @return instance of <%=isinteraction?\"interaction\":\"object\"%> class corresponding to \"classHandle\" with\n\t* \"logicalTime\" time stamp\n\t*/\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, LogicalTime logicalTime ) {\n\t\tClass<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );\n\t\tif ( rtiClass == null ) return null;\n\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass, logicalTime );\n\t}\n\n\t/**\n\t* Like {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle )}, but the <%=isinteraction?\"interaction\":\"object\"%>'s\n\t* <%=isinteraction?\"parameter\":\"attribute\"%>s are initialized using \"datamemberMap\".  The \"datamemberMap\"\n\t* is usually acquired as an argument to an RTI callback method of a federate.\n\t*\n\t* @param classHandle handle of <%=isinteraction?\"interaction\":\"object\"%> class (RTI assigned) class for\n\t* which to create an instance\n\t* @param datamemberMap contains initializing values for the <%=isinteraction?\"parameter\":\"attribute\"%>s\n\t* of the <%=isinteraction?\"interaction\":\"object\"%> class instance\n\t* @return instance of <%=isinteraction?\"interaction\":\"object\"%> class corresponding to \"classHandle\" with\n\t* its <%=isinteraction?\"parameter\":\"attribute\"%>s initialized with the \"datamemberMap\"\n\t*/\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\n\t\tClass<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );\n\t\tif ( rtiClass == null ) return null;\n\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass, datamemberMap );\n\t}\n\n\t/**\n\t* Like {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap )},\n\t* but the <%=isinteraction?\"interaction\":\"object\"%> is given a timestamp based on \"logicalTime\".\n\t*\n\t* @param classHandle handle of <%=isinteraction?\"interaction\":\"object\"%> class (RTI assigned) class for\n\t* which to create an instance\n\t* @param datamemberMap initializing values for the <%=isinteraction?\"parameter\":\"attribute\"%>s of the\n\t* <%=isinteraction?\"interaction\":\"object\"%> class instance\n\t* @param logicalTime timestamp to place on the new <%=isinteraction?\"interaction\":\"object\"%> class instance\n\t* @return instance of <%=isinteraction?\"interaction\":\"object\"%> class corresponding to \"classHandle\" with\n\t* its <%=isinteraction?\"parameter\":\"attribute\"%>s initialized with the \"datamemberMap\" and with\n\t* \"logicalTime\" timestamp\n\t*/\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime ) {\n\t\tClass<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );\n\t\tif ( rtiClass == null ) return null;\n\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass, datamemberMap, logicalTime );\n\t}\n\n<% if(isinteraction){ %><%}else{%>\n\t/**\n\t* Creates a new instance of the object class corresponding to \"class_handle\",\n\t* registers it in an map internal to the ObjectRoot class using \"object_handle\"\n\t* as a key, and returns a reference to the instance.  Though the created\n\t* instance is of the object class corresponding to \"class_handle\" (which is\n\t* a handle assigned by the RTI), it is referred to, via the return value, by\n\t* an ObjectRoot reference.  Thus, to refer to it as an instance of the object\n\t* class corresponding to \"class_handle\", the ObjectRoot reference needs to be\n\t* cast down through the inheritance hierarchy.\n\t* <p/>\n\t* class_handle and object_handle are usually acquired as arguments of the\n\t* \"discoverObjectInstance\" RTI callback method of a federate.\n\t*\n\t* @param class_handle handle of object class (RTI assigned) for which to create\n\t* an instance\n\t* @param object_handle handle (also RTI assigned) of this instance as it is\n\t* known to the RTI.  Any updates to the instance attributes provided by the\n\t* RTI (via a \"reflectAttributeValues\" federate callback) will be identified\n\t* with this object_handle.\n\t* @return new instance of the object class corresponding to class_handle\n\t*/\n    public static ObjectRoot discover( int class_handle, int object_handle ) {\n        Class<?> hlaObjectClass = _classNameClassMap.get(  _classHandleNameMap.get( class_handle )  );\n        ObjectRoot objectRoot = null;\n        try {\n            objectRoot = (ObjectRoot)hlaObjectClass.newInstance();\n            objectRoot.setObjectHandle( object_handle );\n            _objectMap.put( object_handle, objectRoot );\n        } catch( Exception e ) {\n            System.err.println( \"ERROR:  ObjectRoot:  discover:  could not discover object\" );\n            e.printStackTrace();\n        }\n        return objectRoot;\n    }\n    \n    /**\n    * Retrieves the object instance corresponding to \"object_handle\" from an\n    * internal table in the ObjectRoot class, updates its attribute values using\n    * \"reflectedAttributes\", and returns the instance.  Both \"object_handle\" and\n    * \"reflectedAttributes\" are usually acquired as arguments of the\n    * \"reflectAttributeValues\" RTI callback of a federate.\n    * The return value is an ObjectRoot reference to the instance.  So, to refer\n    * to the instance as an instance of its actual class, this reference will\n    * have to be cast down the inheritance hierarchy.\n    *\n    * @param object_handle handle (RTI assigned) of object instance for which the\n    * attributes are to be updated.\n    * @param reflectedAttributes set of updated values for the attributes of the\n    * object instance corresponding to object_handle.\n    * @return the object instance with updated attribute values\n    */\n    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes ) {\n    \tObjectRoot objectRoot = _objectMap.get( object_handle );\n    \tif ( objectRoot == null ) return null;\n    \tobjectRoot.setTime( -1 );\n    \tobjectRoot.setAttributes( reflectedAttributes );\n    \treturn objectRoot;\n    }\n\n\t/**\n\t* Like {@link #reflect( int object_handle, ReflectedAttributes reflectedAttributes )},\n\t* except the updated attributes of the object instance have their timestamps\n\t* updated to \"logicalTime\".\n\t*\n    * @param object_handle handle (RTI assigned) of object instance for which the\n    * attributes are to be updated.\n    * @param reflectedAttributes set of updated values for the attributes of the\n    * object instance corresponding to object_handle.\n    * @param logicalTime new time stamp for attributes that are updated\n    * @return the object instance with updated attribute values\n    */\n    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes, LogicalTime logicalTime ) {\n    \tObjectRoot objectRoot = _objectMap.get( object_handle );\n    \tif ( objectRoot == null ) return null;\n    \tobjectRoot.setTime( logicalTime );\n    \tobjectRoot.setAttributes( reflectedAttributes );\n    \treturn objectRoot;\n    }\n\n\t/**\n\t* Like {@link #reflect( int object_handle, ReflectedAttributes reflectedAttributes )},\n\t* except the updated attributes of the object instance have their timestamps\n\t* updated to \"time\".\n\t*\n    * @param object_handle handle (RTI assigned) of object instance for which the\n    * attributes are to be updated.\n    * @param reflectedAttributes set of updated values for the attributes of the\n    * object instance corresponding to object_handle.\n    * @param time new time stamp for attributes that are updated\n    * @return the object instance with updated attribute values\n    */\n    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes, double time ) {\n    \tObjectRoot objectRoot = _objectMap.get( object_handle );\n    \tif ( objectRoot == null ) return null;\n    \tobjectRoot.setTime( time );\n    \tobjectRoot.setAttributes( reflectedAttributes );\n    \treturn objectRoot;\n    }\n\n\t/**\n\t* Requests an attribute update for this object instance from the federate that\n\t* has modification rights on these attributes.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic void requestUpdate( RTIambassador rti ) {\n\t\tboolean requestNotSubmitted = true;\n\t\twhile( requestNotSubmitted ) {\n\t\t\ttry {\t\t\n\t\t\t\trti.requestObjectAttributeValueUpdate( getObjectHandle(), getSubscribedAttributeHandleSet() );\n\t\t\t\trequestNotSubmitted = false;\n\t\t\t} catch ( FederateNotExecutionMember f ) {\n\t\t\t\tSystem.err.println( \"ERROR: \" + getClassName() + \"request for update failed:  Federate Not Execution Member\" );\n\t\t\t\tf.printStackTrace();\n\t\t\t\treturn;\t\t\t\t\n\t\t\t} catch ( ObjectNotKnown o ) {\n\t\t\t\tSystem.err.println( \"ERROR: \" + getClassName() + \"request for update failed:  Object Not Known\" );\n\t\t\t\to.printStackTrace();\n\t\t\t\treturn;\t\t\t\t\n\t\t\t} catch ( AttributeNotDefined a ) {\n\t\t\t\tSystem.err.println( \"ERROR: \" + getClassName() + \"request for update failed:  Name Not Found\" );\n\t\t\t\ta.printStackTrace();\n\t\t\t\treturn;\t\t\t\t\n\t\t\t} catch ( Exception e ) {\n\t\t\t\te.printStackTrace();\n\t\t\t\ttry { Thread.sleep( 50 ); } catch( Exception e1 ) { }\t\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Returns the object instance corresponding to the \"object_handle\" (RTI\n\t* assigned) from a map internal to the ObjectRoot class.\n\t* The object instance is referred to, via the return value, using an\n\t* an ObjectRoot reference.  To reference to it using a reference of its\n\t* actual class, the returned reference must be cast down through the\n\t* inhertance hierarchy.\n\t*\n\t* @param object_handle handle (RTI assigned) of object instance to retrieve\n\t* from the map internal to the ObjectRoot class.\n\t* @return object instance corresponding to the object_handle (RTI assigned)\n\t* in the map that is internal to the ObjectRoot class.\n\t*/\n\tpublic static ObjectRoot getObject( int object_handle ) {\n\t\treturn _objectMap.get( object_handle );\n\t}\n\t\n\t\n\t/**\n\t* Returns the object instance corresponding to the \"object_handle\" (RTI\n\t* assigned) from a map internal to the ObjectRoot class AND REMOVES IT\n\t* FROM THIS MAP.\n\t* The object instance is referred to, via the return value, using an\n\t* an ObjectRoot reference.  To reference to it using a reference of its\n\t* actual class, the returned reference must be cast down through the\n\t* inhertance hierarchy.\n\t*\n\t* @param object_handle handle (RTI assigned) of object instance to retrieve\n\t* from the map internal to the ObjectRoot class.\n\t* @return object instance corresponding to the object_handle (RTI assigned)\n\t* in the map that is internal to the ObjectRoot class.\n\t*/\n    public static ObjectRoot removeObject( int object_handle ) {\n        return _objectMap.remove( object_handle );\n    }\n    \n\n    private int _object_handle;\n\n    private void setObjectHandle( int object_handle ) {\n        _objectMap.remove( object_handle );\n        _object_handle = object_handle;\n        _objectMap.put( object_handle, this );\n    }\n\n\t/**\n\t* Returns the handle (RTI assigned) the corresponds to this object class\n\t* instance.  This handle is the instance's unique identifier to the RTI.\n\t*\n\t* @return the handle (RTI assigned) of this object class instance.\n\t*/\n    public int getObjectHandle() { return _object_handle; }\n\t\n<%}%>\n\n\tprivate double _time = -1;\n\t\n\t/**\n\t* Returns the timestamp for this <%=isinteraction?\"interaction\":\"object\"%>.  \"receive order\" <%=isinteraction?\"interaction\":\"object\"%>s\n\t* should have a timestamp of -1.\n\t*\n\t* @return timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\n\t*/\n\tpublic double getTime() { return _time; }\n\t\n\t/**\n\t* Sets the timestamp of this <%=isinteraction?\"interaction\":\"object\"%> to \"time\".\n\t*\n\t* @param time new timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\n\t*/\n\tpublic void setTime( double time ) { _time = time; }\n\n\t/**\n\t* Sets the timestamp of this <%=isinteraction?\"interaction\":\"object\"%> to \"logicalTime\".\n\t*\n\t* @param logicalTime new timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\n\t*/\n\tpublic void setTime( LogicalTime logicalTime ) {\n\t\tDoubleTime doubleTime = new DoubleTime();\n\t\tdoubleTime.setTo( logicalTime );\n\t\tsetTime( doubleTime.getTime() );\n\t}\n\n\n\t/**\n\t* Creates a new <%=isinteraction?\"Interaction\":\"Object\"%>Root instance.\n\t*/\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>Root() {\n\t\t_uniqueID = generateUniqueID();\n\t}\n\t\n\t/**\n\t* Creates a copy of an <%=isinteraction?\"Interaction\":\"Object\"%>Root instance.  As an\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>Root instance contains no <%=isinteraction?\"parameter\":\"attribute\"%>s,\n\t* this has the same effect as the default constructor.\n\t*/\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"Interaction\":\"Object\"%>Root <%=isinteraction?\"interaction\":\"object\"%>Root ) {\n\t\tthis();\n\t}\n\n\tprotected <%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, boolean initFlag ) {\n\t\tthis();\n\t\tif ( initFlag ) set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\n\t}\n\t\n\tprotected <%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime, boolean initFlag ) {\n\t\tthis();\n\t\tsetTime( logicalTime );\n\t\tif ( initFlag ) set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\n\t}\n\n\n\t/**\n\t* Creates a new <%=isinteraction?\"interaction\":\"object\"%> instance and initializes its <%=isinteraction?\"parameter\":\"attribute\"%>s\n\t* using the \"datamemberMap\" -- this constructor is usually called as a\n\t* super-class constructor to create and initialize an instance of an\n\t* <%=isinteraction?\"interaction\":\"object\"%> further down in the inheritance hierarchy.  \"datamemberMap\"\n\t* is usually acquired as an argument to an RTI federate callback method, such\n\t* as \"receiveInteraction\".\n\t*\n\t* @param datamemberMap contains <%=isinteraction?\"parameter\":\"attribute\"%> values for the newly created\n\t* <%=isinteraction?\"interaction\":\"object\"%>\n\t*/\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\n\t\tthis( datamemberMap, true );\n\t}\n\n\t/**\n\t* Like {@link #<%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap )},\n\t* except the new instance has an initial timestamp of \"logicalTime\".\n\t*\n\t* @param datamemberMap contains <%=isinteraction?\"parameter\":\"attribute\"%> values for the newly created\n\t* <%=isinteraction?\"interaction\":\"object\"%>\n\t* @param logicalTime initial timestamp for newly created <%=isinteraction?\"interaction\":\"object\"%> instance\n\t*/\t\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime ) {\n\t\tthis( datamemberMap, logicalTime, true );\n\t}\n\n\t/**\n\t* Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" for this\n\t* <%=isinteraction?\"interaction\":\"object\"%>.\n\t*\n\t* @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value to retrieve\n\t* @return the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose name is \"datamemberName\"\n\t*/\n\tpublic Object get<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName ) {\n\t\treturn null;\n\t}\n\n\t/**\n\t* Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose handle is \"datamemberHandle\"\n\t* (RTI assigned) for this <%=isinteraction?\"interaction\":\"object\"%>.\n\t*\n\t* @param datamemberHandle handle (RTI assigned) of <%=isinteraction?\"parameter\":\"attribute\"%> whose\n\t* value to retrieve\n\t* @return the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose handle is \"datamemberHandle\"\n\t*/\n\tpublic Object get<%=isinteraction?\"Parameter\":\"Attribute\"%>( int datamemberHandle ) {\n\t\treturn null;\n\t}\n\t\t\n\t/**\n\t* Set the values of the <%=isinteraction?\"parameter\":\"attribute\"%>s in this <%=isinteraction?\"interaction\":\"object\"%> using\n\t* \"datamemberMap\".  \"datamemberMap\" is usually acquired as an argument to\n\t* an RTI federate callback method such as \"receiveInteraction\".\n\t*\n\t* @param datamemberMap  contains new values for the <%=isinteraction?\"parameter\":\"attribute\"%>s of\n\t* this <%=isinteraction?\"interaction\":\"object\"%>\n\t*/\n\tpublic void set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\n\t\tint size = datamemberMap.size();\n\t\tfor( int ix = 0 ; ix < size ; ++ix ) {\n\t\t\ttry {\n\t\t\t\tset<%=isinteraction?\"Parameter\":\"Attribute\"%>(  datamemberMap.get<%=isinteraction?\"Parameter\":\"Attribute\"%>Handle( ix ), datamemberMap.getValue( ix )  );\n\t\t\t} catch ( Exception e ) {\n\t\t\t\tSystem.err.println( \"set<%=isinteraction?\"Parameter\":\"Attribute\"%>s: Exception caught!\" );\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void set<%=isinteraction?\"Parameter\":\"Attribute\"%>( int handle, byte[] val ) {\n\t\tif ( val == null ) {\n\t\t\tSystem.err.println( \"set:  Attempt to set null value in class \\\"\" + getClass().getName() + \"\\\"\" );\n\t\t}\n\t\tif (   !set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux(  handle, new String( val )  )   ) {\n\t\t\tSystem.err.println( \"set:  bad <%=isinteraction?\"parameter\":\"attribute\"%> handle in class \\\"\" + getClass().getName() + \"\\\"\" );\n\t\t}\n\t}\n\t\n\t/**\n\t* Sets the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" to \"value\"\n\t* in this <%=isinteraction?\"interaction\":\"object\"%>.  \"value\" is converted to data type of \"datamemberName\"\n\t* if needed.\n\t* This action can also be affected by calling the set_<datamemberName>( value )\n\t* method on the <%=isinteraction?\"interaction\":\"object\"%> using a reference to the <%=isinteraction?\"interaction\":\"object\"%>'s actual\n\t* class.\n\t*\n\t* @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be set\n\t* to \"value\"\n\t* @param value new value of <%=isinteraction?\"parameter\":\"attribute\"%> called \"datamemberName\"\n\t*/\n\tpublic void set<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName, String value ) {\n\t\tif (  !set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, value )  ) {\n\t\t\tSystem.err.println( \"Error:  <%=isinteraction?\"interaction\":\"object\"%>Root:  invalid <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" + datamemberName + \"\\\"\" );\n\t\t}\n\t}\n\n\t/**\n\t* Sets the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" to \"value\"\n\t* in this <%=isinteraction?\"interaction\":\"object\"%>.  \"value\" should have the same data type as that of\n\t* the \"datamemberName\" <%=isinteraction?\"parameter\":\"attribute\"%>.\n\t* This action can also be affected by calling the set_<datamemberName>( value )\n\t* method on the <%=isinteraction?\"interaction\":\"object\"%> using a reference to the <%=isinteraction?\"interaction\":\"object\"%>'s actual\n\t* class.\n\t*\n\t* @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be set\n\t* to \"value\"\n\t* @param value new value of <%=isinteraction?\"parameter\":\"attribute\"%> called \"datamemberName\"\n\t*/\n\tpublic void set<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName, Object value ) {\n\t\tif (  !set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, value )  ) {\n\t\t\tSystem.err.println( \"Error:  <%=isinteraction?\"interaction\":\"object\"%>Root:  invalid <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" + datamemberName + \"\\\"\" );\n\t\t}\n\t}\n\n\tprotected boolean set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( int param_handle, String val ) {\n\t\treturn false;\n\t}\n\n\tprotected boolean set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( String datamemberName, String value ) {\n\t\treturn false;\n\t}\n\n\tprotected boolean set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( String datamemberName, Object value ) {\n\t\treturn false;\n\t}\n\n\tprotected Supplied<%=isinteraction?\"Parameter\":\"Attribute\"%>s createSuppliedDatamembers(<% if(isinteraction){ %><%}else{%>boolean force<%}%>) {\n\t\treturn _factory.createSupplied<%=isinteraction?\"Parameter\":\"Attribute\"%>s();\n\t}\n\t\n<% if(isinteraction){ %>\n\t/**\n\t* Sends this interaction to the RTI, with the specified timestamp \"time\".\n\t* This method should be used to send interactions that have \"timestamp\"\n\t* ordering.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t* @param time timestamp for this interaction.  The timestamp should be no\n\t* less than the current federation time + the LOOKAHEAD value of the federate\n\t* sending this interaction.\n\t*/\n\tpublic void sendInteraction( RTIambassador rti, double time ) throws Exception {\n\t\tsynchronized( rti ) {\n\t\t\ttry {\n\t\t\t\tSuppliedParameters datamembers = createSuppliedDatamembers();\n\t\t\t\trti.sendInteraction(  getClassHandle(), datamembers, null, new DoubleTime( time )  );\n\t\t\t\tcreateLog(datamembers,time);\n\t\t\t} catch ( Exception e ) {\n\t\t\t\tSystem.err.println( \"ERROR:  \" + getClass().getName() + \":  could not send interaction\" );\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Sends this interaction to the RTI (without a timestamp).\n\t* This method should be used to send interactions that have \"receive\"\n\t* ordering.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic void sendInteraction( RTIambassador rti ) throws Exception {\n\t\tsynchronized( rti ) {\n\t\t\ttry {\n\t\t\t\tSuppliedParameters datamembers = createSuppliedDatamembers();\n\t\t\t\trti.sendInteraction( getClassHandle(), datamembers, null );\n\t\t\t\tcreateLog(datamembers,0);\n\t\t\t} catch ( Exception e ) {\n\t\t\t\tSystem.err.println( \"ERROR:  \" + getClass().getName() + \":  could not send interaction\" );\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprotected static String fedName = null;\n\tpublic static Boolean enablePubLog = false;\n\tpublic static Boolean enableSubLog = false;\n\tpublic static String pubLogLevel = null;\n\tpublic static String subLogLevel = null;\n\t\n\tpublic static void enablePublishLog(String interaction, String fed, String thislevel, String globallevel){\n\t\tif(globallevel == null || \"\".equals(globallevel)) return;\n\t\tif(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;\n\t\tfedName = fed;\n\t\tenablePubLog = true;\n\t\tpubLogLevel = thislevel;\n\t\tC2WLogger.addLog(interaction, fedName, true);\n\t}\n\t\n\tpublic static void enableSubscribeLog(String interaction, String fed, String thislevel, String globallevel){\n\t\tif(globallevel == null || \"\".equals(globallevel)) return;\n\t\tif(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;\n\t\tfedName = fed;\n\t\tenableSubLog = true;\n\t\tsubLogLevel = thislevel;\n\t\tC2WLogger.addLog(interaction, fedName, false);\n\t}\n\t\n\tprotected void createLog(final SuppliedParameters datamembers, final double time) {\n\t\tif(!enablePubLog) return;\n        Thread t = new Thread(new Runnable() {                                                                                 // NOMELD\n            public void run() {                                                                                                // NOMELD\n\t\t\t\ttry {\n\t\t\t\t\tString interactionId = fedName != null ? fedName + \"_pub_\"+ getSimpleClassName() :getSimpleClassName() + \"_pub\";\n\n\t\t\t\t\t// First just record the interaction event as a log\n\t\t\t\t\tC2WLogger.addEventLog(time, interactionId);\n\n\t\t\t\t\t// Now, log detailed simulation data of the interaction\n\t\t\t\t\tString logIdLocal = null;\n\t\t\t\t\tsynchronized( <%=isinteraction?\"Interaction\":\"Object\"%>Root.class ) {\n\t\t\t\t\t\tlogIdLocal = Integer.toString( logId++ );\n\t\t\t\t\t}\n\n\t\t\t\t\tint noDatamembers = datamembers.size();\n\t\t\t\t\tif ( noDatamembers == 0 ) {\n\t\t\t\t\t\tC2WLogger.addLog( interactionId, time, null, null, null, pubLogLevel, logIdLocal );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor(int ix =0; ix < datamembers.size();ix++){\n\t\t\t\t\t\t\tString parameter = get_parameter_name(datamembers.getHandle( ix ) );\n\t\t\t\t\t\t\tString value = new String(datamembers.getValue(ix));\t\n\t\t\t\t\t\t\tString type = new String(_datamemberTypeMap.get(parameter));\n\t\t\t\t\t\t\tC2WLogger.addLog( interactionId, time, parameter, value, type, pubLogLevel, logIdLocal );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch ( Exception e ) {\n\t\t\t\t\tSystem.err.println( \"ERROR:  \" + getClass().getName() + \":  could not send interaction\" );\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n            }\n        });\n        t.start();\n\t}\n\n<%}else{%>\n    private boolean _isRegistered = false;\n\n\t/**\n\t* Registers this object with the RTI.  This method is usually called by a\n\t* federate who \"owns\" this object, i.e. the federate that created it and\n\t* has write-privileges to its attributes (so, it is responsible for updating\n\t* these attribute and conveying their updated values to the RTI).\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/ \n    public void registerObject( RTIambassador rti ) {\n        \n        while( !_isRegistered ) {\n            try {\n                synchronized( rti ) {\n                    _object_handle = rti.registerObjectInstance( getClassHandle() );\n                }\n                _isRegistered = true;\n                _objectMap.put( getObjectHandle(), this );\n                \n            } catch ( ObjectClassNotDefined o ) {\n                o.printStackTrace();\n                return;\n            } catch ( ObjectClassNotPublished o ) {\n                o.printStackTrace();\n                return;\n            } catch ( FederateNotExecutionMember f ) {\n                f.printStackTrace();\n                return;\n            } catch ( Exception e ) {\n                try {\n                    Thread.sleep( 500 );\n                } catch ( InterruptedException e1 ) {\n                    e1.printStackTrace();\n                } \n            }\n        }\n\n    }\n    \n\t/**\n\t* Unregisters this object with the RTI.  The RTI will destroy all information\n\t* it contains regarding this object as a result.  This method is usually\n\t* called by a federate who \"owns\" this object, i.e. the federate that created\n\t* it and has write-privileges to its attributes.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/ \n    public void unregisterObject( RTIambassador rti ) {\n        \n        while( _isRegistered ) {\n            try {\n                synchronized( rti ) {\n                    rti.deleteObjectInstance( _object_handle, null );\n                }\n                _isRegistered = false;\n                _objectMap.remove( getObjectHandle() );\n                \n            } catch ( ObjectNotKnown o ) {\n                o.printStackTrace();\n                return;\n            } catch ( DeletePrivilegeNotHeld d ) {\n                d.printStackTrace();\n                return;\n            } catch ( FederateNotExecutionMember f ) {\n                f.printStackTrace();\n                return;\n            } catch ( Exception e ) {\n                try {\n                    Thread.sleep( 500 );\n                } catch ( InterruptedException e1 ) {\n                    e1.printStackTrace();\n                } \n            }\n        }\n    }\n\n\t/**\n\t* Broadcasts the attributes of this object and their values to the RTI, where\n\t* the values have \"time\" as their timestamp.  This call should be used for\n\t* objects whose attributes have \"timestamp\" ordering.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t* @param time timestamp on attribute values of this object\n\t* @param force if \"false\", only the attributes whose values have changed since\n\t* the last call to \"updateAttributeValues\" will be broadcast to the RTI.  If\n\t* \"true\", all attributes and their values are broadcast to the RTI.\n\t*/\n    public void updateAttributeValues( RTIambassador rti, double time, boolean force ) {\n\n        SuppliedAttributes suppliedAttributes = createSuppliedDatamembers( force );\n        if ( suppliedAttributes.size() == 0 ) return;\n\n        synchronized( rti ) {\n            try {\n                rti.updateAttributeValues(  getObjectHandle(), suppliedAttributes, null, new DoubleTime( time )  );\n                createLog(suppliedAttributes, time);\n            } catch ( ObjectNotKnown o ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Object Not Known\" );\n                o.printStackTrace();\n                return;\n            } catch ( FederateNotExecutionMember f ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Federate Not Execution Member\" );\n                f.printStackTrace();\n                return;\n            } catch ( AttributeNotDefined a ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Attribute Not Defined\" );\n                a.printStackTrace();\n                return;\n            } catch ( AttributeNotOwned a ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Attribute Not Owned\" );\n                a.printStackTrace();\n                return;\n            } catch ( ConcurrentAccessAttempted c ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Concurrent Access Attempted\" );\n                c.printStackTrace();\n                return;\n            } catch ( InvalidFederationTime i ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Invalid Federation Time\" );\n                i.printStackTrace();\n                return;\n            } catch ( Exception e ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes\" );\n                e.printStackTrace();\n            }\n        }\n    }\n\n\t/**\n    * Like {@link #updateAttributeValues( RTIambassador rti, double time, boolean force )},\n    * except \"force\" is always false.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t* @param time timestamp on attribute values of this object\n\t*/\n    public void updateAttributeValues( RTIambassador rti, double time ) {\n    \tupdateAttributeValues( rti, time, false );\n    }\n\n\t/**\n\t* Broadcasts the attributes of this object and their values to the RTI (with\n\t* no timestamp).  This call should be used for objects whose attributes have\n\t* \"receive\" ordering.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t* @param force if \"false\", only the attributes whose values have changed since\n\t* the last call to \"updateAttributeValues\" will be broadcast to the RTI.  If\n\t* \"true\", all attributes and their values are broadcast to the RTI.\n\t*/\n    public void updateAttributeValues( RTIambassador rti, boolean force ) {\n\n        SuppliedAttributes suppliedAttributes = createSuppliedDatamembers( force );\n        if ( suppliedAttributes.size() == 0 ) return;\n\n        synchronized( rti ) {\n            try {\n                rti.updateAttributeValues( getObjectHandle(), suppliedAttributes, null );\n                createLog(suppliedAttributes, 0);\n            } catch ( ObjectNotKnown o ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Object Not Known\" );\n                o.printStackTrace();\n                return;\n            } catch ( FederateNotExecutionMember f ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Federate Not Execution Member\" );\n                f.printStackTrace();\n                return;\n            } catch ( AttributeNotDefined a ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Attribute Not Defined\" );\n                a.printStackTrace();\n                return;\n            } catch ( AttributeNotOwned a ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Attribute Not Owned\" );\n                a.printStackTrace();\n                return;\n            } catch ( ConcurrentAccessAttempted c ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Concurrent Access Attempted\" );\n                c.printStackTrace();\n                return;\n            } catch ( Exception e ) {\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes\" );\n                e.printStackTrace();\n            }\n        }\n    }\n\n\t/**\n    * Like {@link #updateAttributeValues( RTIambassador rti, boolean force )},\n    * except \"force\" is always false.\n\t*\n\t* @param rti handle to the RTI, usu. obtained through the\n\t* {@link SynchronizedFederate#getRTI()} call\n\t*/\n\tpublic void updateAttributeValues( RTIambassador rti ) {\n\t\tupdateAttributeValues( rti, false );\n\t}\n\n\tprotected static String _fedName = null;\n\tprotected static Map< String, String > _pubAttributeLogMap = new HashMap< String, String >();\n\tprotected static Map< String, String > _subAttributeLogMap = new HashMap< String, String >();\n\t\n\tpublic static void enablePublishLog(String object, String attribute, String fed, String thislevel, String globallevel){\n\t\tif(globallevel == null || \"\".equals(globallevel)) return;\n\t\tif(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;\n\t\t_fedName = fed;\n\t\t_pubAttributeLogMap.put(attribute, thislevel);\n\t\tC2WLogger.addLog(object, attribute, fed, true);\n\t}\n\t\n\tpublic static void enableSubscribeLog(String object, String attribute, String fed, String thislevel, String globallevel){\n\t\tif(globallevel == null || \"\".equals(globallevel)) return;\n\t\tif(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;\n\t\t_fedName = fed;\n\t\t_subAttributeLogMap.put(attribute, thislevel);\n\t\tC2WLogger.addLog(object, attribute, fed, true);\n\t}\n\t\n\tprotected void createLog(final SuppliedAttributes suppliedAttributes, final double time) {\n\t\tif(_pubAttributeLogMap.isEmpty()) return;\n        Thread t = new Thread(new Runnable() {                                                       // NOMELD\n            public void run() {                                                                      // NOMELD\n\t\t\t\ttry {\n\t\t\t\t\tString eventName = _fedName+\"_pub_\"+getSimpleClassName();\n\n\t\t\t\t\t// First just record the interaction event as a log\n\t\t\t\t\tC2WLogger.addEventLog(time, eventName);\n\n\t\t\t\t\t// Now, log detailed simulation data of the object update\n\t\t\t\t\tString logIdLocal = null;\n\t\t\t\t\tsynchronized( <%=isinteraction?\"Interaction\":\"Object\"%>Root.class ) {\n\t\t\t\t\t\tlogIdLocal = Integer.toString( logId++ );\n\t\t\t\t\t}\n\t\t\t\t\tfor(int ix =0; ix < suppliedAttributes.size();ix++){\t\t\t\t\t\t\t\n\t\t\t\t\t\tString attribute = get_attribute_name(suppliedAttributes.getHandle( ix ) );\t\t\t\n\t\t\t\t\t\tif(!_pubAttributeLogMap.containsKey(attribute)) continue;\n\t\t\t\t\t\tString id = _fedName+\"_pub_\"+getSimpleClassName()+\"_\"+attribute;\n\t\t\t\t\t\tString value = new String(suppliedAttributes.getValue(ix));\t\n\t\t\t\t\t\tString type = new String(_datamemberTypeMap.get(attribute));\n\t\t\t\t\t\tString loglevel = _pubAttributeLogMap.get(attribute);\n\t\t\t\t\t\tC2WLogger.addLog( id, time, attribute, value, type, loglevel, logIdLocal );\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} catch ( Exception e ) {\n\t\t\t\t\tSystem.err.println( \"ERROR:  \" + getClass().getName() + \":  could not send interaction\" );\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n            }\n        });\n        t.start();\n\t}\n\t\n<%}%>\n\n\t/**\n\t* For use with the melding API -- this method is used to cast\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>Root instance reference into the\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface interface.\n\t*\n\t* @param rootInstance <%=isinteraction?\"Interaction\":\"Object\"%>Root instance reference to be\n\t* cast into the <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface interface\n\t* @return <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface reference to the instance\n\t*/\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface cast( <%=isinteraction?\"Interaction\":\"Object\"%>Root rootInstance ) {\n\t\treturn rootInstance;\n\t}\t\t\n\n\t/**\n\t* For use with the melding API -- this method creates a new\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>Root instance and returns a\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface reference to it.\n\t*\n\t* @return <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface reference to a newly created\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>Root instance\n\t*/\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface create() {\n\t\treturn new <%=isinteraction?\"Interaction\":\"Object\"%>Root();\n\t}\t\t\n\n\tpublic void copyFrom( Object object ) { }\n}\n",
    "cppfedbase_pom.xml.ejs": "<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n<% if (parent){ %>\n  <parent>\n    <groupId><%=parent.groupId%></groupId>\n    <artifactId><%=parent.artifactId%></artifactId>\n    <version><%=parent.version%></version>\n  </parent>\n<%} -%>\n  <groupId><%=groupId%></groupId>\n  <artifactId><%=artifactId%></artifactId>\n  <version><%=version%></version>\n  <packaging><%=packaging%></packaging>\n  <name><%=name%></name>\n  <description><%=description%></description>\n\n<% if(projects && projects.length > 0){ %> \n    <modules>\n      <% projects.forEach(function(project){ %>\n      <module><%= project.directory ? project.directory : project.artifactId %></module><%}); %> \n    </modules>  \n<%}%>\n    <properties>\n        <boost.version>1.57.0+nar.10</boost.version>\n        <nar-plugin.version>3.3.0</nar-plugin.version>\n        <compiler-name>g++</compiler-name>\n        <linker-name>g++</linker-name>\n    </properties>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>com.github.maven-nar</groupId>\n                <artifactId>nar-maven-plugin</artifactId>\n                <version>${nar-plugin.version}</version>\n                <extensions>true</extensions>\n                <configuration>\n                    <libraries>\n                        <library> \n                            <type>static</type>\n                        </library>\n                    </libraries>\n                    <cpp>\n                        <name>${compiler-name}</name>\n                        <debug>false</debug>\n                        <includes>\n                            <include>**/*.hpp</include>\n                            <include>**/*.h</include>\n                            <include>**/*.cpp</include>\n                            <include>**/*.c</include>\n                        </includes>\n                        <options combine.children=\"append\">\n                            <!--option>-std=c++11</option-->\n                            <option>-ftemplate-depth-128</option>\n                            <option>-fno-inline</option>\n                            <option>-Wall</option>\n                            <option>-pedantic</option>\n                            <option>-Wno-long-long</option>\n                            <option>-Wno-variadic-macros</option>\n                        </options>\n                        <defines>\n                          <!--define>USE_MYSQL_LOGGING</define-->\n                          <define>RTI_USES_STD_FSTREAM</define>\n                        </defines>\n                        <systemIncludePaths>\n                          <systemIncludePath>${build.BOOST_INC_DIR}</systemIncludePath>\n                        </systemIncludePaths>\n                    </cpp>\n                    <linker>\n                        <name>${linker-name}</name>\n                        <incremental>false</incremental>\n                        <libs>\n                          <lib>\n                            <name>RTI-NG64</name>\n                            <type>shared</type>\n                            <directory>${build.RTI_LIB_DIR}</directory>\n                          </lib>\n                          <lib>\n                            <name>FedTime64</name>\n                            <type>shared</type>\n                            <directory>${build.RTI_LIB_DIR}</directory>\n                          </lib>\n                          <lib>\n                            <name>boost_thread</name>\n                            <type>shared</type>\n                            <directory>${build.BOOST_LIB_DIR}</directory>\n                          </lib>\n                          <lib>\n                            <name>boost_system</name>\n                            <type>shared</type>\n                            <directory>${build.BOOST_LIB_DIR}</directory>\n                          </lib>\n                          <lib>\n                            <name>mysqlcppconn</name>\n                            <type>shared</type>\n                            <directory>${build.MYSQL_LIB_DIR}</directory>\n                          </lib>\n                        </libs>\n                        \n                    </linker>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n\n\n    <profiles>\n        <profile>\n          <id>include-generated</id>\n          <activation>\n                <activeByDefault>false</activeByDefault>\n            </activation>\n          <modules>\n              <module>HelloWorld_base-cpp</module>   \n          </modules>  \n        </profile>\n\n        <profile>\n            <id>windows-common</id>\n            <activation>\n                <os>\n                    <family>windows</family>\n                </os>\n            </activation>\n            <properties>\n              <build.RTI_LIB_DIR>${env.RTI_LIB_DIR}</build.RTI_LIB_DIR>\n              <build.BOOST_INC_DIR>${env.BOOST_INC_DIR}</build.BOOST_INC_DIR>\n              <build.BOOST_LIB_DIR>${env.BOOST_LIB_DIR}</build.BOOST_LIB_DIR>\n              <build.MYSQL_LIB_DIR>${env.MYSQL_LIB_DIR}</build.MYSQL_LIB_DIR>\n            </properties>\n            <build>\n                <plugins>\n                    <plugin>\n                        <groupId>com.github.maven-nar</groupId>\n                        <artifactId>nar-maven-plugin</artifactId>\n                        <extensions>true</extensions>\n                        <configuration>\n                            <cpp>\n                                <options combine.children=\"append\">\n                                    <option>-mthreads</option>\n                                </options>\n                            </cpp>\n                        </configuration>\n                    </plugin>\n                </plugins>\n            </build>\n        </profile>\n\n        <profile>\n            <id>linux-common</id>\n            <activation>\n                <os>\n                    <family>linux</family>\n                </os>\n            </activation>\n            <properties>\n              <build.RTI_LIB_DIR>${env.RTI_HOME}/lib/gcc4</build.RTI_LIB_DIR>\n              <build.BOOST_INC_DIR>/usr/include/boost</build.BOOST_INC_DIR>\n              <build.BOOST_LIB_DIR>/usr/lib/x86_64-linux-gnu</build.BOOST_LIB_DIR>\n              <build.MYSQL_LIB_DIR>/usr/lib/</build.MYSQL_LIB_DIR>\n            </properties>\n            <build>\n                <plugins>\n                    <plugin>\n                        <groupId>com.github.maven-nar</groupId>\n                        <artifactId>nar-maven-plugin</artifactId>\n                        <extensions>true</extensions>\n                        <configuration>\n                            <cpp>\n                                <options combine.children=\"append\">\n                                    <option>-pthread</option>\n                                </options>\n                            </cpp>\n                        </configuration>\n                    </plugin>\n                </plugins>\n            </build>\n        </profile>\n\n        <profile>\n            <id>mac-common</id>\n            <activation>\n                <os>\n                    <family>mac</family>\n                </os>\n            </activation>\n            <properties>\n              <build.RTI_LIB_DIR>${env.RTI_LIB_DIR}</build.RTI_LIB_DIR>\n              <build.BOOST_INC_DIR>${env.BOOST_INC_DIR}</build.BOOST_INC_DIR>\n              <build.BOOST_LIB_DIR>${env.BOOST_LIB_DIR}</build.BOOST_LIB_DIR>\n              <build.MYSQL_LIB_DIR>${env.MYSQL_LIB_DIR}</build.MYSQL_LIB_DIR>\n            </properties>\n            <build>\n                <plugins>\n                    <plugin>\n                        <groupId>com.github.maven-nar</groupId>\n                        <artifactId>nar-maven-plugin</artifactId>\n                        <extensions>true</extensions>\n                        <configuration>\n                            <cpp>\n                                <options combine.children=\"append\">\n                                    <option>-pthread</option>\n                                </options>\n                            </cpp>\n                        </configuration>\n                    </plugin>\n                </plugins>\n            </build>\n        </profile>\n    </profiles>\n  \n</project>",
    "federate.hpp.ejs": "<%/* group cppfederate;\n\nfederate(\n\tsimname,\n\tclassname,\n\tisnonmapperfed,\n\ttimeconstrained,\n\ttimeregulating,\n\tlookahead,\n\tasynchronousdelivery,\n\tallinteractiondata,\n\tpublishedinteractiondata,\n\tsubscribedinteractiondata,\n\tallobjectdata,\n\tpublishedobjectdata,\n\tsubscribedobjectdata\n) ::= <<\n*/ -%>\n#ifndef _<%=classname%>Base_\n#define _<%=classname%>Base_\n\n// This code has been generated by the C2W code generator.\n// Do not edit manually!\n\n#include <vector>\n\n#include \"SynchronizedFederate.hpp\"\n#include \"SubscribedInteractionFilter.hpp\"\n\n<% allinteractiondata.forEach(function(interactiondata){ %>\n#include \"<%=interactiondata.name%>.hpp\"<%});%>\n<% allobjectdata.forEach(function(interactiondata){ %>\n#include \"<%=interactiondata.name%>.hpp\"<%});%>\n#include \"C2WLogger.hpp\"\n\nclass <%=classname%>Base : public SynchronizedFederate {\n\npublic:\n\ttypedef SynchronizedFederate Super;\n\t\n\n\ttypedef std::vector< std::string > ArgVector;\n\t\n\tstatic double getLookAhead( void ) {\n\t\tstatic double lookAhead = <%=lookahead%>;\n\t\treturn lookAhead;\n\t}\n\n\tvirtual ~<%=classname%>Base( void )\n\t throw (RTI::FederateInternalError) { }\n\nprivate:\n\tSubscribedInteractionFilter _subscribedInteractionFilter;\n\nprotected:\n\tvoid init( ArgVector argVector ) {\n\n\t\tcreateRTI();\n\t\tjoinFederation( argVector[ 0 ], argVector[ 1 ] );\n\t\t\n\t\tstd::string loglevel=\"\";\n\t\tArgVector loggerArgVector;\n\t\tif ( argVector.size() == 3 ) {\n\t\t\tloggerArgVector.push_back( argVector[ 2 ] );\n\t\t} else if ( argVector.size() > 3 ) {\n\t\t\tloggerArgVector.push_back( argVector[ 3 ] );\n\t\t}\n\t\t_logger->init(loggerArgVector);\n\t\t\n\t\tif ( argVector.size() == 5 ) {\n\t\t\tloglevel = argVector[ 4 ];\n\t\t}\n\t\t\t\n<% if(timeconstrained){ %>\n\t\tenableTimeConstrained();\n<%}%>\n\n<% if(timeregulating){ %>\n\t\tenableTimeRegulation( getLookAhead() );\n<%}%>\n\n<% if(asynchronousdelivery){ %>\n\t\tenableAsynchronousDelivery();\n<%}%>\n\n\n        // interaction pubsub\n        <% /*publishedinteractiondata:pubinter()*/ %>\n        <% publishedinteractiondata.forEach(function(interactiondata){ %>\n        <%=interactiondata.name%>::publish( getRTI() );<%});%>\n        <% /*subscribedinteractiondata:subinter()*/ %>  \n        <% subscribedinteractiondata.forEach(function(interactiondata){ %>  \n        <%=interactiondata.name%>::subscribe( getRTI() );\n\t\t_subscribedInteractionFilter.setFedFilters( <%=interactiondata.name%>::get_handle(), SubscribedInteractionFilter::<%=interactiondata.originFedFilter()%>, SubscribedInteractionFilter::<%=interactiondata.srcFedFilter()%> );<%});%>  \n\t\t\n\t\t// object pubsub\n        <% /*publishedobjectdata:pubobjectdata()*/ %>\n        <% publishedobjectdata.forEach(function(objectdata){ %>\n        <% objectdata.publishedAttributeData.forEach(function(attributedata){ %>\n        <%=objectdata.name%>::publish_<%=attributedata.name%>();<%});%>  \n        <%=objectdata.name%>::publish( getRTI() );<%});%>  \n\n        <% /*subscribedobjectdata:subobjectdata()*/ %> \n        <% subscribedobjectdata.forEach(function(objectdata){ %>\n        <% objectdata.subscribedAttributeData.forEach(function(attributedata){ %>\n        <%=objectdata.name%>::subscribe_<%=attributedata.name%>();<%});%> \n        <%=objectdata.name%>::subscribe( getRTI() );<%});%>  \n   \n        \n         // enable pubsub log\n         if( argVector.size() > 2 ){\n\t\t\t<% /*publishedinteractiondata:publoginter()*/ %>\n\t\t\t<% publishedinteractiondata.forEach(function(interactiondata){ %>\n\t\t\t<%=interactiondata.name%>::enablePublishLog(\"<%=interactiondata.name%>\", \"<%=classname%>\", \"<%=interactiondata.publishedLoglevel%>\", loglevel);<%});%>  \n\t\t\t<% /*subscribedinteractiondata:subloginter()*/ %>\n\t\t\t<% subscribedinteractiondata.forEach(function(interactiondata){ %>\n\t\t\t<%=interactiondata.name%>::enableSubscribeLog(\"<%=interactiondata.name%>\", \"<%=classname%>\", \"<%=interactiondata.subscribedLoglevel%>\", loglevel);<%});%>  \n\t\t\t<% /*publishedobjectdata:publogobject()*/ %>\n\t\t\t<% publishedobjectdata.forEach(function(objectdata){ %>\n\t\t\t<% objectdata.logPublishedAttributeData.forEach(function(attributedata){ %>\n\t\t\t<%=objectdata.name%>::enablePublishLog(\"<%=objectdata.name%>\", \"<%=attributedata.name%>\", \"<%= classname %>\", \"<%= objectdata.publishedLoglevel %>\", loglevel);<%});%><%});%>  \n\t\t\t<% /*subscribedobjectdata:sublogobject()*/ %>\n\t\t\t<% subscribedobjectdata.forEach(function(objectdata){ %>\n\t\t\t<% objectdata.logSubscribedAttributeData.forEach(function(attributedata){ %>\n\t\t\t<%=objectdata.name%>::enableSubscribeLog(\"<%=objectdata.name%>\", \"<%=attributedata.name%>\", \"<%= classname %>\", \"<%= objectdata.subscribedLoglevel %>\", loglevel);<%});%> <%});%>  \n\t\t}\n\n\t}\n\n\tvoid init( int argc, char *argv[] ) {\n\t\tArgVector argVector;\n\t\tfor( int ix = 1 ; ix < argc ; ++ix ) argVector.push_back( argv[ ix ] );\n\t\tinit( argVector );\n\t}\n\t\n\tvoid init( const std::string &federation_id, const std::string &federate_id ) {\n\t\tArgVector argVector;\n\t\targVector.push_back( federation_id );\n\t\targVector.push_back( federate_id );\n\t\tinit( argVector );\n\t}\n\t\npublic:\t\n\t// default constructor\n\t<%=classname%>Base( void ) { }\n\t\n\t// constructor\n\t<%=classname%>Base( const std::string &federation_id, const std::string &federate_id ) { init( federation_id, federate_id ); }\n\n\t// constructor\t\n\t<%=classname%>Base( int argc, char *argv[] ) { init( argc, argv ); }\n\n\t<% /*publishedinteractiondata:create_interaction()*/ %>\n\t<% publishedinteractiondata.forEach(function(interactiondata){ %>\n\t<%=interactiondata.name%>SP create_<%=interactiondata.name%>( void ) {\n\t   <%=interactiondata.name%>SP interactionSP = <%=interactiondata.name%>::create();\n\t   interactionSP->set_sourceFed( getFederateId() );\n\t   interactionSP->set_originFed( getFederateId() );\n\t   return interactionSP;\n\t}<%});%>  \n\n    <% /*filter_interaction()*/ %>\n    virtual void receiveInteraction(\n\t RTI::InteractionClassHandle theInteraction,\n\t const RTI::ParameterHandleValuePairSet& theParameters,\n\t const RTI::FedTime& theTime,\n\t const char *theTag,\n\t RTI::EventRetractionHandle theHandle\n\t)\n\t throw ( RTI::InteractionClassNotKnown, RTI::InteractionParameterNotKnown, RTI::InvalidFederationTime, RTI::FederateInternalError) {\n\n\t\tif ( getMoreATRs() ) {\n\t\t\tInteractionRoot::SP interactionRootSP = InteractionRoot::create_interaction( theInteraction, theParameters, theTime );\n\t\t\tC2WInteractionRootSP c2wInteractionRootSP = boost::dynamic_pointer_cast< C2WInteractionRoot >( interactionRootSP );\n\t\t\tif ( c2wInteractionRootSP != 0 ) {\n\n\t            // Filter interaction if src/origin fed requirements (if any) are not met\n\t            if (  _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRootSP )  ) {\n\t            \treturn;\n\t            }\n\t        }\n\n\t        Super::receiveInteraction( theInteraction, theParameters, theTime, theTag, theHandle );\n\t    }\n\t}\n\n\tvirtual void receiveInteraction(\n\t RTI::InteractionClassHandle theInteraction,\n\t const RTI::ParameterHandleValuePairSet& theParameters,\n\t const char *theTag\n\t)\n\t throw ( RTI::InteractionClassNotKnown, RTI::InteractionParameterNotKnown, RTI::FederateInternalError) {\n\t\tif ( getMoreATRs() ) {\n\t\t\tInteractionRoot::SP interactionRootSP = InteractionRoot::create_interaction( theInteraction, theParameters );\n\t\t\tC2WInteractionRootSP c2wInteractionRootSP = boost::dynamic_pointer_cast< C2WInteractionRoot >( interactionRootSP );\n\t\t\tif ( c2wInteractionRootSP != 0 ) {\n\n\t            // Filter interaction if src/origin fed requirements (if any) are not met\n\t            if (  _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRootSP )  ) {\n\t            \treturn;\n\t            }\n\t        }\n\n\t\t\tSuper::receiveInteraction( theInteraction, theParameters, theTag );\n\t\t}\n\t}\n};\n\n#endif\n\n",
    "federate.java.ejs": "<%/* group federate;\n\nfederate(\n\tsimname,\n\tmelderpackagename,\n\tclassname,\n\tisnonmapperfed,\n\ttimeconstrained,\n\ttimeregulating,\n\tlookahead,\n\tasynchronousdelivery,\n\tpublishedinteractiondata,\n\tsubscribedinteractiondata,\n\tallinteractiondata,\n\tpublishedobjectdata,\n\tsubscribedobjectdata,\n\tallobjectdata\n) ::= <<\n*/ -%>\n// This code has been generated by the C2W code generator.\n// Do not edit manually!\n\npackage <%= simname %>;\n\nimport hla.rti.EventRetractionHandle;\nimport hla.rti.LogicalTime;\nimport hla.rti.ReceivedInteraction;\n\nimport c2w.hla.C2WInteractionRoot;\nimport c2w.hla.C2WLogger;\nimport c2w.hla.InteractionRoot;\nimport c2w.hla.SubscribedInteractionFilter;\nimport c2w.hla.SynchronizedFederate;\n\n\nimport c2w.hla.*;\n<% if(melderpackagename){ -%>\nimport <%= melderpackagename %>.<%= classname %>;\nimport <%= melderpackagename %>.<%= classname %>RTIFactory;\n<% } -%>\n\npublic class <%= classname %>Base extends <% if(melderpackagename) { %><%= classname %><% }else{ %>SynchronizedFederate<% } %> {\n\n<% if(melderpackagename){ -%>\n\tstatic {\n\t\t<%= classname %>RTIFactory rtiFactory = new <%= classname %>RTIFactory();\n<% /*allinteractiondata:setfactoryvar()*/ -%>\n\t\t<% allinteractiondata.forEach(function(rticlass){ %>\n\t\trtiFactory.set_<%= rticlass.name %>Interface( new <%= rticlass.name %>Melder() );<%});%>\n<% /*allobjectdata:setfactoryvar()*/ -%>\n\t\t<% allobjectdata.forEach(function(rticlass){ %>\n\t\trtiFactory.set_<%= rticlass.name %>Interface( new <%= rticlass.name %>Melder() );<%});%>\t\n\n\t\t<%= classname %>.set<%= classname %>RTIFactory( rtiFactory );\n\t}\n<% } -%>\n\tprivate SubscribedInteractionFilter _subscribedInteractionFilter = new SubscribedInteractionFilter();\n\t\n\t// constructor\n\tpublic <%= classname %>Base( String federation_id, String federate_id ) throws Exception {\n\t\n<% if(isnonmapperfed){ -%>\n\t\tsetLookahead( <%= lookahead %> );\n<% } -%>\n\t\tcreateRTI();\n\t\tjoinFederation( federation_id, federate_id );\n\n<% if(timeconstrained){ -%>\n\t\tenableTimeConstrained();\n<% } %>\n<% if(timeregulating){ -%>\n\t\tenableTimeRegulation( getLookahead() );\n<% } -%>\n<% if(asynchronousdelivery){ -%>\n\t\tenableAsynchronousDelivery();\n<% } -%>\n        // interaction pubsub\n<% /* publishedinteractiondata:pubinter() */ -%>\n        <% publishedinteractiondata.forEach(function(interactiondata){ %>\n        <%= interactiondata.name %>.publish( getRTI() );<%});%>\n<% /* subscribedinteractiondata:subinter() */ -%>\n        <% subscribedinteractiondata.forEach(function(interactiondata){ %>\n        <%= interactiondata.name %>.subscribe( getRTI() );\n        _subscribedInteractionFilter.setFedFilters( \n\t\t\t<%= interactiondata.name %>.get_handle(), \n\t\t\tSubscribedInteractionFilter.OriginFedFilter.<%= interactiondata.originFedFilter() %>, \n\t\t\tSubscribedInteractionFilter.SourceFedFilter.<%= interactiondata.srcFedFilter() %> \n\t\t);<%}); -%>\n\t\t\n\t\t// object pubsub\n<%/* publishedobjectdata:pubobjectdata() */ -%>\n        <% publishedobjectdata.forEach(function(objectdata){ %>\n        \t<% objectdata.publishedAttributeData.forEach(function(a){ %>\n        <%= objectdata.name %>.publish_<%= a.name %>();<%});%>\n        <%= objectdata.name %>.publish( getRTI() );\n        <%}); -%>\n<%/* subscribedobjectdata:subobjectdata() */ -%>\n        <% subscribedobjectdata.forEach(function(objectdata){ %>\n        \t<% objectdata.subscribedAttributeData.forEach(function(a){ %>\n        <%= objectdata.name %>.subscribe_<%= a.name %>();<%});%>\n        <%= objectdata.name %>.subscribe( getRTI() );\n        <%}); -%>\n        }\n        \n       // constructor\n\tpublic <%= classname %>Base(  String[] federationInfo ) throws Exception {\n\n<% if(isnonmapperfed){ -%>\n\t\tsetLookahead( <%= lookahead %> );\n<% } -%>\n\t\tcreateRTI();\n\t\tjoinFederation( federationInfo[ 0 ], federationInfo[ 1 ] );\n\n\t\tString loglevel = null;\n\t\tif(federationInfo.length == 3)\n\t\t\tC2WLogger.init( federationInfo[ 2 ] );\n\t\telse if(federationInfo.length > 3)\n\t\t\tC2WLogger.init( federationInfo[ 2 ], federationInfo[ 3 ] );\t\t\n\t\t\n\t\tif(federationInfo.length == 5)\n\t\t\tloglevel = federationInfo[ 4 ];\n\n<% if(timeconstrained){ -%>\n\t\tenableTimeConstrained();\n<% } -%>\n<% if(timeregulating){ -%>\n\t\tenableTimeRegulation( getLookahead() );\n<% } -%>\n<% if(asynchronousdelivery){ -%>\n\t\tenableAsynchronousDelivery();\n<% } -%>\n\n        // interaction pubsub\n<%/* publishedinteractiondata:pubinter() */ -%>\n<%publishedinteractiondata.forEach(function(interactiondata){ %>\n        <%= interactiondata.name %>.publish( getRTI() );<%}); %>\n<%/* subscribedinteractiondata:subinter() */ -%>\n<%subscribedinteractiondata.forEach(function(interactiondata){ %>\n        <%= interactiondata.name %>.subscribe( getRTI() );\n        _subscribedInteractionFilter.setFedFilters( \n\t\t\t<%= interactiondata.name %>.get_handle(), \n\t\t\tSubscribedInteractionFilter.OriginFedFilter.<%= interactiondata.originFedFilter() %>, \n\t\t\tSubscribedInteractionFilter.SourceFedFilter.<%= interactiondata.srcFedFilter() %> \n\t\t);<%}); -%>\n\t\t// object pubsub\n<%/* publishedobjectdata:pubobjectdata() */ -%>\n        <%publishedobjectdata.forEach(function(objectdata){ %>\n        \t<%objectdata.publishedAttributeData.forEach(function(a){%>\n        <%= objectdata.name %>.publish_<%= a.name %>();<% }); %>\n        <%= objectdata.name %>.publish( getRTI() );\n        <%}); -%>\n<%/* subscribedobjectdata:subobjectdata() */ -%>\n        <%subscribedobjectdata.forEach(function(objectdata){%>\n        \t<%objectdata.subscribedAttributeData.forEach(function(a){%>\n        <%= objectdata.name %>.subscribe_<%= a.name %>();<% }); %>\n        <%= objectdata.name %>.subscribe( getRTI() );\n        <%}); -%>\n\t\t// enable pubsub log\n\t\tif(federationInfo.length  > 2) {\n<%/* publishedinteractiondata:publoginter() */ -%>\n\t\t\t<%publishedinteractiondata.forEach(function(interactiondata){%>\n\t\t\t<%= interactiondata.name %>.enablePublishLog(\n\t\t\t\t\"<%= interactiondata.name %>\",\n\t\t\t\t\"<%= classname %>\",\n\t\t\t\t\"<%= interactiondata.publishedLoglevel %>\",\n\t\t\t\tloglevel);<%}); %>\n<%/* subscribedinteractiondata:subloginter() */ -%>\n\t\t\t<%subscribedinteractiondata.forEach(function(interactiondata){%>\n\t\t\t<%= interactiondata.name %>.enableSubscribeLog(\n\t\t\t\t\"<%= interactiondata.name %>\",\n\t\t\t\t\"<%= classname %>\", \n\t\t\t\t\"<%= interactiondata.subscribedLoglevel %>\", \n\t\t\t\tloglevel);<%}); %>\t\n<%/* publishedobjectdata:pubobjectinter() */ -%>\n\t\t\t<%publishedobjectdata.forEach(function(objectdata){%>\n\t        \t<%objectdata.logPublishedAttributeData.forEach(function(a){%>\n\t        <%= objectdata.name %>.enablePublishLog(\n\t        \t\"<%= objectdata.name %>\",\t\n\t        \t\"<%= a.name %>\",\n\t        \t\"<%= classname %>\",\n\t        \t\"<%= objectdata.publishedLoglevel %>\",\n\t        \tloglevel);<% }); %><%}); %>\n<%/* subscribedobjectdata:subobjectinter() */ -%>\n\t\t\t<%subscribedobjectdata.forEach(function(objectdata){%>\n        \t\t<%objectdata.logSubscribedAttributeData.forEach(function(a){%>\n\t        \t<%= objectdata.name %>.enableSubscribeLog(\n\t        \t\"<%= objectdata.name %>\",\t\n\t        \t\"<%= a.name %>\",\n\t        \t\"<%= classname %>\",\n\t        \t\"<%= objectdata.subscribedLoglevel %>\",\n\t        \tloglevel);<% }); %><%}); %>\n\t\t}\n\t\t\n\t}\n<%/* publishedinteractiondata:create_interaction() */ -%>\n\t<%publishedinteractiondata.forEach(function(interaction_data){%>\n\tpublic <%= interaction_data.name %> create_<%= interaction_data.name %>() {\n\t   <%= interaction_data.name%> interaction = new <%= interaction_data.name %>();\n\t   interaction.set_sourceFed( getFederateId() );\n\t   interaction.set_originFed( getFederateId() );\n\t   return interaction;\n\t}<%}); %>\n<%/* filter_interaction() */ -%>\n\t@Override\n\tpublic void receiveInteraction(\n\t int interactionClass, ReceivedInteraction theInteraction, byte[] userSuppliedTag\n\t) {\n\t\tInteractionRoot interactionRoot = InteractionRoot.create_interaction( interactionClass, theInteraction );\n\t\tif ( interactionRoot instanceof C2WInteractionRoot ) {\n\t\t\t\n\t\t\tC2WInteractionRoot c2wInteractionRoot = (C2WInteractionRoot)interactionRoot;\n\n\t        // Filter interaction if src/origin fed requirements (if any) are not met\n\t        if (  _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRoot )  ) {\n\t        \treturn;\n\t        } \n\t\t}\n\t\t\n\t\tsuper.receiveInteraction( interactionClass, theInteraction, userSuppliedTag );\t\t\t\n\t}\n\n\t@Override\n\tpublic void receiveInteraction(\n\t int interactionClass,\n\t ReceivedInteraction theInteraction,\n\t byte[] userSuppliedTag,\n\t LogicalTime theTime,\n\t EventRetractionHandle retractionHandle\n\t) {\n\t\tInteractionRoot interactionRoot = InteractionRoot.create_interaction( interactionClass, theInteraction, theTime );\n\t\tif ( interactionRoot instanceof C2WInteractionRoot ) {\n\n\t\t\tC2WInteractionRoot c2wInteractionRoot = (C2WInteractionRoot)interactionRoot;\n\n\t        // Filter interaction if src/origin fed requirements (if any) are not met\n\t        if (  _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRoot )  ) {\n\t        \treturn;\n\t        } \n\t\t}\n\n\t\tsuper.receiveInteraction( interactionClass, theInteraction, userSuppliedTag, theTime, retractionHandle );\t\t\t\n\t}\n}\n",
    "federate_ver.cpp.ejs": "#include <string>\n\nstatic const std::string _<%=simname%>_base_version_ = \"<%=version%>\";",
    "federatertifactory.java.ejs": "<% /*federatertifactory( melderpackagename, classname, allinteractiondata, allobjectdata ) ::= <<*/%>\npackage <%= melderpackagename %>;\n\npublic class <%=classname %> {\n\n\t<%/* allinteractiondata:interfacemember() */%>\n\tprivate <%=allinteractiondata.name %>Interface _<%=allinteractiondata.name %>_var;\n\t\n\t<%/*  allobjectdata:interfacemember() */%>\n\tprivate <%=allobjectdata.name %>Interface _<%=allobjectdata.name %>_var;\n\t\n\t<%/*  allinteractiondata:setinterfacemember() */%>\n\tpublic void set_<%= allinteractiondata.name  %>Interface( <%= allinteractiondata.name  %>Interface interface_var ) {\n\t\t_<%= allinteractiondata.name %>_var = interface_var;\n\t}\n\n\t<%/*  allobjectdata:setinterfacemember() */%>\n\tpublic void set_<%= allobjectdata.name  %>Interface( <%= allobjectdata.name  %>Interface interface_var ) {\n\t\t_<%= allobjectdata.name %>_var = interface_var;\n\t}\n\n\t<%/*  allinteractiondata:getinterfacemember() */%>\n\tpublic <%= allinteractiondata.name %>Interface get_<%= allinteractiondata.name %>Interface() {\n\t\treturn _<%= allinteractiondata.name %>_var;\n\t}\n\t\n\t<%/*  allobjectdata:getinterfacemember() */%>\n\tpublic <%= allobjectdata.name %>Interface get_<%= allobjectdata.name %>Interface() {\n\t\treturn _<%= allobjectdata.name %>_var;\n\t}\n}",
    "fedfile.fed.ejs": "<% /*fed(federationname,objects,interactions) ::= << */ %>\n(FED\n  (Federation <%= federationname %>)\n  (FEDversion v1.3)\n  (spaces)\n<% /*object_root(objects)*/ -%>\n  (objects\n    (class ObjectRoot\n      (attribute privilegeToDelete reliable timestamp)\n<% /*rtiprivate_object()*/ -%>\n      (class RTIprivate)\n<% /*manager_object()*/ -%>\n      (class Manager\n<% /*federation_object()*/ -%>\n        (class Federation\n          (attribute FederationName reliable receive)\n          (attribute FederatesInFederation reliable receive)\n          (attribute RTIversion reliable receive)\n          (attribute FEDid reliable receive)\n          (attribute LastSaveName reliable receive)\n          (attribute LastSaveTime reliable receive)\n          (attribute NextSaveName reliable receive)\n          (attribute NextSaveTime reliable receive)\n        )\n<% /*federate_object()*/ -%>\n        (class Federate\n          (attribute FederateHandle reliable receive)\n          (attribute FederateType reliable receive)\n          (attribute FederateHost reliable receive)\n          (attribute RTIversion reliable receive)\n          (attribute FEDid reliable receive)\n          (attribute TimeConstrained reliable receive)\n          (attribute TimeRegulating reliable receive)\n          (attribute AsynchronousDelivery reliable receive)\n          (attribute FederateState reliable receive)\n          (attribute TimeManagerState reliable receive)\n          (attribute FederateTime reliable receive)\n          (attribute Lookahead reliable receive)\n          (attribute LBTS reliable receive)\n          (attribute MinNextEventTime reliable receive)\n          (attribute ROlength reliable receive)\n          (attribute TSOlength reliable receive)\n          (attribute ReflectionsReceived reliable receive)\n          (attribute UpdatesSent reliable receive)\n          (attribute InteractionsReceived reliable receive)\n          (attribute InteractionsSent reliable receive)\n          (attribute ObjectsOwned reliable receive)\n          (attribute ObjectsUpdated reliable receive)\n          (attribute ObjectsReflected reliable receive)\n        )\n      )\n<% objects.forEach(function(object){ %>\n<%- object %><%});%>   ) \n  )\n<% /*interactions_root(interactions) */ -%>\n  (interactions\n    (class InteractionRoot reliable timestamp\n<% /*rtiprivate_interaction()*/ -%>\n      (class RTIprivate reliable timestamp)\n<% /*manager_interaction()*/ -%>\n      (class Manager reliable receive\n<% /*federate_interaction()*/ -%>\n\t\t(class Federate reliable receive\n          (parameter Federate)\n<% /*request_interaction()*/ -%>\n          (class Request reliable receive\n<% /*request_publications_interaction()*/ -%>\n            (class RequestPublications reliable receive)\n<% /*request_subscriptions_interaction()*/ -%>\n            (class RequestSubscriptions reliable receive)\n<% /*request_objects_owned_interaction()*/ -%>\n            (class RequestObjectsOwned reliable receive)\n<% /*request_objects_updated_interaction()*/ -%>\n            (class RequestObjectsUpdated reliable receive)\n<% /*request_objects_reflected_interaction()*/ -%>\n            (class RequestObjectsReflected reliable receive)\n<% /*request_updates_sent_interaction()*/ -%>\n            (class RequestUpdatesSent reliable receive)\n<% /*request_interactions_sent_interaction()*/ -%>\n            (class RequestInteractionsSent reliable receive)\n<% /*request_reflections_received_interaction()*/ -%>\n            (class RequestReflectionsReceived reliable receive)\t\n<% /*request_interactions_received_interaction()*/ -%>\n            (class RequestInteractionsReceived reliable receive)\n<% /*request_object_information_interaction()*/ -%>\n            (class RequestObjectInformation reliable receive\n              (parameter ObjectInstance)\n            )\n          )\n<% /*report_interaction()*/ -%>\n          (class Report reliable receive\n<% /*report_object_publication_interaction()*/ -%>\n            (class ReportObjectPublication reliable receive\n              (parameter NumberOfClasses)\n              (parameter ObjectClass)\n              (parameter AttributeList)\n            )\n<% /*report_object_subscription_interaction()*/ -%>\n            (class ReportObjectSubscription reliable receive\n              (parameter NumberOfClasses)\n              (parameter ObjectClass)\n              (parameter Active)\n              (parameter AttributeList)\n            )\n<% /*report_interaction_publication_interaction()*/ -%>\n            (class ReportInteractionPublication reliable receive\n              (parameter InteractionClassList)\n            )\n<% /*report_interaction_subscription_interaction()*/ -%>\n            (class ReportInteractionSubscription reliable receive\n              (parameter InteractionClassList)\n            )\n<% /*report_objects_owned_interaction()*/ -%>\n            (class ReportObjectsOwned reliable receive\n              (parameter ObjectCounts)\n            )\n<% /*report_objects_updated_interaction()*/ -%>\n            (class ReportObjectsUpdated reliable receive\n              (parameter ObjectCounts)\n            )\n<% /*report_objects_reflected_interaction()*/ -%>\n            (class ReportObjectsReflected reliable receive\n              (parameter ObjectCounts)\n            )\n<% /*report_updates_sent_interaction()*/ -%>\n            (class ReportUpdatesSent reliable receive\n              (parameter TransportationType)\n              (parameter UpdateCounts)\n            )\n<% /*report_reflections_received_interaction()*/ -%>\n            (class ReportReflectionsReceived reliable receive\n              (parameter TransportationType)\n              (parameter ReflectCounts)\n            )\n<% /*report_interactions_sent_interaction()*/ -%>\n            (class ReportInteractionsSent reliable receive\n              (parameter TransportationType)\n              (parameter InteractionCounts)\n            )\n<% /*report_interactions_received_interaction()*/ -%>\n            (class ReportInteractionsReceived reliable receive\n              (parameter TransportationType)\n              (parameter InteractionCounts)\n            )\n<% /*report_object_information_interaction()*/ -%>\n            (class ReportObjectInformation reliable receive\n              (parameter ObjectInstance)\n              (parameter OwnedAttributeList)\n              (parameter RegisteredClass)\n              (parameter KnownClass)\n            )\n<% /*alert_interaction()*/ -%>\n            (class Alert reliable receive\n              (parameter AlertSeverity)\n              (parameter AlertDescription)\n              (parameter AlertID)\n            )\n<% /*report_service_invocation_interaction()*/ -%>\n            (class ReportServiceInvocation reliable receive\n              (parameter Service)\n              (parameter Initiator)\n              (parameter SuccessIndicator)\n              (parameter SuppliedArgument1)\n              (parameter SuppliedArgument2)\n              (parameter SuppliedArgument3)\n              (parameter SuppliedArgument4)\n              (parameter SuppliedArgument5)\n              (parameter ReturnedArgument)\n              (parameter ExceptionDescription)\n              (parameter ExceptionID)\n            )\n          )\n<% /*adjust_interaction()*/ -%>\n          (class Adjust reliable receive\n<% /*set_timing_interaction()*/ -%>\n            (class SetTiming reliable receive\n              (parameter ReportPeriod)\n            )\n<% /*modify_attribute_state_interaction()*/ -%>\n            (class ModifyAttributeState reliable receive\n              (parameter ObjectInstance)\n              (parameter Attribute)\n              (parameter AttributeState)\n            )\n<% /*set_service_reporting_interaction()*/ -%>\n            (class SetServiceReporting reliable receive\n              (parameter ReportingState)\n            )\n<% /*set_exception_logging_interaction()*/ -%>\n            (class SetExceptionLogging reliable receive\n              (parameter LoggingState)\n            )\n          )\n<% /*service_interaction()*/ -%>\n          (class Service reliable receive\n<% /*resign_federation_execution_interaction()*/ -%>\n          (class ResignFederationExecution reliable receive\n            (parameter ResignAction)\n          )\n<% /*synchronization_point_achieved_interaction()*/ -%>\n          (class SynchronizationPointAchieved reliable receive\n            (parameter Label)\n          )\n<% /*federate_save_begun_interaction()*/ -%>\n          (class FederateSaveBegun reliable receive)\n<% /*federate_save_complete_interaction()*/ -%>\n          (class FederateSaveComplete reliable receive\n            (parameter SuccessIndicator)\n          )\n<% /*federate_restore_complete_interaction()*/ -%>\n          (class FederateRestoreComplete reliable receive\n            (parameter SuccessIndicator)\n          )\n<% /*publish_object_class_interaction()*/ -%>\n          (class PublishObjectClass reliable receive\n            (parameter ObjectClass)\n            (parameter AttributeList)\n          )\n<% /*unpublish_object_class_interaction()*/ -%>\n          (class UnpublishObjectClass reliable receive\n            (parameter ObjectClass)\n          )\n<% /*publish_interaction_class_interaction()*/ -%>\n          (class PublishInteractionClass reliable receive\n            (parameter InteractionClass)\n          )\n<% /*unpublish_interaction_class_interaction()*/ -%>\n          (class UnpublishInteractionClass reliable receive\n            (parameter InteractionClass)\n          )\n<% /*subscribe_object_class_attributes_interaction()*/ -%>\n          (class SubscribeObjectClassAttributes reliable receive\n            (parameter ObjectClass)\n            (parameter AttributeList)\n            (parameter Active)\n          )\n<% /*unsubscribe_object_class_interaction()*/ -%>\n          (class UnsubscribeObjectClass reliable receive\n            (parameter ObjectClass)\n          )\n<% /*subscribe_interaction_class_interaction()*/ -%>\n          (class SubscribeInteractionClass reliable receive\n            (parameter InteractionClass)\n            (parameter Active)\n          )\n<% /*unsubscribe_interaction_class_interaction()*/ -%>\n          (class UnsubscribeInteractionClass reliable receive\n            (parameter InteractionClass)\n          )\n<% /*delete_object_instance_interaction()*/ -%>\n          (class DeleteObjectInstance reliable receive\n            (parameter ObjectInstance)\n            (parameter Tag)\n            (parameter FederationTime)\n          )\n<% /*local_delete_object_instance_interaction()*/ -%>\n          (class LocalDeleteObjectInstance reliable receive\n            (parameter ObjectInstance)\n          )\n<% /*change_attribute_transportation_type_interaction()*/ -%>\n          (class ChangeAttributeTransportationType reliable receive\n            (parameter ObjectInstance)\n            (parameter AttributeList)\n            (parameter TransportationType)\n          )\n<% /*change_attribute_order_type_interaction()*/ -%>\n          (class ChangeAttributeOrderType reliable receive\n            (parameter ObjectInstance)\n            (parameter AttributeList)\n            (parameter OrderingType)\n          )\n<% /*change_interaction_transportation_type_interaction()*/ -%>\n          (class ChangeInteractionTransportationType reliable receive\n            (parameter InteractionClass)\n            (parameter TransportationType)\n          )\n<% /*change_interaction_order_type_interaction()*/ -%>\n          (class ChangeInteractionOrderType reliable receive\n            (parameter InteractionClass)\n            (parameter OrderingType)\n          )\n<% /*unconditional_attribute_ownership_divestiture_interaction()*/ -%>\n          (class UnconditionalAttributeOwnershipDivestiture reliable receive\n            (parameter ObjectInstance)\n            (parameter AttributeList)\n          )\n<% /*enable_time_regulation_interaction()*/ -%>\n          (class EnableTimeRegulation reliable receive\n            (parameter FederationTime)\n            (parameter Lookahead)\n          )\n<% /*disable_time_regulation_interaction()*/ -%>\n          (class DisableTimeRegulation reliable receive)\n<% /*enable_time_constrained_interaction()*/ -%>\n          (class EnableTimeConstrained reliable receive)\n<% /*disable_time_constrained_interaction()*/ -%>\n          (class DisableTimeConstrained reliable receive)\n<% /*enable_asynchronous_delivery_interaction()*/ -%>\n          (class EnableAsynchronousDelivery reliable receive)\n<% /*disable_asynchronous_delivery_interaction()*/ -%>\n          (class DisableAsynchronousDelivery reliable receive)\n<% /*modify_lookahead_interaction()*/ -%>\n          (class ModifyLookahead reliable receive\n            (parameter Lookahead)\n          )\n<% /*time_advance_request_interaction()*/ -%>\n          (class TimeAdvanceRequest reliable receive\n            (parameter FederationTime)\n          )\n<% /*time_advance_request_available_interaction()*/ -%>\n          (class TimeAdvanceRequestAvailable reliable receive\n            (parameter FederationTime)\n          )\n<% /*next_event_request_interaction()*/ -%>\n          (class NextEventRequest reliable receive\n            (parameter FederationTime)\n          )\n<% /*next_event_request_available_interaction()*/ -%>\n          (class NextEventRequestAvailable reliable receive\n            (parameter FederationTime)\n          )\n<% /*flush_queue_request_interaction()*/ -%>\n          (class FlushQueueRequest reliable receive\n            (parameter FederationTime)\n          )\n          )\n        )\n      )\n<% interactions.forEach(function(interaction){ %>\n<%- interaction %><%});%>  \n    )\n  )\n)\n",
    "fedfile_siminteraction.ejs": "<% /*siminteraction(interaction,parameters,children) */ -%>\n(class <%= interaction.name %> <%= interaction.delivery %> <%= interaction.order %> <%if(!parameters && !children){%>)<%}else{%>\n<% parameters.forEach(function(param){ %>  (parameter <%= param.name %>)\n<% }); -%>\n<% children.forEach(function(child){ %><%= child %>\n<% }); -%>\n)<% } %>",
    "fedfile_simobject.ejs": "<% /*simobject(name,attributes,children) */ -%>\n(class <%= name %><% for(var i=0; i<attributes.length; i++){ %>\n  (attribute <%= attributes[i].name %> <%= attributes[i].delivery %> <%= attributes[i].order %>)<% } -%>\n<% children.forEach(function(child){ %>  <%= child %>\n<% }); -%> \n)",
    "interfacecommon.java.ejs": "<% /*interfacecommon(isinteraction,classname,parentclassname,hlaclassname,datamembers,alldatamembers) */ %>\n\n/**\n* Returns the handle (RTI assigned) of this instance's <%=isinteraction?\"interaction\":\"object\"%> class .\n* \n* @return the handle (RTI assigned) if this instance's <%=isinteraction?\"interaction\":\"object\"%> class\n*/\npublic int getClassHandle();\n\n/**\n* Returns the fully-qualified (dot-delimited) name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class.\n* \n* @return the fully-qualified (dot-delimited) name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class\n*/\npublic String getClassName();\n\n/**\n* Returns the simple name (last name in its fully-qualified dot-delimited name)\n* of this instance's <%=isinteraction?\"interaction\":\"object\"%> class.\n* \n* @return the simple name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class \n*/\npublic String getSimpleClassName();\n\n/**\n* Returns a set containing the names of all of the non-hidden<%=isinteraction?\"parameter\":\"attribute\"%>s of an\n* <%=isinteraction?\"interaction\":\"object\"%> class instance.\n*\n* @return set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\n* <%=isinteraction?\"interaction\":\"object\"%> class instance\n*/\npublic Set< String > get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names();\n\n/**\n* Returns a set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\n* <%=isinteraction?\"interaction\":\"object\"%> class instance.\n*\n* @return set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\n* <%=isinteraction?\"interaction\":\"object\"%> class instance\n*/\npublic Set< String > getAll<%=isinteraction?\"Parameter\":\"Attribute\"%>Names();\n\n/**\n* Publishes the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of the class for a federate.\n*\n* @param rti handle to the RTI, usu. obtained through the\n* {@link SynchronizedFederate#getRTI()} call\n*/\npublic void publish<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti );\n\n/**\n* Unpublishes the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class for a federate.\n*\n* @param rti handle to the RTI, usu. obtained through the\n* {@link SynchronizedFederate#getRTI()} call\n*/\npublic void unpublish<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti );\n\n/**\n* Subscribes a federate to the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class.\n*\n* @param rti handle to the RTI, usu. obtained through the\n* {@link SynchronizedFederate#getRTI()} call\n*/\npublic void subscribe<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti );\n\n/**\n* Unsubscribes a federate from the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class.\n*\n* @param rti handle to the RTI, usu. obtained through the\n* {@link SynchronizedFederate#getRTI()} call\n*/\npublic void unsubscribe<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti );\n\n<% if(isinteraction){ %><% }else{ %>\n/**\n* Returns a data structure containing the handles of all attributes for this object\n* class that are currently marked for subscription.  To actually subscribe to these\n* attributes, a federate must call <objectclassname>.subscribe( RTIambassador rti ).\n*\n* @return data structure containing the handles of all attributes for this object\n* class that are currently marked for subscription\n*/\npublic AttributeHandleSet getSubscribedAttributeHandleSet();\n<%}%>",
    "interfaceroot.java.ejs": "<% /* classrootinterface(isinteraction)*/ %>\npackage c2w.hla;\n\nimport java.util.*;\nimport hla.rti.*;\n\npublic interface <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface\n{\n    public int getUniqueID();\n\n    <%-ejs.render(\n        TEMPLATES[\"interfacecommon.java.ejs\"],{\n            isinteraction: isinteraction,\n            classname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\n            parentclassname: \"\",\n            hlaclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\n            datamembers: [],\n            alldatamembers: []\n    })%>\n\n    \n<% if(isinteraction){ %><%}else{%>\n    /**\n    * Requests an attribute update for this object instance from the federate that\n    * has modification rights on these attributes.\n    *\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    */\n    public void requestUpdate( RTIambassador rti );\n\n    /**\n    * Returns the handle (RTI assigned) the corresponds to this object class\n    * instance.  This handle is the instance's unique identifier to the RTI.\n    *\n    * @return the handle (RTI assigned) of this object class instance.\n    */\n    public int getObjectHandle();\n<%}%>\n\n    /**\n    * Returns the timestamp for this <%=isinteraction?\"interaction\":\"object\"%>.  \"receive order\" <%=isinteraction?\"interaction\":\"object\"%>s\n    * should have a timestamp of -1.\n    *\n    * @return timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\n    */\n    public double getTime();\n    \n    /**\n    * Sets the timestamp of this <%=isinteraction?\"interaction\":\"object\"%> to \"time\".\n    *\n    * @param time new timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\n    */\n    public void setTime( double time );\n\n    /**\n    * Sets the timestamp of this <%=isinteraction?\"interaction\":\"object\"%> to \"logicalTime\".\n    *\n    * @param logicalTime new timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\n    */\n    public void setTime( LogicalTime logicalTime );\n\n    /**\n    * Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" for this\n    * <%=isinteraction?\"interaction\":\"object\"%>.\n    *\n    * @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value to retrieve\n    * @return the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose name is \"datamemberName\"\n    */\n    public Object get<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName );\n\n    /**\n    * Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose handle is \"datamemberHandle\"\n    * (RTI assigned) for this <%=isinteraction?\"interaction\":\"object\"%>.\n    *\n    * @param datamemberHandle handle (RTI assigned) of <%=isinteraction?\"parameter\":\"attribute\"%> whose\n    * value to retrieve\n    * @return the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose handle is \"datamemberHandle\"\n    */\n    public Object get<%=isinteraction?\"Parameter\":\"Attribute\"%>( int datamemberHandle );\n        \n    /**\n    * Set the values of the <%=isinteraction?\"parameter\":\"attribute\"%>s in this <%=isinteraction?\"interaction\":\"object\"%> using\n    * \"datamemberMap\".  \"datamemberMap\" is usually acquired as an argument to\n    * an RTI federate callback method such as \"receiveInteraction\".\n    *\n    * @param datamemberMap  contains new values for the <%=isinteraction?\"parameter\":\"attribute\"%>s of\n    * this <%=isinteraction?\"interaction\":\"object\"%>\n    */\n    public void set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap );\n\n    /**\n    * Sets the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" to \"value\"\n    * in this <%=isinteraction?\"interaction\":\"object\"%>.  \"value\" is converted to data type of \"datamemberName\"\n    * if needed.\n    * This action can also be affected by calling the set_<datamemberName>( value )\n    * method on the <%=isinteraction?\"interaction\":\"object\"%> using a reference to the <%=isinteraction?\"interaction\":\"object\"%>'s actual\n    * class.\n    *\n    * @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be set\n    * to \"value\"\n    * @param value new value of <%=isinteraction?\"parameter\":\"attribute\"%> called \"datamemberName\"\n    */\n    public void set<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName, String value );\n\n    /**\n    * Sets the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" to \"value\"\n    * in this <%=isinteraction?\"interaction\":\"object\"%>.  \"value\" should have the same data type as that of\n    * the \"datamemberName\" <%=isinteraction?\"parameter\":\"attribute\"%>.\n    * This action can also be affected by calling the set_<datamemberName>( value )\n    * method on the <%=isinteraction?\"interaction\":\"object\"%> using a reference to the <%=isinteraction?\"interaction\":\"object\"%>'s actual\n    * class.\n    *\n    * @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be set\n    * to \"value\"\n    * @param value new value of <%=isinteraction?\"parameter\":\"attribute\"%> called \"datamemberName\"\n    */\n    public void set<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName, Object value );\n\n<% if(isinteraction){ %>\n    /**\n    * Sends this interaction to the RTI, with the specified timestamp \"time\".\n    * This method should be used to send interactions that have \"timestamp\"\n    * ordering.\n    *\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    * @param time timestamp for this interaction.  The timestamp should be no\n    * less than the current federation time + the LOOKAHEAD value of the federate\n    * sending this interaction.\n    */\n    public void sendInteraction( RTIambassador rti, double time ) throws Exception;\n\n    /**\n    * Sends this interaction to the RTI (without a timestamp).\n    * This method should be used to send interactions that have \"receive\"\n    * ordering.\n    *\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    */\n    public void sendInteraction( RTIambassador rti ) throws Exception ;\n<%}else{%>\n    /**\n    * Registers this object with the RTI.  This method is usually called by a\n    * federate who \"owns\" this object, i.e. the federate that created it and\n    * has write-privileges to its attributes (so, it is responsible for updating\n    * these attribute and conveying their updated values to the RTI).\n    *\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    */ \n    public void registerObject( RTIambassador rti );\n    \n    /**\n    * Unregisters this object with the RTI.  The RTI will destroy all information\n    * it contains regarding this object as a result.  This method is usually\n    * called by a federate who \"owns\" this object, i.e. the federate that created\n    * it and has write-privileges to its attributes.\n    *\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    */ \n    public void unregisterObject( RTIambassador rti );\n\n    /**\n    * Broadcasts the attributes of this object and their values to the RTI, where\n    * the values have \"time\" as their timestamp.  This call should be used for\n    * objects whose attributes have \"timestamp\" ordering.\n    *\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    * @param time timestamp on attribute values of this object\n    * @param force if \"false\", only the attributes whose values have changed since\n    * the last call to \"updateAttributeValues\" will be broadcast to the RTI.  If\n    * \"true\", all attributes and their values are broadcast to the RTI.\n    */\n    public void updateAttributeValues( RTIambassador rti, double time, boolean force );\n\n    /**\n    * Like {@link #updateAttributeValues( RTIambassador rti, double time, boolean force )},\n    * except \"force\" is always false.\n    *\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    * @param time timestamp on attribute values of this object\n    */\n    public void updateAttributeValues( RTIambassador rti, double time );\n\n    /**\n    * Broadcasts the attributes of this object and their values to the RTI (with\n    * no timestamp).  This call should be used for objects whose attributes have\n    * \"receive\" ordering.\n    *\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    * @param force if \"false\", only the attributes whose values have changed since\n    * the last call to \"updateAttributeValues\" will be broadcast to the RTI.  If\n    * \"true\", all attributes and their values are broadcast to the RTI.\n    */\n    public void updateAttributeValues( RTIambassador rti, boolean force );\n\n    /**\n    * Like {@link #updateAttributeValues( RTIambassador rti, boolean force )},\n    * except \"force\" is always false.\n    *\n    * @param rti handle to the RTI, usu. obtained through the\n    * {@link SynchronizedFederate#getRTI()} call\n    */\n    public void updateAttributeValues( RTIambassador rti );    \n<%}%>    \n}",
    "mapperfederate.java.ejs": "<% /*group mapperfederate;\n\nmapperfederate(\n    classname,\n\tsimname,\n\tstep_size,\n\tmappingconnsdata,\n\tmappingobjectsdata\n) ::= <<*/ -%>\n// This code has been generated by the C2W code generator.\n// Do not edit manually!\n\npackage <%=simname%>;\n\nimport java.util.StringTokenizer;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport hla.rti.EventRetractionHandle;\nimport hla.rti.LogicalTime;\nimport hla.rti.ReceivedInteraction;\nimport c2w.hla.*;\n\npublic class <%=classname%> extends <%=classname%>Base {\n\n    private static Pattern pattern = Pattern.compile( \"[^#]\" );\n\n\tpublic <%=classname%>(String federationId, String federateId)\n\t\t\tthrows Exception {\n\t\tsuper(federationId, federateId);\n\t}\n\n    public <%=classname%>( String[] args ) throws Exception {\n        super( args );\n    }\n    \n    private static double STEP_EPSILON = 0.000001;\n    \n    public boolean isMapperFederate() {\n        return true;\n    }\n\n    <% /*mappingconnsdata:mappingconnections()*/ %>\n    <% mappingconnsdata.forEach(function(mappingconnectiondata){ %>\n\t///////////////////////////////////////////////////////////////////////////////////////\n\t//\n\t// For <% if(mappingconnectiondata.isSimpleConn){ %>Simple<% }else{ %>Complex<% } %>MappingConnection (ID: <%=mappingconnectiondata.uniqueId%>) between interactions:\n\t//\n\t//         <%=mappingconnectiondata.lHSInteractionName%> --to--> <%=mappingconnectiondata.rHSInteractionName%>\n\t//\n\t// This <% if(mappingconnectiondata.isSimpleConn){ %>Simple<% }else{ %>Complex<% } %>MappingConnection is located at:\n\t//\n\t//         <%=mappingconnectiondata.parentPath%>\n\t//\n\t///////////////////////////////////////////////////////////////////////////////////////\n\tpublic boolean isGuardConditionMet_<%=mappingconnectiondata.lHSInteractionName%>_to_<%=mappingconnectiondata.rHSInteractionName%>_<%=mappingconnectiondata.uniqueId%>(<%=mappingconnectiondata.lHSInteractionName%> i1) {\n\t\t<%-mappingconnectiondata.guardCondition%>\n\t\t<% if(mappingconnectiondata.guardConditionInvalid){ %>return true;<% } %>\n\t}\n\n\n\tpublic <%=mappingconnectiondata.rHSInteractionName%> map_<%=mappingconnectiondata.lHSInteractionName%>_to_<%=mappingconnectiondata.rHSInteractionName%>_<%=mappingconnectiondata.uniqueId%>(<%=mappingconnectiondata.lHSInteractionName%> i1) {\n\t\t<%=mappingconnectiondata.rHSInteractionName%> o1 = create_<%=mappingconnectiondata.rHSInteractionName%>();\n\t\tInteractionRoot o1IR = (InteractionRoot) o1;\n\t    <% if(mappingconnectiondata.isMappedInteractionANetworkPacket){ %>\n\t\tboolean __NETWORK_PACKET_CORRUPT__ = false;\n\t\tInteractionRoot __I1__ = (InteractionRoot) i1;\n\t\tif(__I1__ instanceof NetworkPacket ) {\n\t    \tint numParams = o1.getParameterNames().size();\n\t    \tString __DATA__ = ((NetworkPacket) __I1__).get_data();\n\t    \tif(numParams > 0) {\n\t\t\t    Matcher matcher = pattern.matcher( __DATA__ );\n\t\t\t    if ( !matcher.find() ) {\n\t    \t\t\t__NETWORK_PACKET_CORRUPT__ = true;\n\t    \t\t\tif(o1IR instanceof NetworkPacket && __DATA__.length() == 0 ) {\n\t\t\t    \t\t__NETWORK_PACKET_CORRUPT__ = false;\n\t\t\t    \t}\n\t    \t\t}\n\t    \t} else {\n\t    \t\tif(__DATA__.length() > 0) {\n\t    \t\t\t__NETWORK_PACKET_CORRUPT__ = true;\n\t    \t\t}\n\t    \t}\n\t\t}\n\t\tif(!__NETWORK_PACKET_CORRUPT__) {\n\t\t    <% if(mappingconnectiondata.isMappingSpecsNotEmpty){ %>\n\t\t\t<%-mappingconnectiondata.mappingSpecs%><%}%>\n\t\t}\n\t\t<% }else{ %>\n\t    <% if(mappingconnectiondata.isMappingSpecsNotEmpty){ %>\n\t\t<%-mappingconnectiondata.mappingSpecs%><%}%>\n\t\t<%}%>\n\n\t\to1.set_originFed(i1.get_originFed());\n\t\to1.set_actualLogicalGenerationTime(i1.get_actualLogicalGenerationTime());\n\n\t\treturn o1;\n\t}\n    <%/*EMPTY*/});%>\n    \n    <% /*mappingobjectsdata:mappingobjects()*/ %>\n    <% mappingobjectsdata.forEach(function(mappingobjectdata){ %><%/*EMPTY*/});%>\n    \n\n\t<% /*execute_method()*/ %>\n\tpublic void execute() throws Exception {\n\t    double currentTime = 0;\n\n\t    AdvanceTimeRequest atr = new AdvanceTimeRequest( currentTime );\n\t    putAdvanceTimeRequest( atr );\n\n\t    readyToPopulate();\n\t    readyToRun();\n\n\t    startAdvanceTimeThread(TIME_ADVANCE_MODE.NEXT_EVENT_REQUEST_AVAILABLE);\n\n\t    while( true ) {\n\t    \tSystem.out.print( \"<%=classname%>: Requesting RTI to proceed to (\" + currentTime + \")...\" );\n\t    \t\n\t        atr.requestSyncStart();\n\t        currentTime = atr.getCurrentTime();\n\n\t        System.out.println( \"granted!\" );\n\n\t        InteractionRoot interactionRoot;\n\n\t        System.out.println(\"Now waiting to receive an interaction...\");\n\t        while(  ( interactionRoot = getNextInteractionNoWait() ) != null ) {\n\t            \t\n\t\t\t\tSystem.out.println( \"<%=classname%>: received interaction: \\\"\" + interactionRoot + \"\\\" at time: \" + getCurrentTime() );\n\n\t\t\t\tboolean interactionMapped = false;\t\t\t\n\t\t\t\t<% /*mappingconnsdata:mappingCheck()*/ %>\n\t\t\t\t<% mappingconnsdata.forEach(function(mappingconnectiondata){%>\n\t\t\t\tif( interactionRoot instanceof <%=mappingconnectiondata.lHSInteractionName%> ) {\n\t\t\t\t\t<%=mappingconnectiondata.lHSInteractionName%> i1 = (<%=mappingconnectiondata.lHSInteractionName%>) interactionRoot;\n\t\t\t\t\t\n\t\t\t\t\t\tif(  !(interactionRoot instanceof NetworkPacket) || \"<%=mappingconnectiondata.rHSInteractionName%>\".equals(((NetworkPacket) interactionRoot).get_packetType())  ) {\n\t\n\t\t\t\t\t\t\tif( isGuardConditionMet_<%=mappingconnectiondata.lHSInteractionName%>_to_<%=mappingconnectiondata.rHSInteractionName%>_<%=mappingconnectiondata.uniqueId%>(i1) ) {\n\t\t\t\t\t\t\t\t<%=mappingconnectiondata.rHSInteractionName%> o1 = map_<%=mappingconnectiondata.lHSInteractionName%>_to_<%=mappingconnectiondata.rHSInteractionName%>_<%=mappingconnectiondata.uniqueId%>(i1);\n\t\t\t\t\t\t\t\tSystem.out.println( \"<%=classname%>: Sending interaction: \" + o1 );\n\t\t\t\t\t\t\t\to1.sendInteraction( getRTI(), getMinTSOTimestamp() );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tinteractionMapped = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t<% if(mappingconnectiondata.areBothEndsOfMappingANetworkPacket){ %>\n\t\t\t\t\t\t// Or, if it is a mapping from an interaction type to itself then only check the guard condition\n\t\t\t\t\t\tif ( interactionRoot instanceof NetworkPacket && \"<%=mappingconnectiondata.lHSInteractionName%>\".equals(\"<%=mappingconnectiondata.rHSInteractionName%>\") ) {\n\t\t\t\t\t\t\tif( isGuardConditionMet_NetworkPacket_to_NetworkPacket_<%=mappingconnectiondata.uniqueId%>(i1) ) {\n\t\t\t\t\t\t\t\tNetworkPacket o1 = map_NetworkPacket_to_NetworkPacket_<%=mappingconnectiondata.uniqueId%>(i1);\n\t\t\t\t\t\t\t\tSystem.out.println( \"<%=classname%>: Sending interaction: \" + o1 );\n\t\t\t\t\t\t\t\to1.sendInteraction( getRTI(), getMinTSOTimestamp() );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tinteractionMapped = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t<% } %>\n\t\t\t\t}<%});%>\n\n\t\t\t\tif( !interactionMapped ) {\n\t          \t\tSystem.out.println( \"<%=classname%>: Received unknown interaction: \" + interactionRoot );\n\t           \t}\n\t        }\n\n\t        currentTime = getCurrentTime() + <%=step_size%> + STEP_EPSILON;\n\t        AdvanceTimeRequest newATR = new AdvanceTimeRequest( currentTime );\n\t        putAdvanceTimeRequest( newATR );\n\t        \n\t        atr.requestSyncEnd();\n\t        atr = newATR;\n\t    }\n\t}\n\n\t<% /*main_method()*/ %>\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t    System.out.println( \"<%=classname%> federate starting\" );\n\t    try {\n\t    \t<%=classname%> mapperFed = new <%=classname%>( args );\n\t        mapperFed.execute();\n\t    } catch ( Exception e ) {\n\t        System.err.println( \"Exception caught: \" + e.getMessage() );\n\t        e.printStackTrace();\n\t    }\n\t}\n\n}\n",
    "omnetfilter.cpp.ejs": "<% /*FilterInitSource( projectname, subscribedinteractiondata ) ::= << */ %>\n/*\n * Copyright (c) 2016, Institute for Software Integrated Systems, Vanderbilt University\n * All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose, without fee, and without written agreement is\n * hereby granted, provided that the above copyright notice, the following\n * two paragraphs and the author appear in all copies of this software.\n *\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * @author Himanshu Neema\n */\n\n#include \"<%=projectname%>FilterInit.h\"\n#include \"OmnetFOMInteractions.h\"\n#include \"<%=projectname%>NonOmnetNonGenericSources.hpp\"\n\nvoid <%=projectname%>FilterInit::execute( SubscribedInteractionFilter &subscribedInteractionFilter ) {\n\t<% /*subscribedinteractiondata:initInteractionFilter()*/ %>\n\t<% subscribedinteractiondata.forEach(function(subscribedinteractiondata){%>\n\tsubscribedInteractionFilter.setFedFilters( <%=subscribedinteractiondata.name%>::get_handle(), SubscribedInteractionFilter::<%=subscribedinteractiondata.originFedFilter()%>, SubscribedInteractionFilter::<%=subscribedinteractiondata.srcFedFilter()%> );<%});%>\n\n}\n\nstatic bool init( void ) {\n    SubscribedInteractionFilter::get_singleton().setFilterInit( <%=projectname%>FilterInit::create() );\n    return true;\n}\n\nstatic bool static_init = init();\n\n\n",
    "omnetfilter.hpp.ejs": "<% /* FilterInitHeader( projectname, subscribedinteractiondata ) ::= << */ %>\n/*\n * Copyright (c) 2016, Institute for Software Integrated Systems, Vanderbilt University\n * All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software and its\n * documentation for any purpose, without fee, and without written agreement is\n * hereby granted, provided that the above copyright notice, the following\n * two paragraphs and the author appear in all copies of this software.\n *\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n *\n * @author Himanshu Neema\n */\n#ifndef _ISIS_<%=projectname%>_H_\n#define _ISIS_<%=projectname%>_H_\n\n#include \"SubscribedInteractionFilter.hpp\"\n\nstruct <%=projectname%>FilterInit : public SubscribedInteractionFilter::FilterInit {\n    static SP create( void ) { return SP( new <%=projectname%>FilterInit() ); }\n\n    virtual void execute( SubscribedInteractionFilter &subscribedInteractionFilter );\n};\n\n#endif\n"
}});