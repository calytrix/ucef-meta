//jshint ignore: start
/* Generated file based on ejs templates */
define([], function() {
    return {
    "cpp/class.cpp.ejs": "<% /*class(isinteraction,simname,classname,parentclassname,hlaclassname,datamembers,alldatamembers,isc2winteractionroot) ::= <<*/ -%>\r\n// This file was generated by the WebGME Federates Exporter plugin. Do not edit manually!\r\n\r\n#include \"<%=classname%>.hpp\"\r\n\r\n<% /*classcommon(...)*/ -%>\r\n<%- ejs.render(TEMPLATES[\"cpp/classcommon.cpp.ejs\"], {\r\n\t\tisinteraction: isinteraction,\r\n\t\tclassname: classname,\r\n\t\tparentclassname: parentclassname,\r\n\t\thlaclassname: hlaclassname,\r\n\t\tdatamembers: datamembers,\r\n\t\talldatamembers: alldatamembers\r\n}) -%>\r\n<% if(isc2winteractionroot){ -%>\r\n\r\nvoid C2WInteractionRoot::sendInteraction( RTI::RTIambassador *rti, double time ) {\r\n\tif ( get_sourceFed().empty() || get_originFed().empty() ) {\r\n\t\tthrow C2WException( \"C2WInteractionRoot::sendInteraction:  source and/or origin federate not specified.\" );\r\n\t}\r\n\tSuper::sendInteraction( rti, time );\r\n}\r\n\r\nvoid C2WInteractionRoot::sendInteraction( RTI::RTIambassador *rti ) {\r\n\tif ( get_sourceFed().empty() || get_originFed().empty() ) {\r\n\t\tthrow C2WException( \"C2WInteractionRoot::sendInteraction:  source and/or origin federate not specified.\" );\r\n\t}\r\n\tSuper::sendInteraction( rti );\r\n}\r\n<% } -%>\r\n<% if(!isinteraction){ -%>\r\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\r\n\r\n<%=classname%>::AttributeHandleValuePairSetSP <%=classname%>::createDatamemberHandleValuePairSet( bool force ) {\r\n\tAttributeHandleValuePairSetSP datamembers = AttributeHandleValuePairSetSP(RTI::AttributeSetFactory::create(<%=alldatamembers.length%>));\r\n\tstd::string stringConversion;\r\n\tbool isPublished;\r\n\r\n<% /*alldatamembers:{ d |<supplied_attribute(classname=classname,datamember=d)>}*/ -%>\r\n<% alldatamembers.forEach(function(datamember){ -%>\r\n\tisPublished = (m_publishedAttributeNames.find(\"<%=datamember.name%>\") != m_publishedAttributeNames.end());\r\n\tif (  isPublished && _<%=datamember.name%>.shouldBeUpdated( force )  ) {\r\n\t\tstringConversion = static_cast< std::string >(  TypeMedley( get_<%=datamember.name%>() )  );\r\n\t\tdatamembers->add( get_<%=datamember.name%>_handle(), stringConversion.c_str(), stringConversion.size() );\r\n\t\t_<%=datamember.name%>.setHasBeenUpdated();\r\n\t}\r\n\r\n<% }); -%>\r\n\treturn datamembers;\r\n}\r\n\r\nboost::unordered_set< std::string > <%=classname%>::m_publishedAttributeNames;\r\n<% } -%>\r\n<% } -%>\r\n",
    "cpp/class.hpp.ejs": "<% /*class(isinteraction,simname,classname,parentclassname,hlaclassname,datamembers,alldatamembers,isc2winteractionroot) ::= << */ -%>\r\n// This file was generated by the WebGME Federates Exporter plugin. Do not edit manually!\r\n\r\n/*\r\n * Copyright (c) 2008, Institute for Software Integrated Systems, Vanderbilt University\r\n * All rights reserved.\r\n *\r\n * Permission to use, copy, modify, and distribute this software and its\r\n * documentation for any purpose, without fee, and without written agreement is\r\n * hereby granted, provided that the above copyright notice, the following\r\n * two paragraphs and the author appear in all copies of this software.\r\n *\r\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\r\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\r\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\r\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\r\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\r\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\r\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\r\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\r\n *\r\n */\r\n\r\n/*\r\n * \tNOTE:  ALL \"if\" STATEMENTS IN THIS CODE THAT HAD THE FORM:\r\n *\r\n *  if (condition) statement;\r\n *\r\n *\tOR\r\n *\r\n *  if (condition) statement1;\r\n *  else           statement2;\r\n *\r\n *  HAVE BEEN CONVERTED TO THE FORMS:\r\n *\r\n *  if (condition) {\r\n *\t\tstatement;\r\n *\t}\r\n *\r\n *\tAND\r\n *\r\n *  if (condition) {\r\n *\t\tstatement1;\r\n *\t} else {\r\n *\t\tstatement2;\r\n *\t}\r\n *\r\n *\tRESPECTIVELY.  THIS IS BECAUSE THE OMNET DEBUGGER APPEARS TO HAVE A PROBLEM\r\n *  WITH THE NON-BRACED FORMS OF THE IF STATEMENT.  *PLEASE* DO NOT CHANGE IT BACK.\r\n *  -- H.S.N.\r\n *\r\n */\r\n\r\n#ifndef _<%=classname%>_CLASS\r\n#define _<%=classname%>_CLASS\r\n\r\n#include \"<%=parentclassname%>.hpp\"\r\n#include \"C2WException.hpp\"\r\n<% if(!isinteraction){ -%>\r\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\r\n\r\n#include <boost/unordered_set.hpp>\r\n<% }} -%>\r\n\r\nclass <%=classname%> : public <%=parentclassname%> {\r\npublic:\r\n\ttypedef <%=parentclassname%> Super;\r\n\ttypedef boost::shared_ptr< <%=classname%> > SP;\r\n\r\n\tstatic StringVector get_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\r\n\t\treturn getDatamemberNames();\r\n\t}\r\n\r\n\tstatic StringVector get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\r\n\t\treturn getAllDatamemberNames();\r\n\t}\r\n\r\n\t<%=classname%>( void ) { }\r\n\r\n\tstatic SP create( void ) { return SP( new <%=classname%> ); }\r\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\r\n\r\nprivate:\r\n<% if(!isinteraction){ -%>\r\n\tstatic boost::unordered_set< std::string > m_publishedAttributeNames;\r\n\r\n<% } -%>\r\n<% /*alldatamembers:handle()*/ -%>\r\n<% alldatamembers.forEach(function(datamember){ -%>\r\n\tstatic int &get_<%=datamember.name%>_handle_var( void ) {\r\n\t\tstatic int <%=datamember.name%>_handle;\r\n\t\treturn <%=datamember.name%>_handle;\r\n\t}\r\n\r\n<% }); -%>\r\npublic:\r\n<% /*alldatamembers:gethandle()*/ -%>\r\n<% alldatamembers.forEach(function(datamember){ -%>\r\n\tstatic int get_<%=datamember.name%>_handle( void ) { return get_<%=datamember.name%>_handle_var(); }\r\n<% }); -%>\r\n<% } -%>\r\n\r\n<% /*classcommon(...)*/ -%>\r\n<%- ejs.render(TEMPLATES[\"cpp/classcommon.hpp.ejs\"], {\r\n\t\tisinteraction: isinteraction,\r\n\t\tclassname: classname,\r\n\t\tparentclassname: parentclassname,\r\n\t\thlaclassname: hlaclassname,\r\n\t\tdatamembers: datamembers,\r\n\t\talldatamembers: alldatamembers\r\n}) -%>\r\n<% if(isc2winteractionroot){ -%>\r\n\r\npublic:\r\n\tvoid sendInteraction( RTI::RTIambassador *rti, double time );\r\n\tvoid sendInteraction( RTI::RTIambassador *rti );\r\n<% } -%>\r\n<% if(isinteraction){ -%>\r\n<% if(datamembers && datamembers.length > 0){ -%>\r\n\r\nprivate:\r\n<% /*datamembers:interactionmembers()*/ -%>\r\n<% datamembers.forEach(function(datamember){ -%>\r\n\t<%- helpers.cppjavaTypeMap(datamember.parameterType) %> _<%=datamember.name%>;\r\n<% }); -%>\r\n\r\npublic:\r\n<% /*datamembers:interactiongetters()*/ -%>\r\n<% datamembers.forEach(function(datamember){ -%>\r\n\tvoid set_<%=datamember.name%>( <%- helpers.cppjavaArgumentTypeMap(datamember.parameterType) %> <%=datamember.name%> ) { _<%=datamember.name%> = <%=datamember.name%>; }\r\n\r\n\t<%- helpers.cppjavaArgumentTypeMap(datamember.parameterType) %> get_<%=datamember.name%>( void ) const { return _<%=datamember.name%>; }\r\n\r\n<% }); -%>\r\n<% } -%>\r\n<% }else{ -%>\r\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\r\n\r\npublic:\r\n<% alldatamembers.forEach(function(attribute){ -%>\r\n<% /*alldatamembers:{ a |<publish(classname=classname,attribute=a)> }*/ -%>\r\n\tstatic void publish_<%=attribute.name%>( void ) {\r\n\t\tgetPublishAttributeNameVector().push_back( \"<%=attribute.name%>\" );\r\n\t\tm_publishedAttributeNames.emplace( \"<%=attribute.name%>\" );\r\n\t}\r\n\r\n\tstatic void unpublish_<%=attribute.name%>( void ) {\r\n\t\tgetPublishAttributeNameVector().erase( std::remove( getPublishAttributeNameVector().begin(), getPublishAttributeNameVector().end(), \"<%=attribute.name%>\" ), getPublishAttributeNameVector().end() );\r\n\t\tm_publishedAttributeNames.erase( \"<%=attribute.name%>\" );\r\n\t}\r\n\r\n<% /*alldatamembers:{ a |<subscribe(classname=classname,attribute=a)> }*/ -%>\r\n\tstatic void subscribe_<%=attribute.name%>( void ) {\r\n\t\tgetSubscribeAttributeNameVector().push_back( \"<%=attribute.name%>\" );\r\n\t}\r\n\r\n\tstatic void unsubscribe_<%=attribute.name%>(void ) {\r\n\t\tgetSubscribeAttributeNameVector().erase( std::remove( getSubscribeAttributeNameVector().begin(), getSubscribeAttributeNameVector().end(), \"<%=attribute.name%>\" ), getSubscribeAttributeNameVector().end() );\r\n\t}\r\n\r\n<% }); -%>\r\nprotected:\r\n<% /*datamembers:objectmembers()*/ -%>\r\n<% datamembers.forEach(function(datamember){ -%>\r\n\tAttribute< int, <%- helpers.cppjavaTypeMap(datamember.parameterType) %> > _<%=datamember.name%>;\r\n<% }); -%>\r\n\r\npublic:\r\n<% datamembers.forEach(function(datamember){ -%>\r\n<% /*datamembers:objectsetters()*/ -%>\r\n\tvoid set_<%=datamember.name%>( <%- helpers.cppjavaArgumentTypeMap(datamember.parameterType) %> <%=datamember.name%> ) {\r\n\t\t_<%=datamember.name%>.setValue( <%=datamember.name%> );\r\n\t\t_<%=datamember.name%>.setTime( getTime() );\r\n\t}\r\n\r\n<% /*datamembers:objectgetters()*/ -%>\r\n\t<%- helpers.cppjavaArgumentTypeMap(datamember.parameterType) %> get_<%=datamember.name%>( void ) const {\r\n\t\treturn _<%=datamember.name%>.getValue();\r\n\t}\r\n\r\n<% /*datamembers:objecttimegetters()*/ -%>\r\n\tdouble get_<%=datamember.name%>_time( void ) {\r\n\t\treturn _<%=datamember.name%>.getTime();\r\n\t}\r\n\r\n<% }); -%>\r\n<% } -%>\r\n<% } -%>\r\n\t<%=classname%>( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) : Super( datamemberMap ) { }\r\n\r\n\t<%=classname%>( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &logicalTime ) : Super( datamemberMap, logicalTime ) { }\r\n<% if(datamembers && datamembers.length > 0){ -%>\r\n\r\npublic:\r\n\tTypeMedley get<%=isinteraction?\"Parameter\":\"Attribute\"%>( const std::string &datamemberName ) const {\r\n<% /*first(datamembers):startgetbyname()*/ -%>\r\n<% for(var i = 0; i<datamembers.length; i++ ){ -%>\r\n<%= i == 0  ? '\t\tif' : ' else if' %> ( \"<%=datamembers[i].name%>\" == datamemberName ) {\r\n\t\t\treturn TypeMedley( get_<%=datamembers[i].name%>() );\r\n\t\t}<%}%> else {\r\n\t\t\treturn Super::get<%=isinteraction?\"Parameter\":\"Attribute\"%>( datamemberName );\r\n\t\t}\r\n\t}\r\n\r\nprotected:\r\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( const std::string &datamemberName, const std::string &val ) {\r\n\t\tbool retval = true;\r\n<% /*first(datamembers):startifstring()*/ -%>\r\n<% for(var i = 0; i<datamembers.length; i++ ){ -%>\r\n<%= i == 0  ? '\t\tif' : ' else if'%> ( \"<%=datamembers[i].name%>\" == datamemberName ) {\r\n\t\t\tset_<%=datamembers[i].name%>(  TypeMedley( val )  );\r\n\t\t}<%}%> else {\r\n\t\t\tretval = Super::set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, val );\r\n\t\t}\r\n\r\n\t\treturn retval;\r\n\t}\r\n\r\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( const std::string &datamemberName, const TypeMedley &val ) {\r\n\t\tbool retval = true;\r\n<% /*first(datamembers):startifname()*/ -%>\r\n<% for(var i = 0; i<datamembers.length; i++ ){ -%>\r\n<%= i == 0  ? '\t\tif' : ' else if'%> ( \"<%=datamembers[i].name%>\" == datamemberName ) {\r\n\t\t\tset_<%=datamembers[i].name%>( val );\r\n\t\t}<%}%> else {\r\n\t\t\tretval = Super::set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, val );\r\n\t\t}\r\n\r\n\t\treturn retval;\r\n\t}\r\n<% if(!isinteraction){ -%>\r\n\r\n\tvirtual AttributeHandleValuePairSetSP createDatamemberHandleValuePairSet( bool force );\r\n<% } -%>\r\n<% } -%>\r\n};\r\n\r\ntypedef <%=classname%>::SP <%=classname%>SP;\r\n\r\nstatic bool call_<%=classname%>_static_init = <%=classname%>::static_init();\r\n\r\nstd::ostream &operator<<( std::ostream &os, <%=classname%>::SP entitySP );\r\nstd::ostream &operator<<( std::ostream &os, const <%=classname%> &entity );\r\n\r\n#endif\r\n",
    "cpp/classcommon.cpp.ejs": "<% /*classcommon(isinteraction,classname,parentclassname,hlaclassname,datamembers,alldatamembers) ::= << */ -%>\r\nvoid <%=classname%>::init( RTI::RTIambassador *rti ) {\r\n\tstatic bool isInitialized = false;\r\n\tif ( isInitialized ) {\r\n\t\treturn;\r\n\t}\r\n\tisInitialized = true;\r\n<% if(parentclassname){ -%>\r\n\r\n\t<%=parentclassname%>::init( rti );\r\n<% } -%>\r\n\r\n\tbool isNotInitialized = true;\r\n\twhile( isNotInitialized ) {\r\n\t\ttry {\r\n\t\t\tgetHandle() = rti->get<%=isinteraction?\"Interaction\":\"Object\"%>ClassHandle( \"<%=hlaclassname%>\" );\r\n\t\t\tisNotInitialized = false;\r\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\r\n\t\t\tstd::cerr << getInitErrorMessage() << \"Federate Not Execution Member\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::NameNotFound & ) {\r\n\t\t\tstd::cerr << getInitErrorMessage() << \"Name Not Found\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << getInitErrorMessage() << \"Exception caught ... retry\" << std::endl;\r\n\t\t}\r\n\t}\r\n\r\n\tgetClassNameHandleMap().insert(  std::make_pair( \"<%=classname%>\", get_handle() )  );\r\n\tgetClassHandleNameMap().insert(  std::make_pair( get_handle(), \"<%=classname%>\" )  );\r\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\r\n\r\n\tisNotInitialized = true;\r\n\twhile( isNotInitialized ) {\r\n\t\ttry {\r\n<% /*alldatamembers:handle_init()*/ -%>\r\n<% alldatamembers.forEach(function(datamember){ -%>\r\n\t\t\tget_<%=datamember.name%>_handle_var() = rti->get<%=isinteraction?\"Parameter\":\"Attribute\"%>Handle( \"<%=datamember.name%>\", get_handle() );\r\n<% }); -%>\r\n\t\t\tisNotInitialized = false;\r\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\r\n\t\t\tstd::cerr << getInitErrorMessage() << \"Federate Not Execution Member\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\r\n\t\t\tstd::cerr << getInitErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::NameNotFound & ) {\r\n\t\t\tstd::cerr << getInitErrorMessage() << \"Name Not Found\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << getInitErrorMessage() << \"Exception caught ... retry\" << std::endl;\r\n\t\t}\r\n\t}\r\n<% alldatamembers.forEach(function(datamember){ -%>\r\n\r\n<% /*alldatamembers: { d |<initDatamemberNameHandleMap(classname=classname,datamember=d)>}*/ -%>\r\n\tgetDatamemberNameHandleMap().insert(  std::make_pair( \"<%=classname%>.<%=datamember.name%>\", get_<%=datamember.name%>_handle() )  );\r\n<% /*alldatamembers:initDatamemberHandleNameMap()*/ -%>\r\n\tgetDatamemberHandleNameMap().insert(  std::make_pair( get_<%=datamember.name%>_handle(), \"<%=datamember.name%>\" )  );\r\n<% /*alldatamembers:initDatamemberTypeMap()*/ -%>\r\n\tgetDatamemberTypeMap().insert( std::make_pair(\"<%=datamember.name%>\", \"<%=datamember.parameterType%>\") );\r\n<% }); -%>\r\n<% } -%>\r\n}\r\n\r\nvoid <%=classname%>::publish( RTI::RTIambassador *rti ) {\r\n\tif ( getIsPublished() ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tinit( rti );\r\n<% if(!isinteraction){ -%>\r\n\r\n\tgetPublishedAttributeHandleSet_var().empty();\r\n\tfor( StringVector::iterator stsItr = getPublishAttributeNameVector().begin() ; stsItr != getPublishAttributeNameVector().end() ; (void)++stsItr ) {\r\n\t\ttry {\r\n\t\t\tgetPublishedAttributeHandleSet_var().add(  getDatamemberNameHandleMap().find( \"<%=classname%>.\" + *stsItr )->second  );\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << getPublishErrorMessage() << \"Could not publish \\\"\" << *stsItr + \"\\\" attribute.\" << std::endl;\r\n\t\t}\r\n\t}\r\n<% } -%>\r\n\r\n\tbool isNotPublished = true;\r\n\twhile( isNotPublished ) {\r\n\t\ttry {\r\n\t\t\trti->publish<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle()<% if(!isinteraction){ %>, getPublishedAttributeHandleSet_var()<%}%> );\r\n\t\t\tisNotPublished = false;\r\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\r\n\t\t\tstd::cerr << getPublishErrorMessage() << \"Federate Not Execution Member\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\r\n\t\t\tstd::cerr << getPublishErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << getPublishErrorMessage() << \"Exception caught ... retry\" << std::endl;\r\n\t\t}\r\n\t}\r\n\r\n\tgetIsPublished() = true;\r\n}\r\n\r\nvoid <%=classname%>::unpublish( RTI::RTIambassador *rti ) {\r\n\tif ( !getIsPublished() ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tinit( rti );\r\n\r\n\tbool isNotUnpublished = true;\r\n\twhile( isNotUnpublished ) {\r\n\t\ttry {\r\n\t\t\trti->unpublish<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle() );\r\n\t\t\tisNotUnpublished = false;\r\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\r\n\t\t\tstd::cerr << getUnpublishErrorMessage() + \"Federate Not Execution Member\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\r\n\t\t\tstd::cerr << getUnpublishErrorMessage() + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotPublished & ) {\r\n\t\t\tstd::cerr << getUnpublishErrorMessage() + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Published\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << getUnpublishErrorMessage() << \"Exception caught ... retry\" << std::endl;\r\n\t\t}\r\n\t}\r\n\r\n\tgetIsPublished() = false;\r\n}\r\n\r\nvoid <%=classname%>::subscribe( RTI::RTIambassador *rti ) {\r\n\tif ( getIsSubscribed() ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tinit( rti );\r\n<% if(!isinteraction){ -%>\r\n\r\n\tgetSubscribedAttributeHandleSet_var().empty();\r\n\tfor(  StringVector::iterator sstItr = getSubscribeAttributeNameVector().begin() ; sstItr != getSubscribeAttributeNameVector().end() ; (void)++sstItr  ) {\r\n\t\ttry {\r\n\t\t\tgetSubscribedAttributeHandleSet_var().add(  getDatamemberNameHandleMap().find( \"<%=classname%>.\" + *sstItr )->second  );\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << getSubscribeErrorMessage() << \"Could not subscribe to \\\"\" << *sstItr << \"\\\" attribute.\" << std::endl;\r\n\t\t}\r\n\t}\r\n<% } -%>\r\n\r\n\tbool isNotSubscribed = true;\r\n\twhile( isNotSubscribed ) {\r\n\t\ttry {\r\n\t\t\trti->subscribe<% if(isinteraction){ %>InteractionClass( get_handle() )<% }else{ %>ObjectClassAttributes( get_handle(), getSubscribedAttributeHandleSet_var() )<%}%>;\r\n\t\t\tisNotSubscribed = false;\r\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\r\n\t\t\tstd::cerr << getSubscribeErrorMessage() << \"Federate Not Execution Member\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\r\n\t\t\tstd::cerr << getSubscribeErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << getSubscribeErrorMessage() << \"Exception caught ... retry\" << std::endl;\r\n\t\t}\r\n\t}\r\n\r\n\tgetIsSubscribed() = true;\r\n}\r\n\r\nvoid <%=classname%>::unsubscribe( RTI::RTIambassador *rti ) {\r\n\tif ( !getIsSubscribed() ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tinit( rti );\r\n\r\n\tbool isNotUnsubscribed = true;\r\n\twhile( isNotUnsubscribed ) {\r\n\t\ttry {\r\n\t\t\trti->unsubscribe<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle() );\r\n\t\t\tisNotUnsubscribed = false;\r\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\r\n\t\t\tstd::cerr << getUnsubscribeErrorMessage() << \"Federate Not Execution Member\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\r\n\t\t\tstd::cerr << getUnsubscribeErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotSubscribed & ) {\r\n\t\t\tstd::cerr << getUnsubscribeErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Subscribed\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << getUnsubscribeErrorMessage() << \"Exception caught ... retry\" << std::endl;\r\n\t\t}\r\n\t}\r\n\r\n\tgetIsSubscribed() = false;\r\n}\r\n\r\nbool <%=classname%>::static_init( void ) {\r\n\tstatic bool isInitialized = false;\r\n\tif ( isInitialized ) {\r\n\t\treturn true;\r\n\t}\r\n\tisInitialized = true;\r\n\r\n\tgetClassNameSet().insert( \"<%=classname%>\" );\r\n\r\n\tgetClassNameFactoryMap().insert(  std::make_pair( \"<%=classname%>\", &<%=classname%>::factory )  );\r\n\tgetClassNamePublishMap().insert(   std::make_pair(  \"<%=classname%>\", (PubsubFunctionPtr)( &<%=classname%>::publish )  )   );\r\n\tgetClassNameUnpublishMap().insert(   std::make_pair(  \"<%=classname%>\", (PubsubFunctionPtr)( &<%=classname%>::unpublish )  )   );\r\n\tgetClassNameSubscribeMap().insert(   std::make_pair(  \"<%=classname%>\", (PubsubFunctionPtr)( &<%=classname%>::subscribe )  )   );\r\n\tgetClassNameUnsubscribeMap().insert(   std::make_pair(  \"<%=classname%>\", (PubsubFunctionPtr)( &<%=classname%>::unsubscribe )  )   );\r\n\r\n\tgetDatamemberClassNameVectorPtrMap().insert(  std::make_pair( \"<%=classname%>\", &getDatamemberNames() )  );\r\n\tgetAllDatamemberClassNameVectorPtrMap().insert(  std::make_pair( \"<%=classname%>\", &getAllDatamemberNames() )  );\r\n<% if(datamembers && datamembers.length > 0){ -%>\r\n\r\n<% /*datamembers:initDatamemberNameSet()*/ -%>\r\n<% datamembers.forEach(function(datamember){ -%>\r\n<% if(!datamember.hidden && !datamember.inherited){ -%>\r\n\tgetDatamemberNames().push_back( \"<%=datamember.name%>\" );\r\n<% } -%>\r\n<% }); -%>\r\n<% } -%>\r\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\r\n\r\n<% /*alldatamembers:initAllDatamemberNameSet()*/ -%>\r\n<% alldatamembers.forEach(function(datamember){ -%>\r\n\tgetAllDatamemberNames().push_back( \"<%=datamember.name%>\" );\r\n<% }); -%>\r\n<% } -%>\r\n<% if(!isinteraction){ -%>\r\n\r\n\tgetClassNamePublishAttributeNameVectorPtrMap().insert(  std::make_pair( \"<%=classname%>\", &getPublishAttributeNameVector() )  );\r\n\tgetClassNameSubscribeAttributeNameVectorPtrMap().insert(  std::make_pair( \"<%=classname%>\", &getSubscribeAttributeNameVector() )  );\r\n\r\n\tgetClassNamePublishedAttributesPtrMap().insert(  std::make_pair( \"<%=classname%>\", &getPublishedAttributeHandleSet_var() )  );\r\n\tgetClassNameSubscribedAttributesPtrMap().insert( std::make_pair( \"<%=classname%>\", &getSubscribedAttributeHandleSet_var() )  );\r\n<% } -%>\r\n\r\n\treturn true;\r\n}\r\n\r\nstd::ostream &operator<<( std::ostream &os, <%=classname%>::SP entitySP ) {\r\n\treturn os << *entitySP;\r\n}\r\nstd::ostream &operator<<( std::ostream &os, const <%=classname%> &entity ) {\r\n\treturn os << \"<%=classname%>(\"\r\n<% alldatamembers.forEach(function(datamember,i){ -%>\r\n\t\t\t<% if( i > 0){%><< \", \"<%}%> << \"<%=datamember.name%>:\" << entity.get_<%=datamember.name%>()\r\n<% }); -%>\r\n\t\t\t<< \")\";\r\n}\r\n",
    "cpp/classcommon.hpp.ejs": "<% /*classcommon(isinteraction,classname,parentclassname,hlaclassname,datamembers,alldatamembers) ::= <<*/ -%>\r\nprivate:\r\n\tstatic int &getHandle( void ) {\r\n\t\tstatic int handle;\r\n\t\treturn handle;\r\n\t}\r\n\r\npublic:\r\n\tstatic int get_handle( void ) { return getHandle(); }\r\n\tstatic std::string get_class_name( void ) { return \"<%=classname%>\"; }\r\n\r\nprivate:\r\n\tstatic StringVector &getDatamemberNames( void ) {\r\n\t\tstatic StringVector datamemberNames;\r\n\t\treturn datamemberNames;\r\n\t}\r\n\r\n\tstatic StringVector &getAllDatamemberNames( void ) {\r\n\t\tstatic StringVector allDatamemberNames;\r\n\t\treturn allDatamemberNames;\r\n\t}\r\n<% if(!isinteraction){ -%>\r\n\r\nprivate:\r\n\tstatic RTI::AttributeHandleSet &getPublishedAttributeHandleSet_var( void ) {\r\n\t\tstatic RTI::AttributeHandleSet *publishedAttributeHandleSetPtr = RTI::AttributeHandleSetFactory::create( <%= alldatamembers.length %> );\r\n\t\treturn *publishedAttributeHandleSetPtr;\r\n\t}\r\n\tstatic StringVector &getPublishAttributeNameVector( void ) {\r\n\t\tstatic StringVector publishAttributeNameVector;\r\n\t\treturn publishAttributeNameVector;\r\n\t}\r\n\r\n\tstatic RTI::AttributeHandleSet &getSubscribedAttributeHandleSet_var( void ) {\r\n\t\tstatic RTI::AttributeHandleSet *subscribedAttributeHandleSet = RTI::AttributeHandleSetFactory::create( <%= alldatamembers.length %> );\r\n\t\treturn *subscribedAttributeHandleSet;\r\n\t}\r\n\tstatic StringVector &getSubscribeAttributeNameVector( void ) {\r\n\t\tstatic StringVector subscribeAttributeNameVector;\r\n\t\treturn subscribeAttributeNameVector;\r\n\t}\r\n<% } -%>\r\n\r\nprivate:\r\n<% if(isinteraction){ -%>\r\n\tstatic InteractionRoot::SP factory( void ) {\r\n\t\treturn InteractionRoot::SP( new <%=classname%>() );\r\n\t}\r\n<% }else{ -%>\r\n\tstatic ObjectRoot::SP factory( void ) {\r\n\t\treturn ObjectRoot::SP( new <%=classname%>() );\r\n\t}\r\n<% } -%>\r\n\r\n\tstatic std::string &getInitErrorMessage( void ) {\r\n\t\tstatic std::string initErrorMessage( \"Error:  <%=classname%>:  could not initialize:  \" );\r\n\t\treturn initErrorMessage;\r\n\t}\r\n\r\nprotected:\r\n\tstatic void init( RTI::RTIambassador *rti );\r\n\r\nprivate:\r\n\tstatic bool &getIsPublished( void ) {\r\n\t\tstatic bool isPublished = false;\r\n\t\treturn isPublished;\r\n\t}\r\n\r\n\tstatic std::string &getPublishErrorMessage( void ) {\r\n\t\tstatic std::string publishErrorMessage = \"Error:  <%=classname%>:  could not publish:  \";\r\n\t\treturn publishErrorMessage;\r\n\t}\r\n\r\npublic:\r\n\tstatic void publish( RTI::RTIambassador *rti );\r\n\r\nprivate:\r\n\tstatic std::string &getUnpublishErrorMessage( void ) {\r\n\t\tstatic std::string unpublishErrorMessage = \"Error:  <%=classname%>:  could not unpublish:  \";\r\n\t\treturn unpublishErrorMessage;\r\n\t}\r\n\r\npublic:\r\n\tstatic void unpublish( RTI::RTIambassador *rti );\r\n\r\nprivate:\r\n\tstatic bool &getIsSubscribed( void ) {\r\n\t\tstatic bool isSubscribed = false;\r\n\t\treturn isSubscribed;\r\n\t}\r\n\tstatic std::string &getSubscribeErrorMessage( void ) {\r\n\t\tstatic std::string subscribedErrorMessage = \"Error:  <%=classname%>:  could not subscribe:  \";\r\n\t\treturn subscribedErrorMessage;\r\n\t}\r\n\r\npublic:\r\n\tstatic void subscribe( RTI::RTIambassador *rti );\r\n\r\nprivate:\r\n\tstatic std::string getUnsubscribeErrorMessage( void ) {\r\n\t\tstatic std::string unsubscribeErrorMessage = \"Error:  <%=classname%>:  could not unsubscribe:  \";\r\n\t\treturn unsubscribeErrorMessage;\r\n\t}\r\n\r\npublic:\r\n\tstatic void unsubscribe( RTI::RTIambassador *rti );\r\n\r\n\tstatic bool static_init( void );\r\n\r\n\tstatic bool match( int handle ) { return handle == get_handle(); }\r\n\r\n\tvirtual int getClassHandle( void ) const { return get_handle(); }\r\n\tvirtual std::string getClassName( void ) const { return get_class_name(); }\r\n\tvirtual StringVector get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names( void ) const { return get_<%=isinteraction?\"parameter\":\"attribute\"%>_names(); }\r\n\tvirtual StringVector getAll<%=isinteraction?\"Parameter\":\"Attribute\"%>Names( void ) const { return get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names(); }\r\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\r\n\r\n\tvirtual std::string get<%=isinteraction?\"Parameter\":\"Attribute\"%>Name( int datamemberHandle ) const {\r\n<% for(var i = 0; i<alldatamembers.length; i++ ){ -%>\r\n<%= i == 0 ? '\t\tif' : ' else if'%> (datamemberHandle == get_<%=alldatamembers[i].name%>_handle()) {\r\n\t\t\treturn std::string(\"<%=alldatamembers[i].name%>\");\r\n\t\t}<% } %> else {\r\n<% if(parentclassname){ -%>\r\n\t\t\treturn <%=parentclassname%>::get<%=isinteraction?\"Parameter\":\"Attribute\"%>Name(datamemberHandle);\r\n<% } else { -%>\r\n\t\t\treturn std::string();\r\n<% } -%>\r\n\t\t}\r\n\t}\r\n<% } -%>\r\n\r\n\tvirtual void publish<%=isinteraction?\"Interaction\":\"Object\"%>( RTI::RTIambassador *rti ) { publish( rti ); }\r\n\tvirtual void subscribe<%=isinteraction?\"Interaction\":\"Object\"%>( RTI::RTIambassador *rti ) { subscribe( rti ); }\r\n\r\n\tvirtual <%=isinteraction?\"Interaction\":\"Object\"%>Root::SP clone( void ) {\r\n\t\treturn <%=isinteraction?\"Interaction\":\"Object\"%>Root::SP(  new <%=classname%>( *this )  );\r\n\t}\r\n<% if(!isinteraction){ -%>\r\n\r\n\tvirtual const RTI::AttributeHandleSet &getSubscribedAttributeHandleSet( void ) { return getSubscribedAttributeHandleSet_var(); }\r\n<% } -%>\r\n",
    "cpp/classroot.cpp.ejs": "<% /* THIS IS THE ROOT CLASS OF EITHER THE INTERACTION OR OBJECT-CLASS HEIRARCHY (I.E. \"InteractionRoot\" OR \"ObjectRoot\") */ %>\r\n<% /*classroot(isinteraction) ::= <<*/ %>\r\n\r\n/*\r\n * Copyright (c) 2008, Institute for Software Integrated Systems, Vanderbilt University\r\n * All rights reserved.\r\n *\r\n * Permission to use, copy, modify, and distribute this software and its\r\n * documentation for any purpose, without fee, and without written agreement is\r\n * hereby granted, provided that the above copyright notice, the following\r\n * two paragraphs and the author appear in all copies of this software.\r\n *\r\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\r\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\r\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\r\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\r\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\r\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\r\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\r\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\r\n *\r\n */\r\n\r\n#include <boost/lexical_cast.hpp>\r\n#include \"<%=isinteraction?\"Interaction\":\"Object\"%>Root.hpp\"\r\n\r\nC2WLogger* <%=isinteraction?\"Interaction\":\"Object\"%>Root::_logger = &C2W_RTI_LOGGER_CLS::get_singleton();\r\n\r\n<% /*classcommon(classname=apMap.classfirstupper+\"Root\",hlaclassname=apMap.classfirstupper+\"Root\",...)*/ %>\r\n<%- ejs.render(TEMPLATES[\"cpp/classcommon.cpp.ejs\"],\r\n\t{\tisinteraction: isinteraction,\r\n\t\tclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\r\n\t\tparentclassname: \"\",\r\n\t\thlaclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\r\n\t\tdatamembers: [],\r\n\t\talldatamembers: []\r\n}) %>\r\n\r\n<% if(!isinteraction){ %>\r\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::publish( const std::string &className, const std::string &attributeName ) {\r\n\tNameStringVectorPtrMap::iterator camItr = getClassNamePublishAttributeNameVectorPtrMap().find( className );\r\n\tif ( camItr == getClassNamePublishAttributeNameVectorPtrMap().end() ) {\r\n\t\tstd::cerr << \"ERROR:  ObjectRoot.publish:  could not publish class \\\"\" << className << \"\\\" \\\"\" << attributeName << \"\\\" attribute.\" << std::endl;\r\n\t\treturn;\r\n\t}\r\n\tNameStringVectorPtrMap::iterator dnsItr = getAllDatamemberClassNameVectorPtrMap().find( className );\r\n\tif ( dnsItr == getAllDatamemberClassNameVectorPtrMap().end() ) {\r\n\t\tstd::cerr << \"ERROR:  ObjectRoot.publish:  unexpected error:  no datamember vector for class \\\"\" << className << \"\\\"\" << std::endl;\r\n\t\treturn;\r\n\t}\r\n\tif (  std::find ( dnsItr->second->begin(), dnsItr->second->end(), attributeName ) == dnsItr->second->end()  ) {\r\n\t\tstd::cerr << \"ERROR:  ObjectRoot.publish:  no datamember named \\\"\" << attributeName << \"\\\" in class \\\"\" << className << \"\\\"\" << std::endl;\r\n\t\treturn;\r\n\t}\r\n\tcamItr->second->push_back( attributeName );\r\n}\r\n\r\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::subscribe( const std::string &className, const std::string &attributeName ) {\r\n\tNameStringVectorPtrMap::iterator camItr = getClassNameSubscribeAttributeNameVectorPtrMap().find( className );\r\n\tif ( camItr == getClassNameSubscribeAttributeNameVectorPtrMap().end() ) {\r\n\t\tstd::cerr << \"ERROR:  ObjectRoot.subscribe:  could not subscribe class \\\"\" << className << \"\\\" \\\"\" << attributeName << \"\\\" attribute.\" << std::endl;\r\n\t\treturn;\r\n\t}\r\n\tNameStringVectorPtrMap::iterator dnsItr = getAllDatamemberClassNameVectorPtrMap().find( className );\r\n\tif ( dnsItr == getAllDatamemberClassNameVectorPtrMap().end() ) {\r\n\t\tstd::cerr << \"ERROR:  ObjectRoot.subscribe:  unexpected error:  no datamember vector for class \\\"\" << className << \"\\\"\" << std::endl;\r\n\t\treturn;\r\n\t}\r\n\tif (  std::find ( dnsItr->second->begin(), dnsItr->second->end(), attributeName ) == dnsItr->second->end()  ) {\r\n\t\tstd::cerr << \"ERROR:  ObjectRoot.subscribe:  no datamember named \\\"\" << attributeName << \"\\\" in class \\\"\" << className << \"\\\"\" << std::endl;\r\n\t\treturn;\r\n\t}\r\n\tcamItr->second->push_back( attributeName );\r\n}\r\n\r\n<%}%>\r\n\t\r\n<%=isinteraction?\"Interaction\":\"Object\"%>Root::SP <%=isinteraction?\"Interaction\":\"Object\"%>Root::create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) {\r\n\tIntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\r\n\tif ( ismItr == getClassHandleNameMap().end() ) {\r\n\t\treturn SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 );\r\n\t}\r\n\t\r\n\tClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( ismItr->second );\r\n\tif ( cfmItr == getClassNameFactoryMap().end() ) {\r\n\t\treturn SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 );\r\n\t}\r\n\t\r\n\tSP sp = (*cfmItr->second)();\r\n\tsp->set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\r\n\r\n\treturn sp;\r\n}\r\n\r\n<%=isinteraction?\"Interaction\":\"Object\"%>Root::SP <%=isinteraction?\"Interaction\":\"Object\"%>Root::create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime ) {\r\n\tIntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\r\n\tif ( ismItr == getClassHandleNameMap().end() ) {\r\n\t\treturn SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 );\r\n\t}\r\n\t\r\n\tClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( ismItr->second );\r\n\tif ( cfmItr == getClassNameFactoryMap().end() ) {\r\n\t\treturn SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 );\r\n\t}\r\n\t\r\n\tSP sp = (*cfmItr->second)();\r\n\tsp->set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\r\n\tsp->setTime( dlc13FedTime.getTime() );\r\n\r\n\treturn sp;\r\n}\r\n\r\n\r\n<% if(!isinteraction){ %>\r\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::requestUpdate( RTI::RTIambassador *rti ) {\r\n\tbool requestNotSubmitted = true;\r\n\twhile( requestNotSubmitted ) {\r\n\t\ttry {\t\t\r\n\t\t\trti->requestObjectAttributeValueUpdate( getObjectHandle(), getSubscribedAttributeHandleSet_var() );\r\n\t\t\trequestNotSubmitted = false;\r\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\r\n\t\t\tstd::cerr << \"ERROR: \" << getClassName() << \"request for update failed:  Federate Not Execution Member\" << std::endl;\r\n\t\t\treturn;\t\t\t\t\r\n\t\t} catch ( RTI::ObjectNotKnown & ) {\r\n\t\t\tstd::cerr << \"ERROR: \" << getClassName() << \"request for update failed:  Object Not Known\" << std::endl;\r\n\t\t\treturn;\t\t\t\t\r\n\t\t} catch ( RTI::AttributeNotDefined & ) {\r\n\t\t\tstd::cerr << \"ERROR: \" << getClassName() << \"request for update failed:  Name Not Found\" << std::endl;\r\n\t\t\treturn;\t\t\t\t\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << \"ERROR: \" << getClassName() << \"request for update failed:  Unknown Exception\" << std::endl;\t\t\t}\r\n\t}\r\n}\r\n\r\n<%}%>\r\n\r\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) {\r\n\tint size = datamemberMap.size();\r\n\tfor( int ix = 0 ; ix < size ; ++ix ) {\r\n\t\ttry {\r\n\t\t\tstatic RTI::ULong valueLength;\r\n\t\t\tchar *value = datamemberMap.getValuePointer( ix, valueLength );\r\n\t\t\tset<%=isinteraction?\"Parameter\":\"Attribute\"%>(  datamemberMap.getHandle( ix ), std::string( value, valueLength )  );\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << \"set<%=isinteraction?\"Parameter\":\"Attribute\"%>s: Exception caught!\" << std::endl;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n<% if(isinteraction){ %>\r\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::sendInteraction( RTI::RTIambassador *rti, double time ) {\r\n\tbool interactionNotSent = true;\r\n\twhile( interactionNotSent ) {\r\n\t\ttry {\r\n\t\t\tParameterHandleValuePairSetSP datamembers = createDatamemberHandleValuePairSet( 0 );\r\n\t\t\trti->sendInteraction(  getClassHandle(), *datamembers, RTIfedTime( time ), 0  );\r\n\t\t\tcreateLog( time, true );\r\n\t\t\tinteractionNotSent = false;\r\n\t\t} catch ( RTI::InteractionClassNotDefined & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Class Not Defined\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::InteractionClassNotPublished & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Class Not Published\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::InteractionParameterNotDefined & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Parameter Not Defined\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::InvalidFederationTime & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Invalid Federation Time\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Federate Not Execution Member\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::ConcurrentAccessAttempted & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  ConcurrentAccessAttempted\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Exception caught ... retry\" << std::endl;\r\n#ifdef _WIN32\r\n\t\t\tSleep( 500 );\r\n#else\r\n\t\t\tusleep( 500000 );\r\n#endif\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::sendInteraction( RTI::RTIambassador *rti ) {\r\n\tbool interactionNotSent = true;\r\n\twhile( interactionNotSent ) {\r\n\t\ttry {\r\n\t\t\tParameterHandleValuePairSetSP datamembers = createDatamemberHandleValuePairSet( 0 );\r\n\t\t\trti->sendInteraction(  getClassHandle(), *datamembers, 0  );\r\n\t\t\tcreateLog( 0, true );\r\n\t\t} catch ( RTI::InteractionClassNotDefined & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Class Not Defined\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::InteractionClassNotPublished & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Class Not Published\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::InteractionParameterNotDefined & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Parameter Not Defined\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Federate Not Execution Member\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::ConcurrentAccessAttempted & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  ConcurrentAccessAttempted\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Exception caught ... retry\" << std::endl;\r\n#ifdef _WIN32\r\n\t\t\tSleep( 500 );\r\n#else\r\n\t\t\tusleep( 500000 );\r\n#endif\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstd::string <%=isinteraction?\"Interaction\":\"Object\"%>Root::fedName = \"\";\r\nbool <%=isinteraction?\"Interaction\":\"Object\"%>Root::enablePubLog = false;\r\nbool <%=isinteraction?\"Interaction\":\"Object\"%>Root::enableSubLog = false;\r\nstd::string <%=isinteraction?\"Interaction\":\"Object\"%>Root::pubLogLevel = \"\";\r\nstd::string <%=isinteraction?\"Interaction\":\"Object\"%>Root::subLogLevel = \"\";\r\n\r\nvoid InteractionRoot::enablePublishLog( const std::string &interaction, const std::string &fed, const std::string &thislevel, const std::string &globallevel ) {\r\n\tif ( globallevel.empty() ) {\r\n\t\treturn;\r\n\t}\r\n\tif (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {\r\n\t\treturn;\r\n\t}\r\n\tfedName = fed;\r\n\tenablePubLog = true;\r\n\tpubLogLevel = thislevel;\r\n\t_logger->addLog(interaction, fedName, true);\r\n}\r\n\r\nvoid InteractionRoot::enableSubscribeLog( const std::string &interaction, const std::string &fed, const std::string &thislevel, const std::string &globallevel ) {\r\n\tif ( globallevel.empty() ) {\r\n\t\treturn;\r\n\t}\r\n\tif (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {\r\n\t\treturn;\r\n\t}\r\n\tfedName = fed;\r\n\tenableSubLog = true;\r\n\tsubLogLevel = thislevel;\r\n\t_logger->addLog( interaction, fedName, false );\r\n}\r\n\r\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::createLog( double time, bool isPub ) {\r\n\tif (  ( isPub && !enablePubLog ) || ( !isPub && !enableSubLog )  ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tstd::string interactionId;\r\n\tif ( isPub ) {\r\n\t\tinteractionId = \"pub_\" + getClassName();\r\n\t\tif ( !fedName.empty() ) {\r\n\t\t\tinteractionId = fedName + \"_\" + interactionId;\r\n\t\t}\r\n\t} else {\r\n\t\tinteractionId = getClassName() + \"_sub\";\r\n\t\tif ( !fedName.empty() ) {\r\n\t\t\tinteractionId += \"_\" + fedName;\r\n\t\t}\r\n\t}\r\n\t\r\n\t_logger->addLog( interactionId, *this, time, pubLogLevel );\r\n}\r\n\r\n<%}else{%>\r\nvoid ObjectRoot::registerObject( RTI::RTIambassador *rti ) {\r\n    \r\n    while( !_isRegistered ) {\r\n        try {\r\n            _object_handle = rti->registerObjectInstance( getClassHandle() );\r\n            _isRegistered = true;\r\n        } catch ( RTI::ObjectClassNotDefined & ) {\r\n        \tstd::cerr << \"ERROR:  InteractionRoot::registerObject:  Object Class Not Defined\" << std::endl;\r\n            return;\r\n        } catch ( RTI::ObjectClassNotPublished & ) {\r\n        \tstd::cerr << \"ERROR:  InteractionRoot::registerObject:  Object Class Not Published\" << std::endl;\r\n            return;\r\n        } catch ( RTI::FederateNotExecutionMember & ) {\r\n        \tstd::cerr << \"ERROR:  InteractionRoot::registerObject:  Federate Not Execution Member\" << std::endl;\r\n            return;\r\n        } catch ( ... ) {\r\n        \tstd::cerr << \"InteractionRoot::registerObject:  Exception caught ... retry\" << std::endl;\r\n        }\r\n    }\r\n\r\n}\r\n\r\nvoid ObjectRoot::unregisterObject( RTI::RTIambassador *rti ) {\r\n    \r\n    while( _isRegistered ) {\r\n        try {\r\n            rti->deleteObjectInstance( getObjectHandle(), 0 );\r\n            _isRegistered = false;\r\n        } catch ( RTI::ObjectNotKnown & ) {\r\n        \tstd::cerr << \"ERROR:  InteractionRoot::unregisterObject:  Object Not Known\" << std::endl;\r\n            return;\r\n        } catch ( RTI::DeletePrivilegeNotHeld & ) {\r\n        \tstd::cerr << \"ERROR:  InteractionRoot::unregisterObject:  Delete Privilege Not Held\" << std::endl;\r\n            return;\r\n        } catch ( RTI::FederateNotExecutionMember & ) {\r\n        \tstd::cerr << \"ERROR:  InteractionRoot::unregisterObject:  Federate Not Execution Member\" << std::endl;\r\n            return;\r\n        } catch ( ... ) {\r\n        \tstd::cerr << \"InteractionRoot::unregisterObject:  Exception caught ... retry\" << std::endl;\r\n        }\r\n    }\r\n}\r\n\r\nvoid ObjectRoot::updateAttributeValues( RTI::RTIambassador *rti, double time, bool force ) {\r\n\r\n    AttributeHandleValuePairSetSP suppliedAttributesSP = createDatamemberHandleValuePairSet( force );\r\n    if ( suppliedAttributesSP->size() == 0 ) {\r\n    \treturn;\r\n    }\r\n\r\n    try {\r\n        rti->updateAttributeValues(  getObjectHandle(), *suppliedAttributesSP, RTIfedTime( time ), 0  );\r\n        createLog( time, true );\r\n    } catch ( RTI::ObjectNotKnown & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Object Not Known\" << std::endl;\r\n        return;\r\n    } catch ( RTI::FederateNotExecutionMember & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Federate Not Execution Member\" << std::endl;\r\n        return;\r\n    } catch ( RTI::AttributeNotDefined & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Attribute Not Defined\" << std::endl;\r\n        return;\r\n    } catch ( RTI::AttributeNotOwned & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Attribute Not Owned\" << std::endl;\r\n        return;\r\n    } catch ( RTI::ConcurrentAccessAttempted & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Concurrent Access Attempted\" << std::endl;\r\n        return;\r\n    } catch ( RTI::InvalidFederationTime & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Invalid Federation Time\" << std::endl;\r\n        return;\r\n    } catch ( ... ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  exception caught\" << std::endl;\r\n    }\r\n}\r\n\r\nvoid ObjectRoot::updateAttributeValues( RTI::RTIambassador *rti, bool force ) {\r\n\r\n    AttributeHandleValuePairSetSP suppliedAttributesSP = createDatamemberHandleValuePairSet( force );\r\n    if ( suppliedAttributesSP->size() == 0 ) {\r\n    \treturn;\r\n    }\r\n\r\n    try {\r\n        rti->updateAttributeValues( getObjectHandle(), *suppliedAttributesSP, 0 );\r\n        createLog( 0, true );\r\n    } catch ( RTI::ObjectNotKnown & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Object Not Known\" << std::endl;\r\n        return;\r\n    } catch ( RTI::FederateNotExecutionMember & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Federate Not Execution Member\" << std::endl;\r\n        return;\r\n    } catch ( RTI::AttributeNotDefined & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Attribute Not Defined\" << std::endl;\r\n        return;\r\n    } catch ( RTI::AttributeNotOwned & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Attribute Not Owned\" << std::endl;\r\n        return;\r\n    } catch ( RTI::ConcurrentAccessAttempted & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Concurrent Access Attempted\" << std::endl;\r\n        return;\r\n    } catch ( RTI::InvalidFederationTime & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Invalid Federation Time\" << std::endl;\r\n        return;\r\n    } catch ( ... ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  exception caught\" << std::endl;\r\n    }\r\n}\r\n\r\nstd::string ObjectRoot::fedName = \"\";\r\n\r\nvoid ObjectRoot::enablePublishLog(const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel) {\r\n\r\n\tif ( globallevel.empty() ) {\r\n\t\treturn;\r\n\t}\r\n\tif (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {\r\n\t\treturn;\r\n\t}\r\n\tfedName = fed;\r\n\tgetPubAttributeLogMap().insert(  make_pair( attribute, thislevel )  );\r\n\t_logger->addLog( object, attribute, fed, true );\r\n}\r\n\r\nvoid ObjectRoot::enableSubscribeLog( const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel ) {\r\n\tif ( globallevel.empty() ) {\r\n\t\treturn;\r\n\t}\r\n\tif (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {\r\n\t\treturn;\r\n\t}\r\n\tfedName = fed;\r\n\tgetSubAttributeLogMap().insert(  make_pair( attribute, thislevel )  );\r\n\t_logger->addLog( object, attribute, fed, false );\r\n}\r\n\r\nvoid ObjectRoot::createLog( double time, bool isPub ) {\r\n\r\n\tif ( getPubAttributeLogMap().empty() ) {\r\n\t\treturn;\r\n\t}\r\n\tstd::string id = isPub ? fedName + \"_pub_\" + getClassName() : getClassName() + \"_sub_\" + fedName;\r\n\t_logger->addLog( id, *this, time );\r\n}\r\n\r\n<%}%>\r\n",
    "cpp/classroot.hpp.ejs": "\r\n<% /* THIS IS THE ROOT CLASS OF EITHER THE INTERACTION OR OBJECT-CLASS HEIRARCHY (I.E. \"InteractionRoot\" OR \"ObjectRoot\") */\r\n/*classroot(isinteraction) ::= <<*/ %>\r\n/*\r\n * Copyright (c) 2008, Institute for Software Integrated Systems, Vanderbilt University\r\n * All rights reserved.\r\n *\r\n * Permission to use, copy, modify, and distribute this software and its\r\n * documentation for any purpose, without fee, and without written agreement is\r\n * hereby granted, provided that the above copyright notice, the following\r\n * two paragraphs and the author appear in all copies of this software.\r\n *\r\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\r\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\r\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\r\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\r\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\r\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\r\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\r\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\r\n * \r\n */\r\n\r\n/*\r\n * \tNOTE:  ALL \"if\" STATEMENTS IN THIS CODE THAT HAD THE FORM:\r\n *\r\n *  if (condition) statement;\r\n *\r\n *\tOR\r\n *\r\n *  if (condition) statement1;\r\n *  else           statement2;\r\n *\r\n *  HAVE BEEN CONVERTED TO THE FORMS:\r\n *\r\n *  if (condition) {\r\n *\t\tstatement;\r\n *\t}\r\n *\r\n *\tAND\r\n *\r\n *  if (condition) {\r\n *\t\tstatement1;\r\n *\t} else {\r\n *\t\tstatement2;\r\n *\t}\r\n *\r\n *\tRESPECTIVELY.  THIS IS BECAUSE THE OMNET DEBUGGER APPEARS TO HAVE A PROBLEM\r\n *  WITH THE NON-BRACED FORMS OF THE IF STATEMENT.  *PLEASE* DO NOT CHANGE IT BACK.\r\n *  -- H.S.N.\r\n *\r\n */\r\n\r\n<% if(isinteraction){ %>\r\n#ifndef _INTERACTION_ROOT\r\n#define _INTERACTION_ROOT\r\n<% }else{ %>\r\n#ifndef _OBJECT_ROOT\r\n#define _OBJECT_ROOT\r\n<%}%>\r\n\r\n#ifndef _CRT_SECURE_NO_DEPRECATE\r\n#define _CRT_SECURE_NO_DEPRECATE\r\n#endif\r\n\r\n#ifndef RTI_USES_STD_FSTREAM\r\n#define RTI_USES_STD_FSTREAM\r\n#endif\r\n\r\n#include <string>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <sstream>\r\n#include <iostream>\r\n#include <set>\r\n#include <map>\r\n#include <list>\r\n#include <ctype.h>\r\n#include <stdlib.h>\r\n\r\n#include <boost/shared_ptr.hpp>\r\n\r\n#include <TypeMedley.hpp>\r\n#include <StringCollections.hpp>\r\n\r\n#include \"RTI.hh\"\r\n#include \"fedtime.hh\"\r\n\r\n#ifdef _WIN32\r\n#include <windows.h>\r\n#else\r\n#include <unistd.h>\r\n#endif\r\n\r\n#include \"RTILogger.hpp\"\r\n\r\n#ifndef C2W_RTI_LOGGER_CLS\r\n#define C2W_RTI_LOGGER_CLS C2WConsoleLogger\r\n#endif \r\n\r\n#include \"<%=isinteraction?\"Interaction\":\"Object\"%>If.hpp\"\r\n\r\nclass <%=isinteraction?\"Interaction\":\"Object\"%>Root : public <%=isinteraction?\"Interaction\":\"Object\"%>If{\r\npublic:\r\n\ttypedef std::map< std::string, StringSet * > NameStringSetPtrMap;\r\n\ttypedef std::map< std::string, StringVector * > NameStringVectorPtrMap;\r\n\ttypedef std::map< std::string, int > StringIntegerMap;\r\n\ttypedef std::map< int, std::string > IntegerStringMap;\r\n\r\n\ttypedef boost::shared_ptr< <%=isinteraction?\"Interaction\":\"Object\"%>Root > SP;\r\n\ttypedef boost::shared_ptr< RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet > <%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP;\r\n\t\r\n\ttypedef SP (*FactoryFunctionPtr)( void );\r\n\ttypedef std::map< std::string, FactoryFunctionPtr > ClassNameFactoryMap;\r\n\r\n\ttypedef void (*PubsubFunctionPtr)( RTI::RTIambassador * );\r\n\ttypedef std::map< std::string, PubsubFunctionPtr > ClassNamePubSubMap;\r\n\ttypedef std::map< std::string, std::string> DatamemberTypeMap;\r\n\t\r\n\t\r\n<% if(!isinteraction){ %>\r\n\ttypedef std::map< std::string, RTI::AttributeHandleSet * > ClassNameAttributesPtrMap;\r\n\ttypedef std::map< int, SP > ObjectMap;\r\n<%}%>\r\n\r\n\tstatic DatamemberTypeMap &getDatamemberTypeMap( void ) {\r\n\t\tstatic DatamemberTypeMap datamemberTypeMap;\r\n\t\treturn datamemberTypeMap;\r\n\t}\r\n\r\nprotected:\r\n\tstatic StringSet &getClassNameSet( void ) {\r\n\t\tstatic StringSet classNameSet;\r\n\t\treturn classNameSet;\r\n\t}\r\n\r\n\tstatic ClassNameFactoryMap &getClassNameFactoryMap( void ) {\r\n\t\tstatic ClassNameFactoryMap classNameFactoryMap;\r\n\t\treturn classNameFactoryMap;\r\n\t}\r\n\t\r\n\tstatic ClassNamePubSubMap &getClassNamePublishMap( void ) {\r\n\t\tstatic ClassNamePubSubMap classNamePublishMap;\r\n\t\treturn classNamePublishMap;\r\n\t}\r\n\r\n\tstatic ClassNamePubSubMap &getClassNameUnpublishMap( void ) {\r\n\t\tstatic ClassNamePubSubMap classNameUnpublishMap;\r\n\t\treturn classNameUnpublishMap;\r\n\t}\r\n\r\n\tstatic ClassNamePubSubMap &getClassNameSubscribeMap( void ) {\r\n\t\tstatic ClassNamePubSubMap classNameSubscribeMap;\r\n\t\treturn classNameSubscribeMap;\r\n\t}\r\n\r\n\tstatic ClassNamePubSubMap &getClassNameUnsubscribeMap( void ) {\r\n\t\tstatic ClassNamePubSubMap classNameUnsubscribeMap;\r\n\t\treturn classNameUnsubscribeMap;\r\n\t}\r\n\r\n\tstatic NameStringVectorPtrMap &getDatamemberClassNameVectorPtrMap( void ) {\r\n\t\tstatic NameStringVectorPtrMap datamemberClassNameVectorPtrMap;\r\n\t\treturn datamemberClassNameVectorPtrMap;\r\n\t}\r\n\r\n\tstatic NameStringVectorPtrMap &getAllDatamemberClassNameVectorPtrMap( void ) {\r\n\t\tstatic NameStringVectorPtrMap allDatamemberClassNameVectorPtrMap;\r\n\t\treturn allDatamemberClassNameVectorPtrMap;\r\n\t}\r\n\r\n\tstatic StringIntegerMap &getClassNameHandleMap( void ) {\r\n\t\tstatic StringIntegerMap classNameHandleMap;\r\n\t\treturn classNameHandleMap;\r\n\t}\r\n\tstatic IntegerStringMap &getClassHandleNameMap( void ) {\r\n\t\tstatic IntegerStringMap classHandleNameMap;\r\n\t\treturn classHandleNameMap;\r\n\t}\r\n\r\n\tstatic StringIntegerMap &getDatamemberNameHandleMap( void ) {\r\n\t\tstatic StringIntegerMap datamemberNameHandleMap;\r\n\t\treturn datamemberNameHandleMap;\r\n\t}\r\n\tstatic IntegerStringMap &getDatamemberHandleNameMap( void ) {\r\n\t\tstatic IntegerStringMap datamemberHandleNameMap;\r\n\t\treturn datamemberHandleNameMap;\r\n\t}\r\n\r\n<% if(!isinteraction){ %>\r\n\tstatic NameStringVectorPtrMap &getClassNamePublishAttributeNameVectorPtrMap( void ) {\r\n\t\tstatic NameStringVectorPtrMap classNamePublishAttributeNameVectorPtrMap;\r\n\t\treturn classNamePublishAttributeNameVectorPtrMap;\r\n\t}\r\n\tstatic NameStringVectorPtrMap &getClassNameSubscribeAttributeNameVectorPtrMap( void ) {\r\n\t\tstatic NameStringVectorPtrMap classNameSubscribeAttributeNameVectorPtrMap;\r\n\t\treturn classNameSubscribeAttributeNameVectorPtrMap;\r\n\t}\r\n\t\r\n\tstatic ClassNameAttributesPtrMap &getClassNamePublishedAttributesPtrMap( void ) {\r\n\t\tstatic ClassNameAttributesPtrMap classNamePublishedAttributesPtrMap;\r\n\t\treturn classNamePublishedAttributesPtrMap;\r\n\t}\r\n\tstatic ClassNameAttributesPtrMap &getClassNameSubscribedAttributesPtrMap( void ) {\r\n\t\tstatic ClassNameAttributesPtrMap classNameSubscribedAttributesPtrMap;\r\n\t\treturn classNameSubscribedAttributesPtrMap;\r\n\t}\r\n\r\n\tstatic ObjectMap &getObjectMap( void ) {\r\n\t\tstatic ObjectMap objectMap;\r\n\t\treturn objectMap;\r\n\t}\r\n\r\n\ttemplate< typename S, typename T >\r\n\tclass Attribute {\r\n\tprivate:\r\n\t\tT _value;\r\n\t\tT _oldValue;\r\n\t\tbool _oldValueInit;\r\n\t\tdouble _time;\r\n\t\r\n\tpublic:\r\n\t\t\r\n\t\tAttribute( void ) : _value( 0 ), _oldValueInit( false ), _time( -1 ) { }\r\n\t\t\r\n\t\tT getValue( void ) const { return _value; }\r\n\t\tvoid setValue( T value ) { _value = value; }\r\n\t\t\r\n\t\tdouble getTime( void ) { return _time; }\r\n\t\tvoid setTime( double time ) { _time = time; }\r\n\t\t\r\n\t\tvoid setHasBeenUpdated( void ) {\r\n\t\t\t_oldValue = _value;\r\n\t\t\t_oldValueInit = true;\r\n\t\t}\r\n\t\t\r\n\t\tbool shouldBeUpdated( bool force ) { return force || !_oldValueInit || _oldValue != _value; }\r\n\t};\r\n\r\n\ttemplate< typename S >\r\n\tclass Attribute< S, std::string > {\r\n\tprivate:\r\n\t\tstd::string _value;\r\n\t\tstd::string _oldValue;\r\n\t\tbool _oldValueInit;\r\n\t\tdouble _time;\r\n\t\r\n\tpublic:\r\n\t\t\r\n\t\tAttribute( void ) : _oldValueInit( false ), _time( -1 ) { }\r\n\t\t\r\n\t\tconst std::string &getValue( void ) const { return _value; }\r\n\t\tvoid setValue( const std::string &value ) { _value = value; }\r\n\t\t\r\n\t\tdouble getTime( void ) { return _time; }\r\n\t\tvoid setTime( double time ) { _time = time; }\r\n\t\t\r\n\t\tvoid setHasBeenUpdated( void ) {\r\n\t\t\t_oldValue = _value;\r\n\t\t\t_oldValueInit = true;\r\n\t\t}\r\n\t\t\r\n\t\tbool shouldBeUpdated( bool force ) { return force || !_oldValueInit || _oldValue != _value; }\r\n\t};\r\n\t\r\n<%}%>\r\n\t\r\n<% /*classcommon(classname=apMap.classfirstupper+\"Root\",hlaclassname=apMap.classfirstupper+\"Root\",...)*/ -%>\r\n<%- ejs.render(\r\n\tTEMPLATES[\"cpp/classcommon.hpp.ejs\"],{\r\n\t\tisinteraction: isinteraction,\r\n\t\tclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\r\n\t\tparentclassname: \"\",\r\n\t\thlaclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\r\n\t\tdatamembers: [],\r\n\t\talldatamembers: []\r\n}) %>\r\npublic:\r\n\tstatic StringSet get_<%=isinteraction?\"interaction\":\"object\"%>_names( void ) { return getClassNameSet(); }\r\n\tstatic StringVector get_<%=isinteraction?\"parameter\":\"attribute\"%>_names( const std::string &className ) {\r\n\t\tNameStringVectorPtrMap::iterator nssItr = getDatamemberClassNameVectorPtrMap().find( className );\r\n\t\treturn nssItr == getDatamemberClassNameVectorPtrMap().end() ? StringVector() : *nssItr->second;\r\n\t}\r\n\t\r\n\tstatic StringVector get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names( const std::string &className ) {\r\n\t\tNameStringVectorPtrMap::iterator nssItr = getAllDatamemberClassNameVectorPtrMap().find( className );\r\n\t\treturn nssItr == getAllDatamemberClassNameVectorPtrMap().end() ? StringVector() : *nssItr->second;\r\n\t}\r\n\t\r\n\tstatic std::string get_class_name( int classHandle ) {\r\n\t\tIntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\r\n\t\treturn ismItr == getClassHandleNameMap().end() ? std::string() : ismItr->second;\r\n\t}\r\n\t\r\n\tstatic int get_handle( const std::string &className ) {\r\n\t\r\n\t\tStringIntegerMap::iterator simItr = getClassNameHandleMap().find( className );\r\n\t\tif ( simItr == getClassNameHandleMap().end() ) {\r\n\t\t\tstd::cerr << \"Bad class name \\\"\" << className << \"\\\" on get_handle.\" << std::endl;\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\t\r\n\t\treturn simItr->second;\r\n\t}\r\n\t\r\n\tstatic std::string get_<%=isinteraction?\"parameter\":\"attribute\"%>_name( int datamemberHandle ) {\r\n\t\tIntegerStringMap::iterator ismItr = getDatamemberHandleNameMap().find( datamemberHandle );\r\n\t\treturn ismItr == getDatamemberHandleNameMap().end() ? std::string() : ismItr->second;\r\n\t}\r\n\t\r\n\tstatic int get_<%=isinteraction?\"parameter\":\"attribute\"%>_handle( const std::string &className, const std::string &datamemberName ) {\r\n\t\r\n\t\tStringIntegerMap::iterator simItr = getDatamemberNameHandleMap().find( className + \".\" + datamemberName );\r\n\t\tif ( simItr == getDatamemberNameHandleMap().end() ) {\r\n\t\t\tstd::cerr << \"Bad <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" << datamemberName << \"\\\" for class \\\"\" << className << \"\\\" on get_<%=isinteraction?\"parameter\":\"attribute\"%>_handle.\" << std::endl;\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\t\r\n\t\treturn simItr->second;\r\n\t}\r\n\t\r\n\tstatic void publish( const std::string &className, RTI::RTIambassador *rti ) {\r\n\t\tClassNamePubSubMap::iterator cpmItr = getClassNamePublishMap().find( className );\r\n\t\tif ( cpmItr == getClassNamePublishMap().end() ) {\r\n\t\t\tstd::cerr << \"Bad class name \\\"\" << className << \"\\\" on publish.\" << std::endl;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t(*cpmItr->second)( rti );\r\n\t}\r\n\t\r\n\tstatic void unpublish( const std::string &className, RTI::RTIambassador *rti ) {\r\n\t\tClassNamePubSubMap::iterator cpmItr = getClassNameUnpublishMap().find( className );\r\n\t\tif ( cpmItr == getClassNameUnpublishMap().end() ) {\r\n\t\t\tstd::cerr << \"Bad class name \\\"\" << className << \"\\\" on unpublish.\" << std::endl;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t(*cpmItr->second)( rti );\r\n\t}\r\n\t\r\n\tstatic void subscribe( const std::string &className, RTI::RTIambassador *rti ) {\r\n\t\tClassNamePubSubMap::iterator cpmItr = getClassNameSubscribeMap().find( className );\r\n\t\tif ( cpmItr == getClassNameSubscribeMap().end() ) {\r\n\t\t\tstd::cerr << \"Bad class name \\\"\" << className << \"\\\" on subscribe.\" << std::endl;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t(*cpmItr->second)( rti );\r\n\t}\r\n\t\r\n\tstatic void unsubscribe( const std::string &className, RTI::RTIambassador *rti ) {\r\n\t\tClassNamePubSubMap::iterator cpmItr = getClassNameUnsubscribeMap().find( className );\r\n\t\tif ( cpmItr == getClassNameSubscribeMap().end() ) {\r\n\t\t\tstd::cerr << \"Bad class name \\\"\" << className << \"\\\" on unsubscribe.\" << std::endl;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t(*cpmItr->second)( rti );\r\n\t}\r\n\r\n<% if(!isinteraction){ %>\r\n\tstatic void publish( const std::string &className, const std::string &attributeName );\r\n\t\r\n\tstatic void unpublish( const std::string &className, const std::string &attributeName ) {\r\n\t\tNameStringVectorPtrMap::iterator camItr = getClassNamePublishAttributeNameVectorPtrMap().find( className );\r\n\t\tif ( camItr == getClassNamePublishAttributeNameVectorPtrMap().end() ) {\r\n\t\t\tstd::cerr << \"ERROR:  ObjectRoot.unpublish:  could not unpublish class \\\"\" << className << \"\\\" \\\"\" << attributeName << \"\\\" attribute.\" << std::endl;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tcamItr->second->erase( std::remove( camItr->second->begin(), camItr->second->end(), attributeName ), camItr->second->end() );\r\n\t}\r\n\tstatic void subscribe( const std::string &className, const std::string &attributeName );\r\n\t\r\n\tstatic void unsubscribe( const std::string &className, const std::string &attributeName ) {\r\n\t\tNameStringVectorPtrMap::iterator camItr = getClassNameSubscribeAttributeNameVectorPtrMap().find( className );\r\n\t\tif ( camItr == getClassNameSubscribeAttributeNameVectorPtrMap().end() ) {\r\n\t\t\tstd::cerr << \"ERROR:  ObjectRoot.unsubscribe:  could not unsubscribe class \\\"\" << className << \"\\\" \\\"\" << attributeName << \"\\\" attribute.\" << std::endl;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tcamItr->second->erase( std::remove( camItr->second->begin(), camItr->second->end(), attributeName ), camItr->second->end() );\r\n\t}\r\n<%}%>\r\n\t\r\npublic:\r\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( const std::string &className ) {\r\n\t\tClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( className );\r\n\t\treturn cfmItr == getClassNameFactoryMap().end() ? SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 ) : (*cfmItr->second)();\r\n\t}\r\n\r\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( const std::string &className, const RTIfedTime &dlc13FedTime ) {\r\n\t\tClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( className );\r\n\t\tif ( cfmItr == getClassNameFactoryMap().end() ) {\r\n\t\t\treturn SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 );\r\n\t\t}\r\n\t\t\r\n\t\tSP sp = (*cfmItr->second)();\r\n\t\tsp->setTime( dlc13FedTime.getTime() );\r\n\t\treturn sp;\r\n\t}\r\n\r\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle ) {\r\n\t\tIntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\r\n\t\treturn ismItr == getClassHandleNameMap().end() ? SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 ) : create_<%=isinteraction?\"interaction\":\"object\"%>( ismItr->second );\r\n\t}\r\n\r\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, const RTIfedTime &dlc13FedTime ) {\r\n\t\tIntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\r\n\t\treturn ismItr == getClassHandleNameMap().end() ? SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 ) : create_<%=isinteraction?\"interaction\":\"object\"%>( ismItr->second, dlc13FedTime );\r\n\t}\r\n\r\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap );\r\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime );\r\n\r\n\tstatic StringVector get_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\r\n\t\treturn StringVector();\r\n\t}\r\n\r\n\tstatic StringVector get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\r\n\t\treturn StringVector();\r\n\t}\r\n\r\n<% if(!isinteraction){ %>\r\n    static SP discover( int class_handle, int object_handle ) {\r\n    \r\n    \tSP sp = create_object( class_handle );\r\n    \tif ( sp != 0 ) {\r\n    \t\tgetObjectMap().insert(  std::make_pair( object_handle, sp )  );\r\n    \t}\r\n    \treturn sp;\r\n    }\r\n    \r\n    static SP reflect( int object_handle, const RTI::AttributeHandleValuePairSet &datamemberMap ) {\r\n    \tObjectMap::iterator obmItr = getObjectMap().find( object_handle );\r\n    \tif ( obmItr == getObjectMap().end() ) {\r\n    \t\treturn SP( (ObjectRoot *)0 );\r\n    \t}\r\n    \t\r\n    \tSP sp = obmItr->second;\r\n    \tsp->setTime( -1 );\r\n\t\tsp->setAttributes( datamemberMap );\r\n    \treturn sp;\r\n    }\r\n\r\n    static SP reflect(\r\n     int object_handle,\r\n     const RTI::AttributeHandleValuePairSet &datamemberMap,\r\n     double theTime\r\n    ) {\r\n    \tObjectMap::iterator obmItr = getObjectMap().find( object_handle );\r\n    \tif ( obmItr == getObjectMap().end() ) {\r\n    \t\treturn SP( (ObjectRoot *)0 );\r\n    \t}\r\n    \t\r\n    \tSP sp = obmItr->second;\r\n    \tsp->setTime( theTime );\r\n\t\tsp->setAttributes( datamemberMap );\r\n    \treturn sp;\r\n    }\r\n\r\n\tvoid requestUpdate( RTI::RTIambassador *rti );\r\n\r\n\tstatic SP getObject( int object_handle ) {\r\n\t\tObjectMap::iterator obmItr = getObjectMap().find( object_handle );\r\n\t\treturn obmItr == getObjectMap().end() ? SP( (ObjectRoot *)0 ) : obmItr->second;\r\n\t}\r\n\t\t    \r\n    static SP removeObject( int object_handle ) {\r\n\t\tObjectMap::iterator obmItr = getObjectMap().find( object_handle );\r\n\t\tif ( obmItr == getObjectMap().end() ) {\r\n\t\t\treturn SP( (ObjectRoot *)0 );\r\n\t\t}\r\n\t\t\r\n\t\tSP sp = obmItr->second;\r\n        getObjectMap().erase( obmItr );\r\n        return sp;\r\n    }\r\n    \r\n\r\nprivate:\r\n    int _object_handle;\r\n\r\n    void setObjectHandle( int object_handle ) {\r\n        getObjectMap().erase( object_handle );\r\n        _object_handle = object_handle;\r\n        getObjectMap().insert(  std::make_pair( object_handle, this )  );\r\n    }\r\n\r\npublic:\r\n    int getObjectHandle( void ) const { return _object_handle; }\r\n\t\r\n<%}%>\r\n\r\nprivate:\r\n\tdouble _time;\r\n\tstatic C2WLogger* _logger;\r\n\r\npublic:\t\r\n\tdouble getTime( void ) { return _time; }\r\n\t\r\n\tvoid setTime( double time ) { _time = time; }\r\n\tvoid setTime( const RTIfedTime &dlc13FedTime ) {\r\n\t\tsetTime( dlc13FedTime.getTime() );\r\n\t}\r\n\r\n\t<%=isinteraction?\"Interaction\":\"Object\"%>Root( void ) : _time( -1 )<% if(!isinteraction){%>, _isRegistered( false )<%}%> { }\r\n\t\r\n\t<%=isinteraction?\"Interaction\":\"Object\"%>Root( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) : _time( -1 )<% if(!isinteraction){%>, _isRegistered( false )<%}%> {\r\n\t\tset<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\r\n\t}\r\n\r\n\r\n\t<%=isinteraction?\"Interaction\":\"Object\"%>Root( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime ) : _time( dlc13FedTime.getTime() )<% if(!isinteraction){%>, _isRegistered( false )<%}%> {\r\n\t\tset<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\r\n\t}\r\n\r\n\tstatic SP create( void ) { return SP( new <%=isinteraction?\"Interaction\":\"Object\"%>Root ); }\r\n\tstatic SP create( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) { return SP(  new <%=isinteraction?\"Interaction\":\"Object\"%>Root( datamemberMap )  ); }\r\n\tstatic SP create( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime ) {\r\n\t\treturn SP(  new <%=isinteraction?\"Interaction\":\"Object\"%>Root( datamemberMap, dlc13FedTime )  );\r\n\t}\r\n\t\r\n\r\n\tvirtual TypeMedley get<%=isinteraction?\"Parameter\":\"Attribute\"%>( const std::string &datamemberName ) const {\r\n\t\tthrow std::invalid_argument( getClassName() + \" class has no <%=isinteraction?\"parameter\":\"attribute\"%> named \\\"\" + datamemberName + \"\\\"\" );\r\n\t}\r\n\t\t\r\n\tvirtual TypeMedley get<%=isinteraction?\"Parameter\":\"Attribute\"%>( int datamemberHandle ) const {\r\n\t\tthrow std::invalid_argument(\r\n\t\t getClassName() + \" class has no <%=isinteraction?\"parameter\":\"attribute\"%> with handle (\" + boost::lexical_cast< std::string >( datamemberHandle ) + \")\"\r\n\t\t);\r\n\t}\r\n\t\t\r\n\tvoid set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap );\r\n\r\nprivate:\r\n\tvoid set<%=isinteraction?\"Parameter\":\"Attribute\"%>( RTI::Handle handle, const std::string &val ) {\r\n\t\tif (  !set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( handle, val )  ) {\r\n\t\t\tstd::cerr << \"set:  bad <%=isinteraction?\"parameter\":\"attribute\"%> handle in class \\\"\" + getClassName() + \"\\\"\" << std::endl;\r\n\t\t}\r\n\t}\r\n\r\npublic:\r\n\tvoid set<%=isinteraction?\"Parameter\":\"Attribute\"%>( const std::string &datamemberName, TypeMedley value ) {\r\n\t\tif (  !set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, value )  ) {\r\n\t\t\tstd::cerr << \"Error:  class \\\"\" << getClassName() << \"\\\":  invalid <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" + datamemberName + \"\\\"\" << std::endl;\r\n\t\t}\r\n\t}\r\n\r\nprotected:\r\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( int param_handle, const std::string &val ) {\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( const std::string &datamemberName, const std::string &value ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( const std::string &datamemberName, TypeMedley value ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvirtual <%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP createDatamemberHandleValuePairSet( RTI::ULong count<% if(!isinteraction){%>, bool force<%}%> ) {\r\n\t\treturn <%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP(  RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>SetFactory::create( count )  );\r\n\t}\r\n\t\r\n\tvirtual <%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP createDatamemberHandleValuePairSet( <% if(!isinteraction){%>bool force<%}%> ) {\r\n\t\treturn createDatamemberHandleValuePairSet( <% if(!isinteraction){%>force<%}%> );\r\n\t}\r\n\t\r\n<% if(isinteraction){ %>\r\npublic:\r\n\tvoid sendInteraction( RTI::RTIambassador *rti, double time );\r\n\tvoid sendInteraction( RTI::RTIambassador *rti );\r\n\r\nprivate:\r\n\tstatic std::string fedName;\r\n\t\r\npublic:\r\n\tstatic bool enablePubLog;\r\n\tstatic bool enableSubLog;\r\n\tstatic std::string pubLogLevel;\r\n\tstatic std::string subLogLevel;\t\r\n\r\npublic:\r\n\tstatic void enablePublishLog(const std::string &interaction, const std::string &fed, const std::string &thislevel, const std::string &globallevel);\r\n\tstatic void enableSubscribeLog(const std::string &interaction, const std::string &fed, const std::string &thislevel, const std::string &globallevel);\r\n\r\n\tvoid createLog( double time, bool isPub = true );\r\n\t\r\n<% }else{ %>\r\nprivate:\r\n    bool _isRegistered;\r\n\r\npublic:\r\n    void registerObject( RTI::RTIambassador *rti );\r\n\tvoid unregisterObject( RTI::RTIambassador *rti );\r\n\r\n    void updateAttributeValues( RTI::RTIambassador *rti, double time, bool force );\r\n\r\n    void updateAttributeValues( RTI::RTIambassador *rti, double time ) {\r\n    \tupdateAttributeValues( rti, time, false );\r\n    }\r\n\r\n    void updateAttributeValues( RTI::RTIambassador *rti, bool force );\r\n\r\n\tvoid updateAttributeValues( RTI::RTIambassador *rti ) {\r\n\t\tupdateAttributeValues( rti, false );\r\n\t}\r\n\r\nprivate:\r\n\tstatic std::string fedName;\r\n\t\r\npublic:\r\n\tstatic void enablePublishLog(const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel);\r\n\tstatic void enableSubscribeLog(const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel);\r\n\r\n\tstatic std::map<std::string, std::string> &getPubAttributeLogMap( void) {\r\n\t\tstatic std::map<std::string, std::string> pubAttributeLogMap;\r\n\t\treturn pubAttributeLogMap;\r\n\t}\r\n\r\n\tstatic std::map<std::string, std::string> &getSubAttributeLogMap( void) {\r\n\t\tstatic std::map<std::string, std::string> subAttributeLogMap;\r\n\t\treturn subAttributeLogMap;\r\n\t}\r\n\r\n\tvoid createLog( double time, bool isPub = true );\r\n\t\r\n<%}%>\r\n\r\n};\r\n\r\ntypedef <%=isinteraction?\"Interaction\":\"Object\"%>Root::SP <%=isinteraction?\"Interaction\":\"Object\"%>RootSP;\r\n\r\nstatic bool call_<%=isinteraction?\"Interaction\":\"Object\"%>Root_static_init = <%=isinteraction?\"Interaction\":\"Object\"%>Root::static_init();\r\n\r\nstd::ostream &operator<<( std::ostream &os, <%=isinteraction?\"Interaction\":\"Object\"%>Root::SP entitySP );\r\nstd::ostream &operator<<( std::ostream &os, const <%=isinteraction?\"Interaction\":\"Object\"%>Root &entity );\r\n#endif\r\n",
    "cpp/cppfedbase_pom.xml.ejs": "<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n  <modelVersion>4.0.0</modelVersion>\r\n<% if (parent){ %>\r\n  <parent>\r\n    <groupId><%=parent.groupId%></groupId>\r\n    <artifactId><%=parent.artifactId%></artifactId>\r\n    <version><%=parent.version%></version>\r\n  </parent>\r\n<%} -%>\r\n  <groupId><%=groupId%></groupId>\r\n  <artifactId><%=artifactId%></artifactId>\r\n  <version><%=version%></version>\r\n  <packaging><%=packaging%></packaging>\r\n  <name><%=name%></name>\r\n  <description><%=description%></description>\r\n\r\n<% if(projects && projects.length > 0){ %> \r\n    <modules>\r\n      <% projects.forEach(function(project){ %>\r\n      <module><%= project.directory ? project.directory : project.artifactId %></module><%}); %> \r\n    </modules>  \r\n<%}%>\r\n    <properties>\r\n        <boost.version>1.57.0+nar.10</boost.version>\r\n        <nar-plugin.version>3.3.0</nar-plugin.version>\r\n        <compiler-name>g++</compiler-name>\r\n        <linker-name>g++</linker-name>\r\n    </properties>\r\n\r\n    <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>com.github.maven-nar</groupId>\r\n                <artifactId>nar-maven-plugin</artifactId>\r\n                <version>${nar-plugin.version}</version>\r\n                <extensions>true</extensions>\r\n                <configuration>\r\n                    <libraries>\r\n                        <library> \r\n                            <type>static</type>\r\n                        </library>\r\n                    </libraries>\r\n                    <cpp>\r\n                        <name>${compiler-name}</name>\r\n                        <debug>false</debug>\r\n                        <includes>\r\n                            <include>**/*.hpp</include>\r\n                            <include>**/*.h</include>\r\n                            <include>**/*.cpp</include>\r\n                            <include>**/*.c</include>\r\n                        </includes>\r\n                        <options combine.children=\"append\">\r\n                            <!--option>-std=c++11</option-->\r\n                            <option>-ftemplate-depth-128</option>\r\n                            <option>-fno-inline</option>\r\n                            <option>-Wall</option>\r\n                            <option>-pedantic</option>\r\n                            <option>-Wno-long-long</option>\r\n                            <option>-Wno-variadic-macros</option>\r\n                        </options>\r\n                        <defines>\r\n                          <!--define>USE_MYSQL_LOGGING</define-->\r\n                          <define>RTI_USES_STD_FSTREAM</define>\r\n                        </defines>\r\n                        <systemIncludePaths>\r\n                          <systemIncludePath>${build.BOOST_INC_DIR}</systemIncludePath>\r\n                          <systemIncludePath>${build.RTI_INC_DIR}</systemIncludePath>\r\n                        </systemIncludePaths>\r\n                    </cpp>\r\n                    <linker>\r\n                        <name>${linker-name}</name>\r\n                        <incremental>false</incremental>\r\n                        <libs>\r\n                          <lib>\r\n                            <name>RTI-NG_64d</name>\r\n                            <type>shared</type>\r\n                            <directory>${build.RTI_LIB_DIR}</directory>\r\n                          </lib>\r\n                          <lib>\r\n                            <name>FedTime_64d</name>\r\n                            <type>shared</type>\r\n                            <directory>${build.RTI_LIB_DIR}</directory>\r\n                          </lib>\r\n                          <lib>\r\n                            <name>boost_thread</name>\r\n                            <type>shared</type>\r\n                            <directory>${build.BOOST_LIB_DIR}</directory>\r\n                          </lib>\r\n                          <lib>\r\n                            <name>boost_system</name>\r\n                            <type>shared</type>\r\n                            <directory>${build.BOOST_LIB_DIR}</directory>\r\n                          </lib>\r\n                          <lib>\r\n                            <name>mysqlcppconn</name>\r\n                            <type>shared</type>\r\n                            <directory>${build.MYSQL_LIB_DIR}</directory>\r\n                          </lib>\r\n                          <lib>\r\n                                <name>jvm</name>\r\n                                <type>shared</type>\r\n                                <directory>${build.RTI_LIB_JVM_DIR}</directory>\r\n                            </lib>\r\n                        </libs>\r\n                        \r\n                    </linker>\r\n                </configuration>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n\r\n\r\n    <profiles>\r\n        <profile>\r\n          <id>include-generated</id>\r\n          <activation>\r\n                <activeByDefault>false</activeByDefault>\r\n            </activation>\r\n          <modules>\r\n              <module>HelloWorld_base-cpp</module>   \r\n          </modules>  \r\n        </profile>\r\n\r\n        <profile>\r\n            <id>windows-common</id>\r\n            <activation>\r\n                <os>\r\n                    <family>windows</family>\r\n                </os>\r\n            </activation>\r\n            <properties>\r\n              <build.RTI_LIB_DIR>${env.RTI_LIB_DIR}</build.RTI_LIB_DIR>\r\n              <build.RTI_INC_DIR>${env.RTI_HOME}/include/hla13</build.RTI_INC_DIR>\r\n              <build.BOOST_INC_DIR>${env.BOOST_INC_DIR}</build.BOOST_INC_DIR>\r\n              <build.BOOST_LIB_DIR>${env.BOOST_LIB_DIR}</build.BOOST_LIB_DIR>\r\n              <build.MYSQL_LIB_DIR>${env.MYSQL_LIB_DIR}</build.MYSQL_LIB_DIR>\r\n            </properties>\r\n            <build>\r\n                <plugins>\r\n                    <plugin>\r\n                        <groupId>com.github.maven-nar</groupId>\r\n                        <artifactId>nar-maven-plugin</artifactId>\r\n                        <extensions>true</extensions>\r\n                        <configuration>\r\n                            <cpp>\r\n                                <options combine.children=\"append\">\r\n                                    <option>-mthreads</option>\r\n                                </options>\r\n                            </cpp>\r\n                        </configuration>\r\n                    </plugin>\r\n                </plugins>\r\n            </build>\r\n        </profile>\r\n\r\n        <profile>\r\n            <id>linux-common</id>\r\n            <activation>\r\n                <os>\r\n                    <family>linux</family>\r\n                </os>\r\n            </activation>\r\n            <properties>\r\n              <build.RTI_LIB_JVM_DIR>${env.RTI_HOME}/jre/lib/amd64/server</build.RTI_LIB_JVM_DIR>\r\n              <build.RTI_LIB_DIR>${env.RTI_HOME}/lib/gcc4</build.RTI_LIB_DIR>\r\n              <build.RTI_INC_DIR>${env.RTI_HOME}/include/hla13</build.RTI_INC_DIR>\r\n              <build.BOOST_INC_DIR>/usr/include/boost</build.BOOST_INC_DIR>\r\n              <build.BOOST_LIB_DIR>/usr/lib/x86_64-linux-gnu</build.BOOST_LIB_DIR>\r\n              <build.MYSQL_LIB_DIR>/usr/lib/</build.MYSQL_LIB_DIR>\r\n            </properties>\r\n            <build>\r\n                <plugins>\r\n                    <plugin>\r\n                        <groupId>com.github.maven-nar</groupId>\r\n                        <artifactId>nar-maven-plugin</artifactId>\r\n                        <extensions>true</extensions>\r\n                        <configuration>\r\n                            <cpp>\r\n                                <options combine.children=\"append\">\r\n                                    <option>-pthread</option>\r\n                                </options>\r\n                            </cpp>\r\n                        </configuration>\r\n                    </plugin>\r\n                </plugins>\r\n            </build>\r\n        </profile>\r\n\r\n        <profile>\r\n            <id>mac-common</id>\r\n            <activation>\r\n                <os>\r\n                    <family>mac</family>\r\n                </os>\r\n            </activation>\r\n            <properties>\r\n              <build.RTI_LIB_DIR>${env.RTI_LIB_DIR}</build.RTI_LIB_DIR>\r\n              <build.RTI_INC_DIR>${env.RTI_HOME}/include/hla13</build.RTI_INC_DIR>\r\n              <build.BOOST_INC_DIR>${env.BOOST_INC_DIR}</build.BOOST_INC_DIR>\r\n              <build.BOOST_LIB_DIR>${env.BOOST_LIB_DIR}</build.BOOST_LIB_DIR>\r\n              <build.MYSQL_LIB_DIR>${env.MYSQL_LIB_DIR}</build.MYSQL_LIB_DIR>\r\n            </properties>\r\n            <build>\r\n                <plugins>\r\n                    <plugin>\r\n                        <groupId>com.github.maven-nar</groupId>\r\n                        <artifactId>nar-maven-plugin</artifactId>\r\n                        <extensions>true</extensions>\r\n                        <configuration>\r\n                            <cpp>\r\n                                <options combine.children=\"append\">\r\n                                    <option>-pthread</option>\r\n                                </options>\r\n                            </cpp>\r\n                        </configuration>\r\n                    </plugin>\r\n                </plugins>\r\n            </build>\r\n        </profile>\r\n    </profiles>\r\n  \r\n</project>\r\n",
    "cpp/federate.hpp.ejs": "<%/* group cppfederate;\r\n\r\nfederate(\r\n\tsimname,\r\n\tclassname,\r\n\tisnonmapperfed,\r\n\ttimeconstrained,\r\n\ttimeregulating,\r\n\tlookahead,\r\n\tasynchronousdelivery,\r\n\tallinteractiondata,\r\n\tpublishedinteractiondata,\r\n\tsubscribedinteractiondata,\r\n\tallobjectdata,\r\n\tpublishedobjectdata,\r\n\tsubscribedobjectdata\r\n) ::= <<\r\n*/ -%>\r\n#ifndef _<%=classname%>Base_\r\n#define _<%=classname%>Base_\r\n\r\n#include <vector>\r\n\r\n#include \"SynchronizedFederate.hpp\"\r\n#include \"SubscribedInteractionFilter.hpp\"\r\n\r\n<% allinteractiondata.forEach(function(interactiondata){ %>\r\n#include \"<%=interactiondata.name%>.hpp\"<%});%>\r\n<% allobjectdata.forEach(function(interactiondata){ %>\r\n#include \"<%=interactiondata.name%>.hpp\"<%});%>\r\n#include \"C2WLogger.hpp\"\r\n\r\n#include \"FederateConfig.h\"\r\n\r\nclass <%=classname%>Base : public SynchronizedFederate {\r\n\r\npublic:\r\n\ttypedef SynchronizedFederate Super;\r\n\t\r\n\r\n\ttypedef std::vector< std::string > ArgVector;\r\n\t\r\n\tstatic double getLookAhead( void ) {\r\n\t\tstatic double lookAhead = <%=lookahead%>;\r\n\t\treturn lookAhead;\r\n\t}\r\n\r\n\tvirtual ~<%=classname%>Base( void )\r\n\t throw (RTI::FederateInternalError) { }\r\n\r\nprivate:\r\n\tSubscribedInteractionFilter _subscribedInteractionFilter;\r\n\r\nprotected:\r\n\tvoid init() {\r\n\r\n\t\tcreateRTI();\r\n\t\tjoinFederation();\r\n\t\t\r\n\t\t\t\t\t\r\n<% if(timeconstrained){ %>\r\n\t\tenableTimeConstrained();\r\n<%}%>\r\n\r\n<% if(timeregulating){ %>\r\n\t\tenableTimeRegulation( getLookAhead() );\r\n<%}%>\r\n\r\n<% if(asynchronousdelivery){ %>\r\n\t\tenableAsynchronousDelivery();\r\n<%}%>\r\n\r\n\r\n        // interaction pubsub\r\n        <% /*publishedinteractiondata:pubinter()*/ %>\r\n        <% publishedinteractiondata.forEach(function(interactiondata){ %>\r\n        <%=interactiondata.name%>::publish( getRTI() );<%});%>\r\n        <% /*subscribedinteractiondata:subinter()*/ %>  \r\n        <% subscribedinteractiondata.forEach(function(interactiondata){ %>  \r\n        <%=interactiondata.name%>::subscribe( getRTI() );\r\n\t\t_subscribedInteractionFilter.setFedFilters( <%=interactiondata.name%>::get_handle(), SubscribedInteractionFilter::<%=interactiondata.originFedFilter()%>, SubscribedInteractionFilter::<%=interactiondata.srcFedFilter()%> );<%});%>  \r\n\t\t\r\n\t\t// object pubsub\r\n        <% /*publishedobjectdata:pubobjectdata()*/ %>\r\n        <% publishedobjectdata.forEach(function(objectdata){ %>\r\n        <% objectdata.publishedAttributeData.forEach(function(attributedata){ %>\r\n        <%=objectdata.name%>::publish_<%=attributedata.name%>();<%});%>  \r\n        <%=objectdata.name%>::publish( getRTI() );<%});%>  \r\n\r\n        <% /*subscribedobjectdata:subobjectdata()*/ %> \r\n        <% subscribedobjectdata.forEach(function(objectdata){ %>\r\n        <% objectdata.subscribedAttributeData.forEach(function(attributedata){ %>\r\n        <%=objectdata.name%>::subscribe_<%=attributedata.name%>();<%});%> \r\n        <%=objectdata.name%>::subscribe( getRTI() );<%});%>  \r\n   \r\n        \r\n         // enable pubsub log\r\n         \r\n\r\n\t}\r\n\r\npublic:\t\r\n\t// constructor\t\r\n\t<%=classname%>Base(FederateConfig *fedconfig): Super(fedconfig) { init(); }\r\n\r\n\r\n\r\n\t<% /*publishedinteractiondata:create_interaction()*/ %>\r\n\t<% publishedinteractiondata.forEach(function(interactiondata){ %>\r\n\t<%=interactiondata.name%>SP create_<%=interactiondata.name%>( void ) {\r\n\t   <%=interactiondata.name%>SP interactionSP = <%=interactiondata.name%>::create();\r\n\t   interactionSP->set_sourceFed( getFederateId() );\r\n\t   interactionSP->set_originFed( getFederateId() );\r\n\t   return interactionSP;\r\n\t}<%});%>  \r\n\r\n    <% /*filter_interaction()*/ %>\r\n    virtual void receiveInteraction(\r\n\t RTI::InteractionClassHandle theInteraction,\r\n\t const RTI::ParameterHandleValuePairSet& theParameters,\r\n\t const RTI::FedTime& theTime,\r\n\t const char *theTag,\r\n\t RTI::EventRetractionHandle theHandle\r\n\t)\r\n\t throw ( RTI::InteractionClassNotKnown, RTI::InteractionParameterNotKnown, RTI::InvalidFederationTime, RTI::FederateInternalError) {\r\n\r\n\t\tif ( getMoreATRs() ) {\r\n\t\t\tInteractionRoot::SP interactionRootSP = InteractionRoot::create_interaction( theInteraction, theParameters, theTime );\r\n\t\t\tC2WInteractionRootSP c2wInteractionRootSP = boost::dynamic_pointer_cast< C2WInteractionRoot >( interactionRootSP );\r\n\t\t\tif ( c2wInteractionRootSP != 0 ) {\r\n\r\n\t            // Filter interaction if src/origin fed requirements (if any) are not met\r\n\t            if (  _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRootSP )  ) {\r\n\t            \treturn;\r\n\t            }\r\n\t        }\r\n\r\n\t        Super::receiveInteraction( theInteraction, theParameters, theTime, theTag, theHandle );\r\n\t    }\r\n\t}\r\n\r\n\tvirtual void receiveInteraction(\r\n\t RTI::InteractionClassHandle theInteraction,\r\n\t const RTI::ParameterHandleValuePairSet& theParameters,\r\n\t const char *theTag\r\n\t)\r\n\t throw ( RTI::InteractionClassNotKnown, RTI::InteractionParameterNotKnown, RTI::FederateInternalError) {\r\n\t\tif ( getMoreATRs() ) {\r\n\t\t\tInteractionRoot::SP interactionRootSP = InteractionRoot::create_interaction( theInteraction, theParameters );\r\n\t\t\tC2WInteractionRootSP c2wInteractionRootSP = boost::dynamic_pointer_cast< C2WInteractionRoot >( interactionRootSP );\r\n\t\t\tif ( c2wInteractionRootSP != 0 ) {\r\n\r\n\t            // Filter interaction if src/origin fed requirements (if any) are not met\r\n\t            if (  _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRootSP )  ) {\r\n\t            \treturn;\r\n\t            }\r\n\t        }\r\n\r\n\t\t\tSuper::receiveInteraction( theInteraction, theParameters, theTag );\r\n\t\t}\r\n\t}\r\n};\r\n\r\n#endif\r\n\r\n",
    "cpp/federateimpl.cpp.ejs": "<% /* federateimpl(classname) */ -%>\r\n#include \"<%=classname%>.hpp\"\r\n\r\nvoid <%=classname%>::initialize( void ) {\r\n    m_currentTime = 0;\r\n    \r\n    if (this->get_IsLateJoiner()) {\r\n        m_currentTime = getLBTS() - getLookAhead();\r\n        disableTimeRegulation();\r\n    }\r\n\r\n    <%=classname%>ATRCallback advanceTimeRequest(*this);\r\n    putAdvanceTimeRequest(m_currentTime, advanceTimeRequest);\r\n\r\n    if(!this->get_IsLateJoiner()){\r\n        readyToPopulate();\r\n<% if (publishedobjectdata.length > 0) { -%>\r\n        initObjectInstances();\r\n<% } -%>\r\n        readyToRun();\r\n    }\r\n<% if (publishedobjectdata.length > 0) { -%>\r\n    else {\r\n        initObjectInstances();\r\n    }\r\n<% } -%>\r\n}\r\n<% if (publishedobjectdata.length > 0) { -%>\r\n\r\nvoid <%=classname%>::initObjectInstances() {\r\n    // TODO register object instances and send initial values\r\n<% publishedobjectdata.forEach(function(object_data) { -%>\r\n    // v<%=object_data.name%>.registerObject(getRTI());\r\n<% }) -%>\r\n}\r\n<% } -%>\r\n<% if (subscribedobjectdata.length + subscribedinteractiondata.length > 0) { -%>\r\n\r\nvoid <%=classname%>::checkReceivedSubscriptions() {\r\n<% if (subscribedobjectdata.length > 0) { -%>\r\n\r\n    SynchronizedFederate::ObjectReflector objectReflector;\r\n    while(!(objectReflector = getNextObjectReflector()).isNull()) {\r\n        objectReflector.reflect();\r\n\r\n<% (subscribedobjectdata.sort(function(a, b){return b.fullName.length-a.fullName.length})).forEach(function(object_data){ -%>\r\n        boost::shared_ptr<<%=object_data.name%>> <%=object_data.name.toLowerCase()%>_ptr =\r\n                boost::dynamic_pointer_cast<<%=object_data.name%>>(objectReflector.getObjectRootSP());\r\n        if (<%=object_data.name.toLowerCase()%>_ptr != NULL) {\r\n            handleObjectClass(<%=object_data.name.toLowerCase()%>_ptr);\r\n            continue;\r\n        }\r\n<% }) -%>\r\n        std::cerr << \"unhandled object reflection \" << objectReflector.getObjectRootSP()->getClassName() << std::endl;\r\n    }\r\n<% } -%>\r\n<% if (subscribedinteractiondata.length > 0) { -%>\r\n\r\n    InteractionRoot::SP interactionRootSP;\r\n    while((interactionRootSP = getNextInteraction()) != 0) {\r\n<% (subscribedinteractiondata.sort(function(a, b){return b.fullName.length-a.fullName.length})).forEach(function(interaction_data){ -%>\r\n        boost::shared_ptr<<%=interaction_data.name%>> <%=interaction_data.name.toLowerCase()%>_ptr =\r\n                boost::dynamic_pointer_cast<<%=interaction_data.name%>>(interactionRootSP);\r\n        if (<%=interaction_data.name.toLowerCase()%>_ptr != NULL) {\r\n            handleInteractionClass(<%=interaction_data.name.toLowerCase()%>_ptr);\r\n            continue;\r\n        }\r\n<% }) -%>\r\n        std::cerr << \"unhandled interaction \" << interactionRootSP->getClassName() << std::endl;\r\n    }\r\n<% } -%>\r\n}\r\n<% } -%>\r\n\r\nvoid <%=classname%>::execute( void ) {\r\n<% if (subscribedobjectdata.length + subscribedinteractiondata.length > 0) { -%>\r\n    checkReceivedSubscriptions();\r\n<% } -%>\r\n<% if (publishedobjectdata.length > 0) { -%>\r\n\r\n    // TODO update registered object instances\r\n<% publishedobjectdata.forEach(function(object_data) { -%>\r\n\r\n<% object_data.parameters.forEach(function(parameter) { -%>\r\n    // v<%=object_data.name%>.set_<%=parameter.name%>(YOUR_VALUE_HERE);\r\n<% }) -%>\r\n    // v<%=object_data.name%>.updateAttributeValues(getRTI(), m_currentTime + getLookAhead());\r\n<% }) -%>\r\n<% } -%>\r\n<% if (publishedinteractiondata.length > 0) { -%>\r\n\r\n    // TODO send interactions\r\n<% publishedinteractiondata.forEach(function(interaction_data) { -%>\r\n\r\n    // <%=interaction_data.name%>SP v<%=interaction_data.name%> = create_<%=interaction_data.name%>();\r\n<% interaction_data.parameters.forEach(function(parameter) { -%>\r\n    // v<%=interaction_data.name%>->set_<%=parameter.name%>(YOUR_VALUE_HERE);\r\n<% }) -%>\r\n    // v<%=interaction_data.name%>->sendInteraction(getRTI(), m_currentTime + getLookAhead());\r\n<% }) -%>\r\n<% } -%>\r\n    \r\n    m_currentTime += 1;\r\n    <%=classname%>ATRCallback advanceTimeRequest(*this);\r\n    putAdvanceTimeRequest(m_currentTime, advanceTimeRequest);\r\n}\r\n<% subscribedobjectdata.forEach(function(object_data) { -%>\r\n\r\nvoid <%=classname%>::handleObjectClass(boost::shared_ptr<<%=object_data.name%>> object) {\r\n    // TODO implement how to handle received object update\r\n}\r\n<% }); -%>\r\n<% subscribedinteractiondata.forEach(function(interaction_data) { -%>\r\n\r\nvoid <%=classname%>::handleInteractionClass(boost::shared_ptr<<%=interaction_data.name%>> interaction) {\r\n    // TODO implement how to handle received interaction\r\n}\r\n<% }); -%>\r\n\r\nint main(int argc, char *argv[]) {\r\n    FederateConfigParser *configParser = new FederateConfigParser();\r\n    FederateConfig *config = configParser->parseArgs(argc, argv);\r\n\r\n    std::cout << \"Creating <%=classname%> instance\" << std::endl;\r\n    <%=classname%> federateInstance(config);\r\n    federateInstance.initialize();\r\n    std::cout << \"Running <%=classname%> instance\" << std::endl;\r\n    federateInstance.run();\r\n\r\n    return 0;\r\n}\r\n",
    "cpp/federateimpl.hpp.ejs": "<% /* federateimpl(classname) */ -%>\r\n#ifndef _<%=classname.toUpperCase()%>_CLASS\r\n#define _<%=classname.toUpperCase()%>_CLASS\r\n\r\n#include \"<%=classname%>Base.hpp\"\r\n#include \"FederateConfigParser.h\"\r\n#include \"FederateConfig.h\"\r\n\r\n\r\nclass <%=classname%> : public <%=classname%>Base {\r\n    private:\r\n        double m_currentTime;\r\n<% if (publishedobjectdata.length > 0) { -%>\r\n\r\n        // TODO declare all the published object instances\r\n<% publishedobjectdata.forEach(function(object_data) { -%>\r\n        // <%=object_data.name%> v<%=object_data.name%>;\r\n<% }) -%>\r\n\r\n        void initObjectInstances();\r\n<%} -%>\r\n<% subscribedobjectdata.forEach(function(object_data) { -%>\r\n\r\n        void handleObjectClass(boost::shared_ptr<<%=object_data.name%>> object);\r\n<% }); -%>\r\n<% subscribedinteractiondata.forEach(function(interaction_data) { -%>\r\n\r\n        void handleInteractionClass(boost::shared_ptr<<%=interaction_data.name%>> interaction);\r\n<% }); -%>\r\n\r\n<% if (subscribedobjectdata.length + subscribedinteractiondata.length > 0) { -%>\r\n        void checkReceivedSubscriptions();\r\n\r\n<% } -%>\r\n    public:\r\n        typedef <%=classname%>Base Super;\r\n\r\n        <%=classname%>(FederateConfig *configuration): Super(configuration) {}\r\n\r\n        virtual ~<%=classname%>( void ) throw (RTI::FederateInternalError) {}\r\n\r\n        class <%=classname%>ATRCallback : public ATRCallback {\r\n            private:\r\n                <%=classname%> &m_federateInstance;\r\n            public:\r\n                <%=classname%>ATRCallback(<%=classname%> &federateInstance): m_federateInstance(federateInstance) {}\r\n                \r\n                virtual void execute( void ) {\r\n                    m_federateInstance.execute();\r\n                }\r\n\r\n                virtual SP clone( void ) {\r\n                    return SP(new <%=classname%>ATRCallback(*this));\r\n                }\r\n        };\r\n\r\n        void initialize( void );\r\n        void execute( void );\r\n};\r\n\r\n#endif\r\n",
    "cpp/federate_ver.cpp.ejs": "#include <string>\r\n\r\nstatic const std::string _<%=simname%>_base_version_ = \"<%=version%>\";",
    "cpp/omnetfilter.cpp.ejs": "<% /*FilterInitSource( projectname, subscribedinteractiondata ) ::= << */ %>\r\n/*\r\n * Copyright (c) 2016, Institute for Software Integrated Systems, Vanderbilt University\r\n * All rights reserved.\r\n *\r\n * Permission to use, copy, modify, and distribute this software and its\r\n * documentation for any purpose, without fee, and without written agreement is\r\n * hereby granted, provided that the above copyright notice, the following\r\n * two paragraphs and the author appear in all copies of this software.\r\n *\r\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\r\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\r\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\r\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\r\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\r\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\r\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\r\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\r\n *\r\n * @author Himanshu Neema\r\n */\r\n\r\n#include \"<%=projectname%>FilterInit.h\"\r\n#include \"OmnetFOMInteractions.h\"\r\n//#include \"<%=projectname%>NonOmnetNonGenericSources.hpp\"\r\n\r\nvoid <%=projectname%>FilterInit::execute( SubscribedInteractionFilter &subscribedInteractionFilter ) {\r\n\t<% /*subscribedinteractiondata:initInteractionFilter()*/ %>\r\n\t<% subscribedinteractiondata.forEach(function(subscribedinteractiondata){%>\r\n\tsubscribedInteractionFilter.setFedFilters( <%=subscribedinteractiondata.name%>::get_handle(), SubscribedInteractionFilter::<%=subscribedinteractiondata.originFedFilter()%>, SubscribedInteractionFilter::<%=subscribedinteractiondata.srcFedFilter()%> );<%});%>\r\n\r\n}\r\n\r\nstatic bool init( void ) {\r\n    SubscribedInteractionFilter::get_singleton().setFilterInit( <%=projectname%>FilterInit::create() );\r\n    return true;\r\n}\r\n\r\nstatic bool static_init = init();\r\n\r\n\r\n",
    "cpp/omnetfilter.hpp.ejs": "<% /* FilterInitHeader( projectname, subscribedinteractiondata ) ::= << */ %>\r\n/*\r\n * Copyright (c) 2016, Institute for Software Integrated Systems, Vanderbilt University\r\n * All rights reserved.\r\n *\r\n * Permission to use, copy, modify, and distribute this software and its\r\n * documentation for any purpose, without fee, and without written agreement is\r\n * hereby granted, provided that the above copyright notice, the following\r\n * two paragraphs and the author appear in all copies of this software.\r\n *\r\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\r\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\r\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\r\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\r\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\r\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\r\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\r\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\r\n *\r\n * @author Himanshu Neema\r\n */\r\n#ifndef _ISIS_<%=projectname%>_H_\r\n#define _ISIS_<%=projectname%>_H_\r\n\r\n#include \"SubscribedInteractionFilter.hpp\"\r\n\r\nstruct <%=projectname%>FilterInit : public SubscribedInteractionFilter::FilterInit {\r\n    static SP create( void ) { return SP( new <%=projectname%>FilterInit() ); }\r\n\r\n    virtual void execute( SubscribedInteractionFilter &subscribedInteractionFilter );\r\n};\r\n\r\n#endif\r\n",
    "java/class.java.ejs": "<% /*class(isinteraction,simname,classname,parentclassname,hlaclassname,datamembers,alldatamembers,isc2winteractionroot) */ -%>\r\n\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\n\r\nimport org.apache.logging.log4j.LogManager;\r\nimport org.apache.logging.log4j.Logger;\r\nimport org.cpswt.utils.CpswtUtils;\r\n\r\n<% if(isinteraction){ -%>\r\nimport hla.rti.FederateNotExecutionMember;\r\nimport hla.rti.InteractionClassNotDefined;\r\nimport hla.rti.InteractionClassNotPublished;\r\nimport hla.rti.InteractionClassNotSubscribed;\r\nimport hla.rti.LogicalTime;\r\nimport hla.rti.NameNotFound;\r\nimport hla.rti.RTIambassador;\r\nimport hla.rti.ReceivedInteraction;\r\n<% } else { -%>\r\nimport hla.rti.AttributeHandleSet;\r\nimport hla.rti.FederateNotExecutionMember;\r\nimport hla.rti.LogicalTime;\r\nimport hla.rti.NameNotFound;\r\nimport hla.rti.ObjectClassNotDefined;\r\nimport hla.rti.ObjectClassNotPublished;\r\nimport hla.rti.ObjectClassNotSubscribed;\r\nimport hla.rti.RTIambassador;\r\nimport hla.rti.ReflectedAttributes;\r\nimport hla.rti.SuppliedAttributes;\r\n<% } -%>\r\n<% if(simname !== 'org.cpswt.hla'){ -%>\r\n\r\nimport org.cpswt.hla.*;\r\n<% } -%>\r\n\r\n/**\r\n* Implements <%=hlaclassname%>\r\n*/\r\npublic class <%=classname%> extends <%=parentclassname%> {\r\n\r\n    private static final Logger logger = LogManager.getLogger();\r\n\r\n    /**\r\n    * Creates an instance of the <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class with default <%=isinteraction?\"parameter\":\"attribute\"%> values.\r\n    */\r\n    public <%=classname%>() {}\r\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\r\n\r\n<% /*alldatamembers:handle()*/ -%>\r\n<% alldatamembers.forEach(function(datamember){ -%>\r\n    private static int _<%=datamember.name%>_handle;\r\n<% }); -%>\r\n<% } -%>\r\n\r\n<% /*classcommon(...)*/ -%>\r\n<%- ejs.render(TEMPLATES[\"java/classcommon.java.ejs\"],\r\n    {   isinteraction: isinteraction,\r\n        classname: classname,\r\n        parentclassname: parentclassname,\r\n        hlaclassname: hlaclassname,\r\n        datamembers: datamembers,\r\n        alldatamembers: alldatamembers\r\n}) -%>\r\n<% if(isc2winteractionroot){ -%>\r\n\r\n    @Override\r\n    public void sendInteraction( RTIambassador rti, double time ) {\r\n        if (  get_sourceFed() == null || \"\".equals( get_sourceFed() ) || get_originFed() == null || \"\".equals( get_originFed() )  ) {\r\n            throw new Exception( \"source and/or origin federate not specified.\" );\r\n        }\r\n        super.sendInteraction( rti, time );\r\n    }\r\n\r\n    @Override\r\n    public void sendInteraction( RTIambassador rti ) {\r\n        if (  get_sourceFed() == null || \"\".equals( get_sourceFed() ) || get_originFed() == null || \"\".equals( get_originFed() )  ) {\r\n            throw new Exception( \"source and/or origin federate not specified.\" );\r\n        }\r\n        super.sendInteraction( rti );\r\n    }\r\n<% } -%>\r\n<% if(isinteraction){ -%>\r\n<% if(datamembers && datamembers.length > 0){ -%>\r\n\r\n<% datamembers.forEach(function(parameter){ -%>\r\n<% /*datamembers:interactionmembers()*/ -%>\r\n    private <%=parameter.parameterType%> _<%=parameter.name%> = <%-helpers.initialvalue(parameter.parameterType)%>;\r\n<% }); -%>\r\n\r\n<% datamembers.forEach(function(parameter){ -%>\r\n<% /*datamembers:interactionsetters()*/ -%>\r\n    /**\r\n    * Set the value of the \"<%=parameter.name%>\" parameter to \"value\" for this parameter.\r\n    *\r\n    * @param value the new value for the \"<%=parameter.name%>\" parameter\r\n    */\r\n    public void set_<%=parameter.name%>( <%=parameter.parameterType%> value ) {\r\n        _<%=parameter.name%> = value;\r\n    }\r\n\r\n<% /*datamembers:interactiongetters()*/ -%>\r\n    /**\r\n    * Returns the value of the \"<%=parameter.name%>\" parameter of this interaction.\r\n    *\r\n    * @return the value of the \"<%=parameter.name%>\" parameter\r\n    */\r\n    public <%=parameter.parameterType%> get_<%=parameter.name%>() {\r\n        return _<%=parameter.name%>;\r\n    }\r\n<% }); -%>\r\n<% } -%>\r\n<% }else{ %>\r\n<% alldatamembers.forEach(function(attribute){ -%>\r\n\r\n<% /* alldatamembers:{ a |<publish(attribute=a)> } */ -%>\r\n    /**\r\n    * Publishes the \"<%=attribute.name%>\" attribute of the attribute's containing object\r\n    * class for a federate.\r\n    * Note:  This method only marks the \"<%=attribute.name%>\" attribute for publication.\r\n    * To actually publish the attribute, the federate must (re)publish its containing\r\n    * object class.\r\n    * (using &lt;objectClassName&gt;.publish( RTIambassador rti ) ).\r\n    */\r\n    public static void publish_<%=attribute.name%>() {\r\n        _publishAttributeNameSet.add( \"<%=attribute.name%>\" );\r\n    }\r\n\r\n    /**\r\n    * Unpublishes the \"<%=attribute.name%>\" attribute of the attribute's containing object\r\n    * class for a federate.\r\n    * Note:  This method only marks the \"<%=attribute.name%>\" attribute for unpublication.\r\n    * To actually publish the attribute, the federate must (re)publish its containing\r\n    * object class.\r\n    * (using &lt;objectClassName&gt;.publish( RTIambassador rti ) ).\r\n    */\r\n    public static void unpublish_<%=attribute.name%>() {\r\n        _publishAttributeNameSet.remove( \"<%=attribute.name%>\" );\r\n    }\r\n\r\n<% /* alldatamembers:{ a |<subscribe(attribute=a)> } */ -%>\r\n    /**\r\n    * Subscribes a federate to the \"<%=attribute.name%>\" attribute of the attribute's\r\n    * containing object class.\r\n    * Note:  This method only marks the \"<%=attribute.name%>\" attribute for subscription.\r\n    * To actually subscribe to the attribute, the federate must (re)subscribe to its\r\n    * containing object class.\r\n    * (using &lt;objectClassName&gt;.subscribe( RTIambassador rti ) ).\r\n    */\r\n    public static void subscribe_<%=attribute.name%>() {\r\n        _subscribeAttributeNameSet.add( \"<%=attribute.name%>\" );\r\n    }\r\n\r\n    /**\r\n    * Unsubscribes a federate from the \"<%=attribute.name%>\" attribute of the attribute's\r\n    * containing object class.\r\n    * Note:  This method only marks the \"<%=attribute.name%>\" attribute for unsubscription.\r\n    * To actually unsubscribe to the attribute, the federate must (re)subscribe to its\r\n    * containing object class.\r\n    * (using &lt;objectClassName&gt;.subscribe( RTIambassador rti ) ).\r\n    */\r\n    public static void unsubscribe_<%=attribute.name%>() {\r\n        _subscribeAttributeNameSet.remove( \"<%=attribute.name%>\" );\r\n    }\r\n<% }); -%>\r\n<% datamembers.forEach(function(datamember){ -%>\r\n\r\n<% /*datamembers:objectmembers()*/ -%>\r\n    protected Attribute< <%= helpers.primitive2object(datamember.parameterType) %> > _<%=datamember.name%> =\r\n            new Attribute< <%= helpers.primitive2object(datamember.parameterType) %> >(  new <%= helpers.primitive2object(datamember.parameterType)%>( <%-helpers.initialvalue(datamember.parameterType)%> )  );\r\n\r\n<% /*datamembers:objectsetters()*/ -%>\r\n    /**\r\n    * Set the value of the \"<%=datamember.name%>\" attribute to \"value\" for this object.\r\n    *\r\n    * @param value the new value for the \"<%=datamember.name%>\" attribute\r\n    */\r\n    public void set_<%=datamember.name%>( <%=datamember.parameterType%> value ) {\r\n        _<%=datamember.name%>.setValue( value );\r\n        _<%=datamember.name%>.setTime( getTime() );\r\n    }\r\n\r\n<% /*datamembers:objectgetters()*/ -%>\r\n    /**\r\n    * Returns the value of the \"<%=datamember.name%>\" attribute of this object.\r\n    *\r\n    * @return the value of the \"<%=datamember.name%>\" attribute\r\n    */\r\n    public <%=datamember.parameterType%> get_<%=datamember.name%>() {\r\n        return _<%=datamember.name%>.getValue();\r\n    }\r\n\r\n<% /*datamembers:objecttimegetters()*/ -%>\r\n    /**\r\n    * Returns the current timestamp of the \"<%=datamember.name%>\" attribute of this object.\r\n    *\r\n    * @return the current timestamp of the \"<%=datamember.name%>\" attribute\r\n    */\r\n    public double get_<%=datamember.name%>_time() {\r\n        return _<%=datamember.name%>.getTime();\r\n    }\r\n<% }); -%>\r\n<% } -%>\r\n\r\n    protected <%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, boolean initFlag ) {\r\n        super( datamemberMap, false );\r\n        if ( initFlag ) set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>s( datamemberMap );\r\n    }\r\n\r\n    protected <%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime, boolean initFlag ) {\r\n        super( datamemberMap, logicalTime, false );\r\n        if ( initFlag ) set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>s( datamemberMap );\r\n    }\r\n\r\n    /**\r\n    * Creates an instance of the <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class, using\r\n    * \"datamemberMap\" to initialize its <%=isinteraction?\"parameter\":\"attribute\"%> values.\r\n    * \"datamemberMap\" is usually acquired as an argument to an RTI federate\r\n    * callback method, such as \"receiveInteraction\".\r\n    *\r\n    * @param datamemberMap data structure containing initial values for the\r\n    * <%=isinteraction?\"parameter\":\"attribute\"%>s of this new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n    */\r\n    public <%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\r\n        this( datamemberMap, true );\r\n    }\r\n\r\n    /**\r\n    * Like {@link #<%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap )}, except this\r\n    * new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance is given a timestamp of\r\n    * \"logicalTime\".\r\n    *\r\n    * @param datamemberMap data structure containing initial values for the\r\n    * <%=isinteraction?\"parameter\":\"attribute\"%>s of this new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n    * @param logicalTime timestamp for this new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class\r\n    * instance\r\n    */\r\n    public <%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime ) {\r\n        this( datamemberMap, logicalTime, true );\r\n    }\r\n\r\n    /**\r\n    * Creates a new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance that is a duplicate\r\n    * of the instance referred to by <%=classname%>_var.\r\n    *\r\n    * @param <%=classname%>_var <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance of which\r\n    * this newly created <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance will be a\r\n    * duplicate\r\n    */\r\n    public <%=classname%>( <%=classname%> <%=classname%>_var ) {\r\n        super( <%=classname%>_var );\r\n<% if(datamembers && datamembers.length > 0){ -%>\r\n\r\n<% /*datamembers:{ d |<rticlasscopyvalue(classname=classname,datamember=d)>}*/ -%>\r\n<% datamembers.forEach(function(datamember){ -%>\r\n        set_<%=datamember.name%>( <%=classname%>_var.get_<%=datamember.name%>() );\r\n<% }); -%>\r\n<% } -%>\r\n    }\r\n<% if(datamembers && datamembers.length > 0){ -%>\r\n\r\n    /**\r\n    * Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose name is \"datamemberName\"\r\n    * for this <%=isinteraction?\"interaction\":\"object\"%>.\r\n    *\r\n    * @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be\r\n    * returned\r\n    * @return value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose name is \"datamemberName\"\r\n    * for this <%=isinteraction?\"interaction\":\"object\"%>\r\n    */\r\n    public Object get<%= isinteraction ? \"Parameter\" : \"Attribute\" %>( String datamemberName ) {\r\n<% /*first(datamembers):startgetbyname()*/ -%>\r\n<% /*rest(datamembers):continuegetbyname()*/ -%>\r\n<% for(var i = 0; i<datamembers.length; i++ ){ -%>\r\n        <%= i == 0  ? 'if' : 'else if'%> ( \"<%=datamembers[i].name%>\".equals(datamemberName) ) return <%=helpers.get(datamembers[i].parameterType, datamembers[i].name)%>;\r\n<% } -%>\r\n        else return super.get<%= isinteraction ? \"Parameter\" : \"Attribute\" %>( datamemberName );\r\n    }\r\n\r\n    protected boolean set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( String datamemberName, String val ) {\r\n        boolean retval = true;\r\n<% /*first(datamembers):startifstring()*/ -%>\r\n<% /*rest(datamembers):continueifstring()*/ -%>\r\n<% for(var i = 0; i<datamembers.length; i++ ){ -%>\r\n        <%= i == 0  ? 'if' : 'else if'%> ( \"<%=datamembers[i].name%>\".equals( datamemberName) ) set_<%=datamembers[i].name%>( <%=helpers.set(datamembers[i].parameterType)%> );\r\n<% } -%>\r\n        else retval = super.set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( datamemberName, val );\r\n\r\n        return retval;\r\n    }\r\n\r\n    protected boolean set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( String datamemberName, Object val ) {\r\n        boolean retval = true;\r\n<% /*first(datamembers):startifname()*/ -%>\r\n<% /*rest(datamembers):continueifname()*/ -%>\r\n<% for(var i = 0; i<datamembers.length; i++ ){ -%>\r\n        <%= i == 0  ? 'if' : 'else if'%> ( \"<%=datamembers[i].name%>\".equals( datamemberName) ) set_<%=datamembers[i].name%>( (<%= helpers.primitive2object(datamembers[i].parameterType)%>)val );\r\n<% } -%>\r\n        else retval = super.set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( datamemberName, val );\r\n\r\n        return retval;\r\n    }\r\n<% } -%>\r\n<% if(!isinteraction){ -%>\r\n\r\n    @Override\r\n    protected SuppliedAttributes createSuppliedDatamembers(boolean force) {\r\n        SuppliedAttributes datamembers = _factory.createSuppliedAttributes();\r\n <% alldatamembers.forEach(function(datamember){ -%>\r\n\r\n        if (_publishAttributeNameSet.contains(\"<%=datamember.name%>\") && _<%=datamember.name%>.shouldBeUpdated(force)) {\r\n            datamembers.add( getAttributeHandle(\"<%=datamember.name%>\"), getAttribute(\"<%=datamember.name%>\").toString().getBytes() );\r\n            _<%=datamember.name%>.setHasBeenUpdated();\r\n        }\r\n<% }); -%>\r\n\r\n        return datamembers;\r\n    }\r\n<% } -%>\r\n\r\n    public void copyFrom( Object object ) {\r\n        super.copyFrom( object );\r\n        if ( object instanceof <%=classname%> ) {\r\n            <%=classname%> data = (<%=classname%>)object;\r\n<% /*datamembers:copydatamember();separator = \"\\n\"*/ -%>\r\n<% datamembers.forEach(function(datamember){ -%>\r\n            _<%=datamember.name%> = data._<%=datamember.name%>;\r\n<% }); -%>\r\n        }\r\n    }\r\n}\r\n\r\n",
    "java/classcommon.java.ejs": "<% /*classcommon(isinteraction,classname,parentclassname,hlaclassname,datamembers,alldatamembers) */ -%>\r\n    private static boolean _isInitialized = false;\r\n\r\n    private static int _handle;\r\n\r\n    /**\r\n    * Returns the handle (RTI assigned) of the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\r\n    * Note: As this is a static method, it is NOT polymorphic, and so, if called on\r\n    * a reference will return the handle of the class pertaining to the reference,\r\n    * rather than the handle of the class for the instance referred to by the reference.\r\n    * For the polymorphic version of this method, use {@link #getClassHandle()}.\r\n    *\r\n    * @return the RTI assigned integer handle that represents this <%=isinteraction?\"interaction\":\"object\"%> class\r\n    */\r\n    public static int get_handle() {\r\n        return _handle;\r\n    }\r\n\r\n    /**\r\n    * Returns the fully-qualified (dot-delimited) name of the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\r\n    * Note: As this is a static method, it is NOT polymorphic, and so, if called on\r\n    * a reference will return the name of the class pertaining to the reference,\r\n    * rather than the name of the class for the instance referred to by the reference.\r\n    * For the polymorphic version of this method, use {@link #getClassName()}.\r\n    *\r\n    * @return the fully-qualified HLA class path for this <%=isinteraction?\"interaction\":\"object\"%> class\r\n    */\r\n    public static String get_class_name() {\r\n        return \"<%=hlaclassname%>\";\r\n    }\r\n\r\n    /**\r\n    * Returns the simple name (the last name in the dot-delimited fully-qualified\r\n    * class name) of the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\r\n    *\r\n    * @return the name of this <%=isinteraction?\"interaction\":\"object\"%> class\r\n    */\r\n    public static String get_simple_class_name() {\r\n        return \"<%= classname %>\";\r\n    }\r\n\r\n    private static Set< String > _datamemberNames = new HashSet< String >();\r\n    private static Set< String > _allDatamemberNames = new HashSet< String >();\r\n\r\n    /**\r\n    * Returns a set containing the names of all of the non-hidden <%=isinteraction?\"parameter\":\"attribute\"%>s in the\r\n    * <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\r\n    * Note: As this is a static method, it is NOT polymorphic, and so, if called on\r\n    * a reference will return a set of parameter names pertaining to the reference,\r\n    * rather than the parameter names of the class for the instance referred to by\r\n    * the reference.  For the polymorphic version of this method, use\r\n    * {@link #get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names()}.\r\n    *\r\n    * @return a modifiable set of the non-hidden <%=isinteraction?\"parameter\":\"attribute\"%> names for this <%=isinteraction?\"interaction\":\"object\"%> class\r\n    */\r\n    public static Set< String > get_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\r\n        return new HashSet< String >(_datamemberNames);\r\n    }\r\n\r\n    /**\r\n    * Returns a set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s in the\r\n    * <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\r\n    * Note: As this is a static method, it is NOT polymorphic, and so, if called on\r\n    * a reference will return a set of parameter names pertaining to the reference,\r\n    * rather than the parameter names of the class for the instance referred to by\r\n    * the reference.  For the polymorphic version of this method, use\r\n    * {@link #get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names()}.\r\n    *\r\n    * @return a modifiable set of the <%=isinteraction?\"parameter\":\"attribute\"%> names for this <%=isinteraction?\"interaction\":\"object\"%> class\r\n    */\r\n    public static Set< String > get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\r\n        return new HashSet< String >(_allDatamemberNames);\r\n    }\r\n<% if(!isinteraction){ -%>\r\n\r\n    private static Set< String > _publishAttributeNameSet = new HashSet< String >();\r\n    private static Set< String > _subscribeAttributeNameSet = new HashSet< String >();\r\n<% } -%>\r\n\r\n    static {\r\n        _classNameSet.add(\"<%= hlaclassname %>\");\r\n        _classNameClassMap.put(\"<%= hlaclassname %>\", <%= classname %>.class);\r\n\r\n        _datamemberClassNameSetMap.put(\"<%= hlaclassname %>\", _datamemberNames);\r\n        _allDatamemberClassNameSetMap.put(\"<%= hlaclassname %>\", _allDatamemberNames);\r\n<% if(datamembers && datamembers.length > 0){ -%>\r\n\r\n<% /*datamembers:initDatamemberNameSet()*/ -%>\r\n<% datamembers.forEach(function(datamember){ -%>\r\n<% if(!datamember.hidden && !datamember.inherited){ -%>\r\n        _datamemberNames.add(\"<%=datamember.name%>\");\r\n<% } -%>\r\n<% }); -%>\r\n\r\n<% /*datamembers:initDatamemberTypeMap()*/ -%>\r\n<% datamembers.forEach(function(datamember){ -%>\r\n        _datamemberTypeMap.put(\"<%=datamember.name%>\", \"<%=datamember.parameterType%>\");\r\n<% }); -%>\r\n<% } -%>\r\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\r\n\r\n<% /*alldatamembers:initAllDatamemberNameSet()*/ -%>\r\n<% alldatamembers.forEach(function(datamember){ -%>\r\n        _allDatamemberNames.add(\"<%=datamember.name%>\");\r\n<% }); -%>\r\n<% } -%>\r\n<% if(!isinteraction){ -%>\r\n\r\n        _classNamePublishAttributeNameMap.put(\"<%= hlaclassname %>\", _publishAttributeNameSet);\r\n        _classNameSubscribeAttributeNameMap.put(\"<%= hlaclassname %>\", _subscribeAttributeNameSet);\r\n<% } -%>\r\n    }\r\n\r\n    protected static void init(RTIambassador rti) {\r\n        if (_isInitialized) return;\r\n        _isInitialized = true;\r\n\r\n        <% if(parentclassname){ %><%=parentclassname%>.init(rti);<%}%>\r\n\r\n        boolean isNotInitialized = true;\r\n        while(isNotInitialized) {\r\n            try {\r\n                _handle = rti.get<%=isinteraction?\"Interaction\":\"Object\"%>ClassHandle(\"<%= hlaclassname %>\");\r\n                isNotInitialized = false;\r\n            } catch (FederateNotExecutionMember e) {\r\n                logger.error(\"could not initialize: Federate Not Execution Member\", e);\r\n                return;\r\n            } catch (NameNotFound e) {\r\n                logger.error(\"could not initialize: Name Not Found\", e);\r\n                return;\r\n            } catch (Exception e) {\r\n                logger.error(e);\r\n                CpswtUtils.sleepDefault();\r\n            }\r\n        }\r\n\r\n        _classNameHandleMap.put(\"<%= hlaclassname %>\", get_handle());\r\n        _classHandleNameMap.put(get_handle(), \"<%= hlaclassname %>\");\r\n        _classHandleSimpleNameMap.put(get_handle(), \"<%= classname %>\");\r\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\r\n\r\n        isNotInitialized = true;\r\n        while(isNotInitialized) {\r\n            try {\r\n<% /*alldatamembers:handle_init()*/ -%>\r\n<% alldatamembers.forEach(function(datamember){ -%>\r\n                _<%=datamember.name%>_handle = rti.get<%=isinteraction?\"Parameter\":\"Attribute\"%>Handle(\"<%=datamember.name%>\", get_handle());\r\n<% }); -%>\r\n                isNotInitialized = false;\r\n            } catch (FederateNotExecutionMember e) {\r\n                logger.error(\"could not initialize: Federate Not Execution Member\", e);\r\n                return;\r\n            } catch (<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined e) {\r\n                logger.error(\"could not initialize: <%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\", e);\r\n                return;\r\n            } catch (NameNotFound e) {\r\n                logger.error(\"could not initialize: Name Not Found\", e);\r\n                return;\r\n            } catch (Exception e) {\r\n                logger.error(e);\r\n                CpswtUtils.sleepDefault();\r\n            }\r\n        }\r\n\r\n<% /*alldatamembers: { d |<initDatamemberNameHandleMap(hlaclassname=hlaclassname,datamember=d)>}*/ -%>\r\n<% alldatamembers.forEach(function(datamember){ -%>\r\n        _datamemberNameHandleMap.put(\"<%=hlaclassname%>.<%=datamember.name%>\", _<%=datamember.name%>_handle);\r\n<% }); -%>\r\n\r\n<% /*alldatamembers:initDatamemberHandleNameMap()*/ -%>\r\n<% alldatamembers.forEach(function(datamember){ -%>\r\n        _datamemberHandleNameMap.put(_<%=datamember.name%>_handle, \"<%=datamember.name%>\");\r\n<% }); -%>\r\n<% } -%>\r\n    }\r\n\r\n    private static boolean _isPublished = false;\r\n\r\n    /**\r\n    * Publishes the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class for a federate.\r\n    *\r\n    * @param rti handle to the Local RTI Component\r\n    */\r\n    public static void publish(RTIambassador rti) {\r\n        if (_isPublished) return;\r\n\r\n        init(rti);\r\n<% if(!isinteraction){ -%>\r\n\r\n        AttributeHandleSet publishedAttributeHandleSet = _factory.createAttributeHandleSet();\r\n        for(String attributeName : _publishAttributeNameSet) {\r\n            try {\r\n                publishedAttributeHandleSet.add(_datamemberNameHandleMap.get(\"<%= hlaclassname %>.\" + attributeName));\r\n                logger.trace(\"publish {}:{}\", get_class_name(), attributeName);\r\n            } catch (Exception e) {\r\n                logger.error(\"could not publish \\\"\" + attributeName + \"\\\" attribute.\", e);\r\n            }\r\n        }\r\n<% } -%>\r\n\r\n        synchronized(rti) {\r\n            boolean isNotPublished = true;\r\n            while(isNotPublished) {\r\n                try {\r\n                    rti.publish<%=isinteraction?\"Interaction\":\"Object\"%>Class(get_handle()<% if(!isinteraction){ %>, publishedAttributeHandleSet<%}%>);\r\n                    isNotPublished = false;\r\n                } catch (FederateNotExecutionMember e) {\r\n                    logger.error(\"could not publish: Federate Not Execution Member\", e);\r\n                    return;\r\n                } catch (<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined e) {\r\n                    logger.error(\"could not publish: <%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\", e);\r\n                    return;\r\n                } catch (Exception e) {\r\n                    logger.error(e);\r\n                    CpswtUtils.sleepDefault();\r\n                }\r\n            }\r\n        }\r\n\r\n        _isPublished = true;\r\n        logger.debug(\"publish: {}\", get_class_name());\r\n    }\r\n\r\n    /**\r\n    * Unpublishes the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class for a federate.\r\n    *\r\n    * @param rti handle to the Local RTI Component\r\n    */\r\n    public static void unpublish(RTIambassador rti) {\r\n        if (!_isPublished) return;\r\n\r\n        init(rti);\r\n\r\n        synchronized(rti) {\r\n            boolean isNotUnpublished = true;\r\n            while(isNotUnpublished) {\r\n                try {\r\n                    rti.unpublish<%=isinteraction?\"Interaction\":\"Object\"%>Class(get_handle());\r\n                    isNotUnpublished = false;\r\n                } catch (FederateNotExecutionMember e) {\r\n                    logger.error(\"could not unpublish: Federate Not Execution Member\", e);\r\n                    return;\r\n                } catch (<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined e) {\r\n                    logger.error(\"could not unpublish: <%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\", e);\r\n                    return;\r\n                } catch (<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotPublished e) {\r\n                    logger.error(\"could not unpublish: <%=isinteraction?\"Interaction\":\"Object\"%> Class Not Published\", e);\r\n                    return;\r\n                } catch (Exception e) {\r\n                    logger.error(e);\r\n                    CpswtUtils.sleepDefault();\r\n                }\r\n            }\r\n        }\r\n\r\n        _isPublished = false;\r\n        logger.debug(\"unpublish: {}\", get_class_name());\r\n    }\r\n\r\n    private static boolean _isSubscribed = false;\r\n\r\n    /**\r\n    * Subscribes a federate to the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\r\n    *\r\n    * @param rti handle to the Local RTI Component\r\n    */\r\n    public static void subscribe(RTIambassador rti) {\r\n        if (_isSubscribed) return;\r\n\r\n        init(rti);\r\n<% if(!isinteraction){ -%>\r\n\r\n        AttributeHandleSet subscribedAttributeHandleSet = _factory.createAttributeHandleSet();\r\n        for(String attributeName : _subscribeAttributeNameSet) {\r\n            try {\r\n                subscribedAttributeHandleSet.add(_datamemberNameHandleMap.get(\"<%= hlaclassname %>.\" + attributeName));\r\n                logger.trace(\"subscribe {}:{}\", get_class_name(), attributeName);\r\n            } catch (Exception e) {\r\n                logger.error(\"could not subscribe to \\\"\" + attributeName + \"\\\" attribute.\", e);\r\n            }\r\n        }\r\n<% } -%>\r\n\r\n        synchronized(rti) {\r\n            boolean isNotSubscribed = true;\r\n            while(isNotSubscribed) {\r\n                try {\r\n                    rti.subscribe<% if(isinteraction){ %>InteractionClass(get_handle())<% }else{ %>ObjectClassAttributes(get_handle(), subscribedAttributeHandleSet)<%}%>;\r\n                    isNotSubscribed = false;\r\n                } catch (FederateNotExecutionMember e) {\r\n                    logger.error(\"could not subscribe: Federate Not Execution Member\", e);\r\n                    return;\r\n                } catch (<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined e) {\r\n                    logger.error(\"could not subscribe: <%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\", e);\r\n                    return;\r\n                } catch (Exception e) {\r\n                    logger.error(e);\r\n                    CpswtUtils.sleepDefault();\r\n                }\r\n            }\r\n        }\r\n\r\n        _isSubscribed = true;\r\n        logger.debug(\"subscribe: {}\", get_class_name());\r\n    }\r\n\r\n    /**\r\n    * Unsubscribes a federate from the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\r\n    *\r\n    * @param rti handle to the Local RTI Component\r\n    */\r\n    public static void unsubscribe(RTIambassador rti) {\r\n        if (!_isSubscribed) return;\r\n\r\n        init(rti);\r\n\r\n        synchronized(rti) {\r\n            boolean isNotUnsubscribed = true;\r\n            while(isNotUnsubscribed) {\r\n                try {\r\n                    rti.unsubscribe<%=isinteraction?\"Interaction\":\"Object\"%>Class(get_handle());\r\n                    isNotUnsubscribed = false;\r\n                } catch (FederateNotExecutionMember e) {\r\n                    logger.error(\"could not unsubscribe: Federate Not Execution Member\", e);\r\n                    return;\r\n                } catch (<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined e) {\r\n                    logger.error(\"could not unsubscribe: <%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\", e);\r\n                    return;\r\n                } catch (<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotSubscribed e) {\r\n                    logger.error(\"could not unsubscribe: <%=isinteraction?\"Interaction\":\"Object\"%> Class Not Subscribed\", e);\r\n                    return;\r\n                } catch (Exception e) {\r\n                    logger.error(e);\r\n                    CpswtUtils.sleepDefault();\r\n                }\r\n            }\r\n        }\r\n\r\n        _isSubscribed = false;\r\n        logger.debug(\"unsubscribe: {}\", get_class_name());\r\n    }\r\n\r\n    /**\r\n    * Return true if \"handle\" is equal to the handle (RTI assigned) of this class\r\n    * (that is, the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class).\r\n    *\r\n    * @param handle handle to compare to the value of the handle (RTI assigned) of\r\n    * this class (the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class).\r\n    * @return \"true\" if \"handle\" matches the value of the handle of this class\r\n    * (that is, the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class).\r\n    */\r\n    public static boolean match(int handle) {\r\n        return handle == get_handle();\r\n    }\r\n\r\n    /**\r\n    * Returns the handle (RTI assigned) of this instance's <%=isinteraction?\"interaction\":\"object\"%> class .\r\n    *\r\n    * @return the handle (RTI assigned) if this instance's <%=isinteraction?\"interaction\":\"object\"%> class\r\n    */\r\n    public int getClassHandle() {\r\n        return get_handle();\r\n    }\r\n\r\n    /**\r\n    * Returns the fully-qualified (dot-delimited) name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class.\r\n    *\r\n    * @return the fully-qualified (dot-delimited) name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class\r\n    */\r\n    public String getClassName() {\r\n        return get_class_name();\r\n    }\r\n\r\n    /**\r\n    * Returns the simple name (last name in its fully-qualified dot-delimited name)\r\n    * of this instance's <%=isinteraction?\"interaction\":\"object\"%> class.\r\n    *\r\n    * @return the simple name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class\r\n    */\r\n    public String getSimpleClassName() {\r\n        return get_simple_class_name();\r\n    }\r\n\r\n    /**\r\n    * Returns a set containing the names of all of the non-hidden<%=isinteraction?\"parameter\":\"attribute\"%>s of an\r\n    * <%=isinteraction?\"interaction\":\"object\"%> class instance.\r\n    *\r\n    * @return set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\r\n    * <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n    */\r\n    public Set< String > get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names() {\r\n        return get_<%=isinteraction?\"parameter\":\"attribute\"%>_names();\r\n    }\r\n\r\n    /**\r\n    * Returns a set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\r\n    * <%=isinteraction?\"interaction\":\"object\"%> class instance.\r\n    *\r\n    * @return set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\r\n    * <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n    */\r\n    public Set< String > getAll<%=isinteraction?\"Parameter\":\"Attribute\"%>Names() {\r\n        return get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names();\r\n    }\r\n<% if(alldatamembers && alldatamembers.length > 0){ -%>\r\n\r\n    @Override\r\n    public String get<%=isinteraction?\"Parameter\":\"Attribute\"%>Name(int datamemberHandle) {\r\n<% for(var i = 0; i<alldatamembers.length; i++ ){ -%>\r\n        <%= i == 0 ? 'if' : 'else if'%> (datamemberHandle == _<%=alldatamembers[i].name%>_handle) return \"<%=alldatamembers[i].name%>\";\r\n<% } -%>\r\n        else return super.get<%=isinteraction?\"Parameter\":\"Attribute\"%>Name(datamemberHandle);\r\n    }\r\n<% } -%>\r\n\r\n    /**\r\n    * Publishes the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of the class for a federate.\r\n    *\r\n    * @param rti handle to the Local RTI Component\r\n    */\r\n    public void publish<%=isinteraction?\"Interaction\":\"Object\"%>(RTIambassador rti) {\r\n        publish(rti);\r\n    }\r\n\r\n    /**\r\n    * Unpublishes the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class for a federate.\r\n    *\r\n    * @param rti handle to the Local RTI Component\r\n    */\r\n    public void unpublish<%=isinteraction?\"Interaction\":\"Object\"%>(RTIambassador rti) {\r\n        unpublish(rti);\r\n    }\r\n\r\n    /**\r\n    * Subscribes a federate to the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class.\r\n    *\r\n    * @param rti handle to the Local RTI Component\r\n    */\r\n    public void subscribe<%=isinteraction?\"Interaction\":\"Object\"%>(RTIambassador rti) {\r\n        subscribe(rti);\r\n    }\r\n\r\n    /**\r\n    * Unsubscribes a federate from the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class.\r\n    *\r\n    * @param rti handle to the Local RTI Component\r\n    */\r\n    public void unsubscribe<%=isinteraction?\"Interaction\":\"Object\"%>(RTIambassador rti) {\r\n        unsubscribe(rti);\r\n    }\r\n\r\n    @Override\r\n    public String toString() {\r\n        return getClass().getName() + \"(\"\r\n<% /*alldatamembers:stringValue(); separator=\"+ \\\",\\\"\"*/ -%>\r\n<% var separator = false; alldatamembers.forEach(function(datamember){ -%>\r\n                <%if(separator){%>+ \",\" <%}else{separator=true;}%>+ \"<%=datamember.name%>:\" + get_<%=datamember.name%>()\r\n<% }); -%>\r\n                + \")\";\r\n    }\r\n",
    "java/classroot.java.ejs": "\r\n\r\n// This code has been generated by the C2W code generator.\r\n// Do not edit manually!\r\n\r\n<%/* THIS IS THE ROOT CLASS OF EITHER THE INTERACTION OR OBJECT-CLASS HEIRARCHY (I.E. \"InteractionRoot\" OR \"ObjectRoot\") */%>\r\n<%/*classroot(isinteraction)*/%>\r\n\r\n/*\r\n * Copyright (c) 2016, Institute for Software Integrated Systems, Vanderbilt University\r\n * All rights reserved.\r\n *\r\n * Permission to use, copy, modify, and distribute this software and its\r\n * documentation for any purpose, without fee, and without written agreement is\r\n * hereby granted, provided that the above copyright notice, the following\r\n * two paragraphs and the author appear in all copies of this software.\r\n *\r\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\r\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\r\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\r\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\r\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\r\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\r\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\r\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\r\n *\r\n * @author Himanshu Neema\r\n */\r\n\r\npackage org.cpswt.hla;\r\n\r\nimport hla.rti.*;\r\nimport hla.rti.jlc.RtiFactory;\r\nimport hla.rti.jlc.RtiFactoryFactory;\r\n\r\nimport java.lang.reflect.Method;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n<% if(isinteraction){%>import java.util.concurrent.LinkedBlockingQueue;<%}%>\r\n\r\nimport org.portico.impl.hla13.types.DoubleTime;\r\n\r\n/**\r\n * <%=isinteraction?\"Interaction\":\"Object\"%>Root is the base class for all <%=isinteraction?\"interaction\":\"object\"%>s\r\n * defined in a given federation.  As such, an <%=isinteraction?\"Interaction\":\"Object\"%>Root\r\n * variable may refer to any type of interaction defined in the\r\n * federation.\r\n * <p/>\r\n * This <%=isinteraction?\"Interaction\":\"Object\"%>Root class provides the following:\r\n * - methods for constructing any <%=isinteraction?\"interaction\":\"object\"%> in the federation, either from\r\n * data provided by the RTI (for example, see\r\n * {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle )} or from a string argument\r\n * specifying the name of <%=isinteraction?\"interaction\":\"object\"%> to construct (see\r\n * {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( String className )}.\r\n * - methods for sending <% if(isinteraction){ %>an interaction<%}else{%>object updates<%}%> to the RTI (see\r\n * {@link <% if(isinteraction){ %>#sendInteraction( RTIambassador rti )<%}else{%>#updateAttributeValues( RTIambassador rti )<%}%>} for an example).\r\n * - methods for publishing/subscribing to any <% if(isinteraction){ %>interaction<%}else{%>object/object attribute<%}%> \r\n * defined in the federation (see\r\n * {@link #publish( String className, RTIambassador rti )} for example).\r\n * - methods for getting/setting any <%=isinteraction?\"parameter\":\"attribute\"%> in the <%=isinteraction?\"interaction\":\"object\"%> to\r\n * which a given <%=isinteraction?\"Interaction\":\"Object\"%>Root variable is referring\r\n * (see {@link #get<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName )} and\r\n * {@link #set<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName, Object value )}\r\n */\r\npublic class <%=isinteraction?\"Interaction\":\"Object\"%>Root implements <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface {\r\n\r\n\tprivate static int logId = 0;\r\n\tprivate static int _globalUniqueID = 0;\r\n\t\r\n\tprivate static int generateUniqueID() {\r\n\t\treturn _globalUniqueID++;\r\n\t}\r\n\t\r\n\tprivate int _uniqueID;\r\n\t\r\n\tpublic int getUniqueID() { return _uniqueID; }\r\n\t\r\n\tprotected static RtiFactory _factory;\r\n\tstatic {\r\n\t\tboolean factoryNotAcquired = true;\r\n\t\twhile( factoryNotAcquired ) {\r\n\t\t\ttry {\r\n\t\t\t\t_factory = RtiFactoryFactory.getRtiFactory( \"org.portico.dlc.HLA13RTIFactory\" );\r\n\t\t\t\tfactoryNotAcquired = false;\r\n\t\t\t} catch ( Exception e ) {\r\n\t\t\t\tSystem.err.println( \"ERROR: acquiring factory\" );\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t\ttry { Thread.sleep( 100 ); } catch ( Exception e1 ) { }\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprotected static Set< String > _classNameSet = new HashSet< String >();\r\n\tprotected static Map< String, Class<?> > _classNameClassMap = new HashMap< String, Class<?> >();\r\n\tprotected static Map<  String, Set< String >  > _datamemberClassNameSetMap = new HashMap<  String, Set< String >  >();\r\n\tprotected static Map<  String, Set< String >  > _allDatamemberClassNameSetMap = new HashMap<  String, Set< String >  >();\r\n\r\n\tprotected static Map< String, Integer > _classNameHandleMap = new HashMap< String, Integer >();\r\n\tprotected static Map< Integer, String > _classHandleNameMap = new HashMap< Integer, String >();\r\n\tprotected static Map< Integer, String > _classHandleSimpleNameMap = new HashMap< Integer, String >();\r\n\t\r\n\tprotected static Map< String, Integer > _datamemberNameHandleMap = new HashMap< String, Integer >();\r\n\tprotected static Map< Integer, String > _datamemberHandleNameMap = new HashMap< Integer, String >();\r\n\tprotected static Map< String, String > _datamemberTypeMap = new HashMap< String, String >();\r\n\r\n<% if(isinteraction){ %><%}else{%>\r\n\tprotected static Map<  String, Set< String >  > _classNamePublishAttributeNameMap = new HashMap<  String, Set< String >  >();\r\n\tprotected static Map<  String, Set< String >  > _classNameSubscribeAttributeNameMap = new HashMap<  String, Set< String >  >();\r\n\r\n\tprotected static Map< String, AttributeHandleSet > _classNamePublishedAttributeMap = new HashMap< String, AttributeHandleSet >();\r\n\tprotected static Map< String, AttributeHandleSet > _classNameSubscribedAttributeMap = new HashMap< String, AttributeHandleSet >();\r\n\t\r\n    private static Map< Integer, ObjectRoot > _objectMap = new HashMap< Integer, ObjectRoot >();\r\n\r\n\tprotected static class Attribute<T> {                                                                                 // NOMELD\r\n\t\tprivate T _value = null;                                                                                           // NOMELD\r\n\t\tprivate T _oldValue = null;                                                                                        // NOMELD\r\n\t\tprivate boolean _oldValueInit = false;                                                                             // NOMELD\r\n\t\tprivate double _time = 0;                                                                                          // NOMELD\r\n                                                                                                                           // NOMELD\r\n\t\tpublic Attribute( T init ) {                                                                                       // NOMELD\r\n\t\t\t_value = init;                                                                                                 // NOMELD\r\n\t\t}                                                                                                                  // NOMELD\r\n\t\t                                                                                                                   // NOMELD\r\n\t\tpublic T getValue() { return _value; }                                                                             // NOMELD\r\n\t\tpublic void setValue( T value ) {                                                                                  // NOMELD\r\n\t\t\tif ( value == null ) return;                                                                                   // NOMELD\r\n\t\t\t_value = value;                                                                                                // NOMELD\r\n\t\t}                                                                                                                  // NOMELD\r\n\t\t                                                                                                                   // NOMELD\r\n\t\tpublic double getTime() { return _time; }                                                                          // NOMELD\r\n\t\tpublic void setTime( double time ) { _time = time; }                                                               // NOMELD\r\n\t\t                                                                                                                   // NOMELD\r\n\t\tpublic void setHasBeenUpdated() {                                                                                  // NOMELD\r\n\t\t\t_oldValue = _value;                                                                                            // NOMELD\r\n\t\t\t_oldValueInit = true;                                                                                          // NOMELD\r\n\t\t}                                                                                                                  // NOMELD\r\n\t\t                                                                                                                   // NOMELD\r\n\t\tpublic boolean shouldBeUpdated( boolean force ) { return force || !_oldValueInit || !_oldValue.equals( _value ); } // NOMELD\t\t\r\n\t}                                                                                                                      // NOMELD\r\n<%}%>\t\r\n\t\r\n\t<% /*classcommon(classname=%=isinteraction?\"Interaction\":\"Object\"%+\"Root\",hlaclassname=%=isinteraction?\"Interaction\":\"Object\"%+\"Root\",...)*/ %>\r\n\t<%- ejs.render(TEMPLATES[\"java/classcommon.java.ejs\"],\r\n\t\t{\r\n\t\t\tisinteraction: isinteraction,\r\n\t\t\tclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\r\n\t\t\tparentclassname: \"\",\r\n\t\t\thlaclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\r\n\t\t\tdatamembers: [],\r\n\t\t\talldatamembers: []\r\n\t}) %>\r\n\t/**\r\n\t* Returns a set of strings containing the names of all of the <%=isinteraction?\"interaction\":\"object\"%>\r\n\t* classes in the current federation.\r\n\t*\r\n\t* @return Set< String > containing the names of all <%=isinteraction?\"interaction\":\"object\"%> classes\r\n\t* in the current federation\r\n\t*/\r\n\tpublic static Set< String > get_<%=isinteraction?\"interaction\":\"object\"%>_names() { return new HashSet< String >( _classNameSet ); }\r\n\r\n\t/**\r\n\t* Returns a set of strings containing the names of all of the non-hidden <%=isinteraction?\"parameter\":\"attribute\"%>s\r\n\t* in the <%=isinteraction?\"interaction\":\"object\"%> class specified by className.\r\n\t*\r\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class for which to retrieve the\r\n\t* names of all of its <%=isinteraction?\"parameter\":\"attribute\"%>s\r\n\t* @return Set< String > containing the names of all <%=isinteraction?\"parameter\":\"attribute\"%>s in the\r\n\t* className <%=isinteraction?\"interaction\":\"object\"%> class\r\n\t*/\r\n\tpublic static Set< String > get_<%=isinteraction?\"parameter\":\"attribute\"%>_names( String className ) {\r\n\t\treturn new HashSet< String >(  _datamemberClassNameSetMap.get( className )  );\r\n\t}\r\n\t\r\n\t/**\r\n\t* Returns a set of strings containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s\r\n\t* in the <%=isinteraction?\"interaction\":\"object\"%> class specified by className.\r\n\t*\r\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class for which to retrieve the\r\n\t* names of all of its <%=isinteraction?\"parameter\":\"attribute\"%>s\r\n\t* @return Set< String > containing the names of all <%=isinteraction?\"parameter\":\"attribute\"%>s in the\r\n\t* className <%=isinteraction?\"interaction\":\"object\"%> class\r\n\t*/\r\n\tpublic static Set< String > get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names( String className ) {\r\n\t\treturn new HashSet< String >(  _allDatamemberClassNameSetMap.get( className )  );\r\n\t}\r\n\t\r\n\t/**\r\n\t* Returns the fully-qualified name of the <%=isinteraction?\"interaction\":\"object\"%> class corresponding\r\n\t* to the RTI-defined classHandle.\r\n\t*\r\n\t* @param classHandle handle (defined by RTI) of <%=isinteraction?\"interaction\":\"object\"%> class for\r\n\t* which to retrieve the fully-qualified name\r\n\t* @return the fully-qualified name of the <%=isinteraction?\"interaction\":\"object\"%> class that\r\n\t* corresponds to the RTI-defined classHandle\r\n\t*/\r\n\tpublic static String get_class_name( int classHandle ) {\r\n\t\treturn _classHandleNameMap.get( classHandle );\r\n\t}\r\n\r\n\t/**\r\n\t* Returns the simple name of the <%=isinteraction?\"interaction\":\"object\"%> class corresponding to the\r\n\t* RTI-defined classHandle.  The simple name of an <%=isinteraction?\"interaction\":\"object\"%> class is\r\n\t* the last name in its (dot-delimited) fully-qualified name.\r\n\t*\r\n\t* @param classHandle handle (defined by RTI) of <%=isinteraction?\"interaction\":\"object\"%> class for which\r\n\t* to retrieve the simple name\r\n\t* @return the simple name of the <%=isinteraction?\"interaction\":\"object\"%> class that corresponds to\r\n\t* the RTI-defined classHandle\r\n\t*/\r\n\tpublic static String get_simple_class_name( int classHandle ) {\r\n\t\treturn _classHandleSimpleNameMap.get( classHandle );\r\n\t}\r\n\t\r\n\t/**\r\n\t* Returns the integer handle (RTI defined) of the <%=isinteraction?\"interaction\":\"object\"%> class\r\n\t* corresponding to the fully-qualified <%=isinteraction?\"interaction\":\"object\"%> class name in className.\r\n\t*\r\n\t* @param className fully-qualified name of <%=isinteraction?\"interaction\":\"object\"%> class for which to\r\n\t* retrieve the RTI-defined integer handle\r\n\t* @return the RTI-defined handle of the <%=isinteraction?\"interaction\":\"object\"%> class\r\n\t*/\r\n\tpublic static int get_handle( String className ) {\r\n\t\r\n\t\tInteger classHandle = _classNameHandleMap.get( className );\r\n\t\tif ( classHandle == null ) {\r\n\t\t\tSystem.err.println( \"Bad class name \\\"\" + className + \"\\\" on get_handle.\" );\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\t\r\n\t\treturn classHandle;\t\t\r\n\t}\r\n\t\r\n\t/**\r\n\t* Returns the name of <% if(isinteraction){ %>a parameter<%}else{%>an attribute<%}%> corresponding to\r\n\t* its handle (RTI assigned) in datamemberHandle.\r\n\t*\r\n\t* @param datamemberHandle handle of <% if(isinteraction){ %>parameter<%}else{%>attribute<%}%> (RTI assigned)\r\n\t* for which to return the name\r\n\t* @return the name of the <% if(isinteraction){ %>parameter<%}else{%>attribute<%}%> corresponding to datamemberHandle\r\n\t*/\r\n\tpublic static String get_<%=isinteraction?\"parameter\":\"attribute\"%>_name( int datamemberHandle ) {\r\n\t\treturn _datamemberHandleNameMap.get( datamemberHandle );\r\n\t}\r\n\t\r\n\t/**\r\n\t* Returns the handle of <% if(isinteraction){ %>a parameter<%}else{%>an attribute<%}%> (RTI assigned) given\r\n\t* its <%=isinteraction?\"interaction\":\"object\"%> class name and <%=isinteraction?\"parameter\":\"attribute\"%> name\r\n\t*\r\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class\r\n\t* @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%>\r\n\t* @return the handle (RTI assigned) of the <%=isinteraction?\"parameter\":\"attribute\"%> \"datamemberName\" of <%=isinteraction?\"interaction\":\"object\"%> class \"className\"\r\n\t*/\r\n\tpublic static int get_<%=isinteraction?\"parameter\":\"attribute\"%>_handle( String className, String datamemberName ) {\r\n\t\r\n\t\tInteger datamemberHandle = _datamemberNameHandleMap.get( className + \",\" + datamemberName );\r\n\t\tif ( datamemberHandle == null ) {\r\n\t\t\tSystem.err.println( \"Bad <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" + datamemberName + \"\\\" for class \\\"\" + className + \"\\\" on get_<%=isinteraction?\"parameter\":\"attribute\"%>_handle.\" );\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\t\r\n\t\treturn datamemberHandle;\t\t\r\n\t}\r\n\t\r\n\tprivate static Class<?>[] pubsubArguments = new Class<?>[] { RTIambassador.class };\r\n\t\r\n\t\r\n\t/**\r\n\t* Publishes the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" for a federate.\r\n\t* This can also be performed by calling the publish( RTIambassador rti )\r\n\t* method directly on the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" (for\r\n\t* example, to publish the <%=isinteraction?\"Interaction\":\"Object\"%>Root class in particular,\r\n\t* see {@link <%=isinteraction?\"Interaction\":\"Object\"%>Root#publish( RTIambassador rti )}).\r\n\t*\r\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class to be published for the federate\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic static void publish( String className, RTIambassador rti ) {\r\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\r\n\t\tif ( rtiClass == null ) {\r\n\t\t\tSystem.err.println( \"Bad class name \\\"\" + className + \"\\\" on publish.\" );\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tMethod method = rtiClass.getMethod( \"publish\", pubsubArguments );\r\n\t\t\tmethod.invoke( null, new Object[]{ rti } );\r\n\t\t} catch ( Exception e ) {\r\n\t\t\tSystem.err.println( \"Exception caught on publish!\" );\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* Unpublishes the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" for a federate.\r\n\t* This can also be performed by calling the unpublish( RTIambassador rti )\r\n\t* method directly on the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" (for\r\n\t* example, to unpublish the <%=isinteraction?\"Interaction\":\"Object\"%>Root class in particular,\r\n\t* see {@link <%=isinteraction?\"Interaction\":\"Object\"%>Root#unpublish( RTIambassador rti )}).\r\n\t*\r\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class to be unpublished for the federate\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic static void unpublish( String className, RTIambassador rti ) {\r\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\r\n\t\tif ( rtiClass == null ) {\r\n\t\t\tSystem.err.println( \"Bad class name \\\"\" + className + \"\\\" on unpublish.\" );\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tMethod method = rtiClass.getMethod( \"unpublish\", pubsubArguments );\r\n\t\t\tmethod.invoke( null, new Object[]{ rti } );\r\n\t\t} catch ( Exception e ) {\r\n\t\t\tSystem.err.println( \"Exception caught on unpublish!\" );\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t* Subscribes federate to the <%=isinteraction?\"interaction\":\"object\"%> class names by \"className\"\r\n\t* This can also be performed by calling the subscribe( RTIambassador rti )\r\n\t* method directly on the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" (for\r\n\t* example, to subscribe a federate to the <%=isinteraction?\"Interaction\":\"Object\"%>Root class\r\n\t* in particular, see {@link <%=isinteraction?\"Interaction\":\"Object\"%>Root#subscribe( RTIambassador rti )}).\r\n\t*\r\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class to which to subscribe the federate\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic static void subscribe( String className, RTIambassador rti ) {\r\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\r\n\t\tif ( rtiClass == null ) {\r\n\t\t\tSystem.err.println( \"Bad class name \\\"\" + className + \"\\\" on subscribe.\" );\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tMethod method = rtiClass.getMethod( \"subscribe\", pubsubArguments );\r\n\t\t\tmethod.invoke( null, new Object[]{ rti } );\r\n\t\t} catch ( Exception e ) {\r\n\t\t\tSystem.err.println( \"Exception caught on subscribe!\" );\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t* Unsubscribes federate from the <%=isinteraction?\"interaction\":\"object\"%> class names by \"className\"\r\n\t* This can also be performed by calling the unsubscribe( RTIambassador rti )\r\n\t* method directly on the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" (for\r\n\t* example, to unsubscribe a federate to the <%=isinteraction?\"Interaction\":\"Object\"%>Root class\r\n\t* in particular, see {@link <%=isinteraction?\"Interaction\":\"Object\"%>Root#unsubscribe( RTIambassador rti )}).\r\n\t*\r\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class to which to unsubscribe the federate\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic static void unsubscribe( String className, RTIambassador rti ) {\r\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\r\n\t\ttry {\r\n\t\t\tMethod method = rtiClass.getMethod( \"unsubscribe\", pubsubArguments );\r\n\t\t\tmethod.invoke( null, new Object[]{ rti } );\r\n\t\t} catch ( Exception e ) {\r\n\t\t\tSystem.err.println( \"Exception caught on unsubscribe!\" );\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\r\n<% if(isinteraction){ %><%}else{%>\r\n\t/**\r\n\t* Publishes the attribute named by \"attributeName\" of the object class named\r\n\t* by \"className\" for a federate.  This can also be performed by calling the\r\n\t* publish_<attributeName>() method directly on the object class named by\r\n\t* \"className\".\r\n\t*\r\n\t* Note:  This method only marks the attribute named by \"attributeName\" for\r\n\t* publication.  The attribute doesn't actually get published until the\r\n\t* \"className\" object class, of which it is a member, is (re)published.  See\r\n\t* {@link ObjectRoot#publish( String className, RTIambassador RTI )} and\r\n\t* {@link ObjectRoot#publish( RTIambassador RTI )} for examples of how to\r\n\t* publish the object class.\r\n\t* \r\n\t* @param className name of object class for which the attribute named by\r\n\t* \"attributeName\" is to be published\r\n\t* @param attributeName name of the attribute to be published\r\n\t*/\r\n\tpublic static void publish( String className, String attributeName ) {\r\n\t\ttry {\r\n\t\t\t_classNamePublishAttributeNameMap.get( className ).add( attributeName );\r\n\t\t} catch ( Exception e ) {\r\n\t\t\tSystem.err.println( \"ERROR:  ObjectRoot.publish:  could not publish class \\\"\" + className + \"\\\" \\\"\" + attributeName + \"\\\" attribute.\" );\r\n\t\t\te.printStackTrace();\r\n\t\t}\t\t\r\n\t}\r\n\r\n\t/**\r\n\t* Unpublishes the attribute named by \"attributeName\" of the object class named\r\n\t* by \"className\" for a federate.  This can also be performed by calling the\r\n\t* unpublish_<attributeName>() method directly on the object class named by\r\n\t* \"className\".\r\n\t*\r\n\t* Note:  This method only marks the attribute named by \"attributeName\" for\r\n\t* un-publication. The attribute doesn't actually get unpublished until the\r\n\t* \"className\" object class, of which it is a member, is (re)published.  See\r\n\t* {@link ObjectRoot#publish( String className, RTIambassador RTI )} and\r\n\t* {@link ObjectRoot#publish( RTIambassador RTI )} for examples of how to\r\n\t* publish the object class.\r\n\t* \r\n\t* @param className name of object class for which the attribute named by\r\n\t* \"attributeName\" is to be unpublished (by a federate)\r\n\t* @param attributeName name of the attribute to be unpublished\r\n\t*/\r\n\tpublic static void unpublish( String className, String attributeName ) {\r\n\t\ttry {\r\n\t\t\t_classNamePublishAttributeNameMap.get( className ).remove( attributeName );\r\n\t\t} catch ( Exception e ) {\r\n\t\t\tSystem.err.println( \"ERROR:  ObjectRoot.unpublish:  could not unpublish class \\\"\" + className + \"\\\" \\\"\" + attributeName + \"\\\" attribute.\" );\r\n\t\t\te.printStackTrace();\r\n\t\t}\t\t\r\n\t}\r\n\r\n\t/**\r\n\t* Subscribe a federate to the attribute named by \"attributeName\" of the\r\n\t* object class named by \"className\".  This can also be performed by calling\r\n\t* the subscribe_<attributeName>() method directly on the object class named\r\n\t* by \"className\".\r\n\t*\r\n\t* Note:  This method only marks the attribute named by \"attributeName\" for\r\n\t* subscription.  The attribute doesn't actually get subscribed to until the\r\n\t* \"className\" object class, of which it is a member, is (re)subscribed to.\r\n\t* See {@link ObjectRoot#subscribe( String className, RTIambassador RTI )} and\r\n\t* {@link ObjectRoot#subscribe( RTIambassador RTI )} for examples of how to\r\n\t* subscribe to the object class.\r\n\t* \r\n\t* @param className name of object class for which the attribute named by\r\n\t* \"attributeName\" is to be subcribed\r\n\t* @param attributeName name of the attribute to be published\r\n\t*/\r\n\tpublic static void subscribe( String className, String attributeName ) {\r\n\t\ttry {\r\n\t\t\t_classNameSubscribeAttributeNameMap.get( className ).add( attributeName );\r\n\t\t} catch ( Exception e ) {\r\n\t\t\tSystem.err.println( \"ERROR:  ObjectRoot.subscribe:  could not subscribe to class \\\"\" + className + \"\\\" \\\"\" + attributeName + \"\\\" attribute.\" );\r\n\t\t\te.printStackTrace();\r\n\t\t}\t\t\r\n\t}\r\n\r\n\t/**\r\n\t* Unsubscribe a federate from the attribute named by \"attributeName\" of the\r\n\t* object class named by \"className\".  This can also be performed by calling\r\n\t* the unsubscribe_<attributeName>() method directly on the object class named\r\n\t* by \"className\".\r\n\t*\r\n\t* Note:  This method only marks the attribute named by \"attributeName\" for\r\n\t* unsubscription.  The attribute doesn't actually get unsubscribed from until the\r\n\t* \"className\" object class, of which it is a member, is (re)subscribed to.\r\n\t* See {@link ObjectRoot#subscribe( String className, RTIambassador RTI )} and\r\n\t* {@link ObjectRoot#subscribe( RTIambassador RTI )} for examples of how to\r\n\t* subscribe to the object class.\r\n\t* \r\n\t* @param className name of object class for which the attribute named by\r\n\t* \"attributeName\" is to be subcribed\r\n\t* @param attributeName name of the attribute to be published\r\n\t*/\r\n\tpublic static void unsubscribe( String className, String attributeName ) {\r\n\t\ttry {\r\n\t\t\t_classNameSubscribeAttributeNameMap.get( className ).remove( attributeName );\r\n\t\t} catch ( Exception e ) {\r\n\t\t\tSystem.err.println( \"ERROR:  ObjectRoot.unsubscribe:  could not unsubscribe class \\\"\" + className + \"\\\" \\\"\" + attributeName + \"\\\" attribute.\" );\r\n\t\t\te.printStackTrace();\r\n\t\t}\t\t\r\n\t}\r\n<%}%>\r\n\t\r\n\tprivate static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( Class<?> rtiClass ) {\r\n\t\t<%=isinteraction?\"Interaction\":\"Object\"%>Root classRoot = null;\r\n\t\ttry {\r\n\t\t\tclassRoot = (<%=isinteraction?\"Interaction\":\"Object\"%>Root)rtiClass.newInstance();\r\n\t\t} catch( Exception e ) {\r\n\t\t\tSystem.err.println( \"ERROR:  <%=isinteraction?\"Interaction\":\"Object\"%>Root:  create_<%=isinteraction?\"interaction\":\"object\"%>:  could not create/cast new <%=isinteraction?\"Interaction\":\"Object\"%>\" );\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\t\r\n\t\treturn classRoot;\r\n\t}\r\n\r\n\tprivate static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( Class<?> rtiClass, LogicalTime logicalTime ) {\t\r\n\t\t<%=isinteraction?\"Interaction\":\"Object\"%>Root classRoot = create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass );\r\n\t\tif ( classRoot != null ) classRoot.setTime( logicalTime );\r\n\t\treturn classRoot;\r\n\t}\r\n\r\n\tprivate static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( Class<?> rtiClass, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\r\n\t\t<%=isinteraction?\"Interaction\":\"Object\"%>Root classRoot = create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass );\r\n\t\tclassRoot.set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\r\n\t\treturn classRoot;\r\n\t}\r\n\t\r\n\tprivate static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( Class<?> rtiClass, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime ) {\r\n\t\t<%=isinteraction?\"Interaction\":\"Object\"%>Root classRoot = create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass );\r\n\t\tclassRoot.set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\r\n\t\tclassRoot.setTime( logicalTime );\r\n\t\treturn classRoot;\r\n\t}\r\n\t\r\n\t/**\r\n\t* Create an <%=isinteraction?\"interaction\":\"object\"%> that is in instance of <%=isinteraction?\"interaction\":\"object\"%> class\r\n\t* \"className\". An <%=isinteraction?\"Interaction\":\"Object\"%>Root reference is returned,\r\n\t* so to refer to the instance using a reference to a \"className\" interaction,\r\n\t* the returned reference must be cast down the <%=isinteraction?\"interaction\":\"object\"%> inheritance\r\n\t* hierarchy.\r\n\t* An instance of the \"className\" <%=isinteraction?\"interaction\":\"object\"%> class may also be created\r\n\t* by using the \"new\" operator directory on the \"className\" <%=isinteraction?\"interaction\":\"object\"%>\r\n\t* class.  For instance, two ways to create an <%=isinteraction?\"Interaction\":\"Object\"%>Root\r\n\t* instance are\r\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>.create_<%=isinteraction?\"interaction\":\"object\"%>( \"<%=isinteraction?\"Interaction\":\"Object\"%>Root\" ),\r\n\t* and\r\n\t* new <%=isinteraction?\"Interaction\":\"Object\"%>Root()\r\n\t*\r\n\t* @param className fully-qualified (dot-delimited) name of the <%=isinteraction?\"interaction\":\"object\"%>\r\n\t* class for which to create an instance\r\n\t* @return instance of \"className\" <%=isinteraction?\"interaction\":\"object\"%> class\r\n\t*/\r\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( String className ) {\r\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\r\n\t\tif ( rtiClass == null ) return null;\r\n\r\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass );\r\n\t}\r\n\r\n\t/**\r\n\t* Like {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( String className )}, but <%=isinteraction?\"interaction\":\"object\"%>\r\n\t* is created with a timestamp based on \"logicalTime\".\r\n\t*\r\n\t* @param className fully-qualified (dot-delimited) name of the <%=isinteraction?\"interaction\":\"object\"%>\r\n\t* class for which to create an instance\r\n\t* @param logicalTime timestamp to place on the new <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n\t* @return instance of \"className\" <%=isinteraction?\"interaction\":\"object\"%> class with \"logicalTime\" time stamp.\r\n\t*/\r\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( String className, LogicalTime logicalTime ) {\r\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\r\n\t\tif ( rtiClass == null ) return null;\r\n\r\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass, logicalTime );\r\n\t}\r\n\r\n\t/**\r\n\t* Create an <%=isinteraction?\"interaction\":\"object\"%> that is in instance of <%=isinteraction?\"interaction\":\"object\"%> class\r\n\t* that corresponds to the \"classHandle\" handle (RTI assigned). An\r\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>Root reference is returned, so to refer to the\r\n\t* instance using a reference to a \"className\" interaction, the returned\r\n\t* reference must be cast down the <%=isinteraction?\"interaction\":\"object\"%> inheritance hierarchy.\r\n\t*\r\n\t* @param classHandle handle of <%=isinteraction?\"interaction\":\"object\"%> class (RTI assigned) class for\r\n\t* which to create an instance\r\n\t* @return instance of <%=isinteraction?\"interaction\":\"object\"%> class corresponding to \"classHandle\"\r\n\t*/\r\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle ) {\r\n\t\tClass<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );\r\n\t\tif ( rtiClass == null ) return null;\r\n\r\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass );\r\n\t}\r\n\r\n\t/**\r\n\t* Like {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle )}, but the <%=isinteraction?\"interaction\":\"object\"%>\r\n\t* is created with a timestamp based on \"logicalTime\".\r\n\t*\r\n\t* @param classHandle handle of <%=isinteraction?\"interaction\":\"object\"%> class (RTI assigned) class for\r\n\t* which to create an instance\r\n\t* @param logicalTime timestamp to place on the new <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n\t* @return instance of <%=isinteraction?\"interaction\":\"object\"%> class corresponding to \"classHandle\" with\r\n\t* \"logicalTime\" time stamp\r\n\t*/\r\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, LogicalTime logicalTime ) {\r\n\t\tClass<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );\r\n\t\tif ( rtiClass == null ) return null;\r\n\r\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass, logicalTime );\r\n\t}\r\n\r\n\t/**\r\n\t* Like {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle )}, but the <%=isinteraction?\"interaction\":\"object\"%>'s\r\n\t* <%=isinteraction?\"parameter\":\"attribute\"%>s are initialized using \"datamemberMap\".  The \"datamemberMap\"\r\n\t* is usually acquired as an argument to an RTI callback method of a federate.\r\n\t*\r\n\t* @param classHandle handle of <%=isinteraction?\"interaction\":\"object\"%> class (RTI assigned) class for\r\n\t* which to create an instance\r\n\t* @param datamemberMap contains initializing values for the <%=isinteraction?\"parameter\":\"attribute\"%>s\r\n\t* of the <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n\t* @return instance of <%=isinteraction?\"interaction\":\"object\"%> class corresponding to \"classHandle\" with\r\n\t* its <%=isinteraction?\"parameter\":\"attribute\"%>s initialized with the \"datamemberMap\"\r\n\t*/\r\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\r\n\t\tClass<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );\r\n\t\tif ( rtiClass == null ) return null;\r\n\r\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass, datamemberMap );\r\n\t}\r\n\r\n\t/**\r\n\t* Like {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap )},\r\n\t* but the <%=isinteraction?\"interaction\":\"object\"%> is given a timestamp based on \"logicalTime\".\r\n\t*\r\n\t* @param classHandle handle of <%=isinteraction?\"interaction\":\"object\"%> class (RTI assigned) class for\r\n\t* which to create an instance\r\n\t* @param datamemberMap initializing values for the <%=isinteraction?\"parameter\":\"attribute\"%>s of the\r\n\t* <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n\t* @param logicalTime timestamp to place on the new <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n\t* @return instance of <%=isinteraction?\"interaction\":\"object\"%> class corresponding to \"classHandle\" with\r\n\t* its <%=isinteraction?\"parameter\":\"attribute\"%>s initialized with the \"datamemberMap\" and with\r\n\t* \"logicalTime\" timestamp\r\n\t*/\r\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime ) {\r\n\t\tClass<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );\r\n\t\tif ( rtiClass == null ) return null;\r\n\r\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass, datamemberMap, logicalTime );\r\n\t}\r\n\r\n<% if(isinteraction){ %><%}else{%>\r\n\t/**\r\n\t* Creates a new instance of the object class corresponding to \"class_handle\",\r\n\t* registers it in an map internal to the ObjectRoot class using \"object_handle\"\r\n\t* as a key, and returns a reference to the instance.  Though the created\r\n\t* instance is of the object class corresponding to \"class_handle\" (which is\r\n\t* a handle assigned by the RTI), it is referred to, via the return value, by\r\n\t* an ObjectRoot reference.  Thus, to refer to it as an instance of the object\r\n\t* class corresponding to \"class_handle\", the ObjectRoot reference needs to be\r\n\t* cast down through the inheritance hierarchy.\r\n\t* <p/>\r\n\t* class_handle and object_handle are usually acquired as arguments of the\r\n\t* \"discoverObjectInstance\" RTI callback method of a federate.\r\n\t*\r\n\t* @param class_handle handle of object class (RTI assigned) for which to create\r\n\t* an instance\r\n\t* @param object_handle handle (also RTI assigned) of this instance as it is\r\n\t* known to the RTI.  Any updates to the instance attributes provided by the\r\n\t* RTI (via a \"reflectAttributeValues\" federate callback) will be identified\r\n\t* with this object_handle.\r\n\t* @return new instance of the object class corresponding to class_handle\r\n\t*/\r\n    public static ObjectRoot discover( int class_handle, int object_handle ) {\r\n        Class<?> hlaObjectClass = _classNameClassMap.get(  _classHandleNameMap.get( class_handle )  );\r\n        ObjectRoot objectRoot = null;\r\n        try {\r\n            objectRoot = (ObjectRoot)hlaObjectClass.newInstance();\r\n            objectRoot.setObjectHandle( object_handle );\r\n            _objectMap.put( object_handle, objectRoot );\r\n        } catch( Exception e ) {\r\n            System.err.println( \"ERROR:  ObjectRoot:  discover:  could not discover object\" );\r\n            e.printStackTrace();\r\n        }\r\n        return objectRoot;\r\n    }\r\n    \r\n    /**\r\n    * Retrieves the object instance corresponding to \"object_handle\" from an\r\n    * internal table in the ObjectRoot class, updates its attribute values using\r\n    * \"reflectedAttributes\", and returns the instance.  Both \"object_handle\" and\r\n    * \"reflectedAttributes\" are usually acquired as arguments of the\r\n    * \"reflectAttributeValues\" RTI callback of a federate.\r\n    * The return value is an ObjectRoot reference to the instance.  So, to refer\r\n    * to the instance as an instance of its actual class, this reference will\r\n    * have to be cast down the inheritance hierarchy.\r\n    *\r\n    * @param object_handle handle (RTI assigned) of object instance for which the\r\n    * attributes are to be updated.\r\n    * @param reflectedAttributes set of updated values for the attributes of the\r\n    * object instance corresponding to object_handle.\r\n    * @return the object instance with updated attribute values\r\n    */\r\n    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes ) {\r\n    \tObjectRoot objectRoot = _objectMap.get( object_handle );\r\n    \tif ( objectRoot == null ) return null;\r\n    \tobjectRoot.setTime( -1 );\r\n    \tobjectRoot.setAttributes( reflectedAttributes );\r\n    \treturn objectRoot;\r\n    }\r\n\r\n\t/**\r\n\t* Like {@link #reflect( int object_handle, ReflectedAttributes reflectedAttributes )},\r\n\t* except the updated attributes of the object instance have their timestamps\r\n\t* updated to \"logicalTime\".\r\n\t*\r\n    * @param object_handle handle (RTI assigned) of object instance for which the\r\n    * attributes are to be updated.\r\n    * @param reflectedAttributes set of updated values for the attributes of the\r\n    * object instance corresponding to object_handle.\r\n    * @param logicalTime new time stamp for attributes that are updated\r\n    * @return the object instance with updated attribute values\r\n    */\r\n    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes, LogicalTime logicalTime ) {\r\n    \tObjectRoot objectRoot = _objectMap.get( object_handle );\r\n    \tif ( objectRoot == null ) return null;\r\n    \tobjectRoot.setTime( logicalTime );\r\n    \tobjectRoot.setAttributes( reflectedAttributes );\r\n    \treturn objectRoot;\r\n    }\r\n\r\n\t/**\r\n\t* Like {@link #reflect( int object_handle, ReflectedAttributes reflectedAttributes )},\r\n\t* except the updated attributes of the object instance have their timestamps\r\n\t* updated to \"time\".\r\n\t*\r\n    * @param object_handle handle (RTI assigned) of object instance for which the\r\n    * attributes are to be updated.\r\n    * @param reflectedAttributes set of updated values for the attributes of the\r\n    * object instance corresponding to object_handle.\r\n    * @param time new time stamp for attributes that are updated\r\n    * @return the object instance with updated attribute values\r\n    */\r\n    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes, double time ) {\r\n    \tObjectRoot objectRoot = _objectMap.get( object_handle );\r\n    \tif ( objectRoot == null ) return null;\r\n    \tobjectRoot.setTime( time );\r\n    \tobjectRoot.setAttributes( reflectedAttributes );\r\n    \treturn objectRoot;\r\n    }\r\n\r\n\t/**\r\n\t* Requests an attribute update for this object instance from the federate that\r\n\t* has modification rights on these attributes.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic void requestUpdate( RTIambassador rti ) {\r\n\t\tboolean requestNotSubmitted = true;\r\n\t\twhile( requestNotSubmitted ) {\r\n\t\t\ttry {\t\t\r\n\t\t\t\trti.requestObjectAttributeValueUpdate( getObjectHandle(), getSubscribedAttributeHandleSet() );\r\n\t\t\t\trequestNotSubmitted = false;\r\n\t\t\t} catch ( FederateNotExecutionMember f ) {\r\n\t\t\t\tSystem.err.println( \"ERROR: \" + getClassName() + \"request for update failed:  Federate Not Execution Member\" );\r\n\t\t\t\tf.printStackTrace();\r\n\t\t\t\treturn;\t\t\t\t\r\n\t\t\t} catch ( ObjectNotKnown o ) {\r\n\t\t\t\tSystem.err.println( \"ERROR: \" + getClassName() + \"request for update failed:  Object Not Known\" );\r\n\t\t\t\to.printStackTrace();\r\n\t\t\t\treturn;\t\t\t\t\r\n\t\t\t} catch ( AttributeNotDefined a ) {\r\n\t\t\t\tSystem.err.println( \"ERROR: \" + getClassName() + \"request for update failed:  Name Not Found\" );\r\n\t\t\t\ta.printStackTrace();\r\n\t\t\t\treturn;\t\t\t\t\r\n\t\t\t} catch ( Exception e ) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t\ttry { Thread.sleep( 50 ); } catch( Exception e1 ) { }\t\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* Returns the object instance corresponding to the \"object_handle\" (RTI\r\n\t* assigned) from a map internal to the ObjectRoot class.\r\n\t* The object instance is referred to, via the return value, using an\r\n\t* an ObjectRoot reference.  To reference to it using a reference of its\r\n\t* actual class, the returned reference must be cast down through the\r\n\t* inhertance hierarchy.\r\n\t*\r\n\t* @param object_handle handle (RTI assigned) of object instance to retrieve\r\n\t* from the map internal to the ObjectRoot class.\r\n\t* @return object instance corresponding to the object_handle (RTI assigned)\r\n\t* in the map that is internal to the ObjectRoot class.\r\n\t*/\r\n\tpublic static ObjectRoot getObject( int object_handle ) {\r\n\t\treturn _objectMap.get( object_handle );\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t* Returns the object instance corresponding to the \"object_handle\" (RTI\r\n\t* assigned) from a map internal to the ObjectRoot class AND REMOVES IT\r\n\t* FROM THIS MAP.\r\n\t* The object instance is referred to, via the return value, using an\r\n\t* an ObjectRoot reference.  To reference to it using a reference of its\r\n\t* actual class, the returned reference must be cast down through the\r\n\t* inhertance hierarchy.\r\n\t*\r\n\t* @param object_handle handle (RTI assigned) of object instance to retrieve\r\n\t* from the map internal to the ObjectRoot class.\r\n\t* @return object instance corresponding to the object_handle (RTI assigned)\r\n\t* in the map that is internal to the ObjectRoot class.\r\n\t*/\r\n    public static ObjectRoot removeObject( int object_handle ) {\r\n        return _objectMap.remove( object_handle );\r\n    }\r\n    \r\n\r\n    private int _object_handle;\r\n\r\n    private void setObjectHandle( int object_handle ) {\r\n        _objectMap.remove( object_handle );\r\n        _object_handle = object_handle;\r\n        _objectMap.put( object_handle, this );\r\n    }\r\n\r\n\t/**\r\n\t* Returns the handle (RTI assigned) the corresponds to this object class\r\n\t* instance.  This handle is the instance's unique identifier to the RTI.\r\n\t*\r\n\t* @return the handle (RTI assigned) of this object class instance.\r\n\t*/\r\n    public int getObjectHandle() { return _object_handle; }\r\n\t\r\n<%}%>\r\n\r\n\tprivate double _time = -1;\r\n\t\r\n\t/**\r\n\t* Returns the timestamp for this <%=isinteraction?\"interaction\":\"object\"%>.  \"receive order\" <%=isinteraction?\"interaction\":\"object\"%>s\r\n\t* should have a timestamp of -1.\r\n\t*\r\n\t* @return timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\r\n\t*/\r\n\tpublic double getTime() { return _time; }\r\n\t\r\n\t/**\r\n\t* Sets the timestamp of this <%=isinteraction?\"interaction\":\"object\"%> to \"time\".\r\n\t*\r\n\t* @param time new timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\r\n\t*/\r\n\tpublic void setTime( double time ) { _time = time; }\r\n\r\n\t/**\r\n\t* Sets the timestamp of this <%=isinteraction?\"interaction\":\"object\"%> to \"logicalTime\".\r\n\t*\r\n\t* @param logicalTime new timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\r\n\t*/\r\n\tpublic void setTime( LogicalTime logicalTime ) {\r\n\t\tDoubleTime doubleTime = new DoubleTime();\r\n\t\tdoubleTime.setTo( logicalTime );\r\n\t\tsetTime( doubleTime.getTime() );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* Creates a new <%=isinteraction?\"Interaction\":\"Object\"%>Root instance.\r\n\t*/\r\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>Root() {\r\n\t\t_uniqueID = generateUniqueID();\r\n\t}\r\n\t\r\n\t/**\r\n\t* Creates a copy of an <%=isinteraction?\"Interaction\":\"Object\"%>Root instance.  As an\r\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>Root instance contains no <%=isinteraction?\"parameter\":\"attribute\"%>s,\r\n\t* this has the same effect as the default constructor.\r\n\t*/\r\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"Interaction\":\"Object\"%>Root <%=isinteraction?\"interaction\":\"object\"%>Root ) {\r\n\t\tthis();\r\n\t}\r\n\r\n\tprotected <%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, boolean initFlag ) {\r\n\t\tthis();\r\n\t\tif ( initFlag ) set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\r\n\t}\r\n\t\r\n\tprotected <%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime, boolean initFlag ) {\r\n\t\tthis();\r\n\t\tsetTime( logicalTime );\r\n\t\tif ( initFlag ) set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* Creates a new <%=isinteraction?\"interaction\":\"object\"%> instance and initializes its <%=isinteraction?\"parameter\":\"attribute\"%>s\r\n\t* using the \"datamemberMap\" -- this constructor is usually called as a\r\n\t* super-class constructor to create and initialize an instance of an\r\n\t* <%=isinteraction?\"interaction\":\"object\"%> further down in the inheritance hierarchy.  \"datamemberMap\"\r\n\t* is usually acquired as an argument to an RTI federate callback method, such\r\n\t* as \"receiveInteraction\".\r\n\t*\r\n\t* @param datamemberMap contains <%=isinteraction?\"parameter\":\"attribute\"%> values for the newly created\r\n\t* <%=isinteraction?\"interaction\":\"object\"%>\r\n\t*/\r\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\r\n\t\tthis( datamemberMap, true );\r\n\t}\r\n\r\n\t/**\r\n\t* Like {@link #<%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap )},\r\n\t* except the new instance has an initial timestamp of \"logicalTime\".\r\n\t*\r\n\t* @param datamemberMap contains <%=isinteraction?\"parameter\":\"attribute\"%> values for the newly created\r\n\t* <%=isinteraction?\"interaction\":\"object\"%>\r\n\t* @param logicalTime initial timestamp for newly created <%=isinteraction?\"interaction\":\"object\"%> instance\r\n\t*/\t\r\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime ) {\r\n\t\tthis( datamemberMap, logicalTime, true );\r\n\t}\r\n\r\n\t/**\r\n\t* Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" for this\r\n\t* <%=isinteraction?\"interaction\":\"object\"%>.\r\n\t*\r\n\t* @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value to retrieve\r\n\t* @return the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose name is \"datamemberName\"\r\n\t*/\r\n\tpublic Object get<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName ) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t* Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose handle is \"datamemberHandle\"\r\n\t* (RTI assigned) for this <%=isinteraction?\"interaction\":\"object\"%>.\r\n\t*\r\n\t* @param datamemberHandle handle (RTI assigned) of <%=isinteraction?\"parameter\":\"attribute\"%> whose\r\n\t* value to retrieve\r\n\t* @return the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose handle is \"datamemberHandle\"\r\n\t*/\r\n\tpublic Object get<%=isinteraction?\"Parameter\":\"Attribute\"%>( int datamemberHandle ) {\r\n\t\treturn null;\r\n\t}\r\n\t\t\r\n\t/**\r\n\t* Set the values of the <%=isinteraction?\"parameter\":\"attribute\"%>s in this <%=isinteraction?\"interaction\":\"object\"%> using\r\n\t* \"datamemberMap\".  \"datamemberMap\" is usually acquired as an argument to\r\n\t* an RTI federate callback method such as \"receiveInteraction\".\r\n\t*\r\n\t* @param datamemberMap  contains new values for the <%=isinteraction?\"parameter\":\"attribute\"%>s of\r\n\t* this <%=isinteraction?\"interaction\":\"object\"%>\r\n\t*/\r\n\tpublic void set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\r\n\t\tint size = datamemberMap.size();\r\n\t\tfor( int ix = 0 ; ix < size ; ++ix ) {\r\n\t\t\ttry {\r\n\t\t\t\tset<%=isinteraction?\"Parameter\":\"Attribute\"%>(  datamemberMap.get<%=isinteraction?\"Parameter\":\"Attribute\"%>Handle( ix ), datamemberMap.getValue( ix )  );\r\n\t\t\t} catch ( Exception e ) {\r\n\t\t\t\tSystem.err.println( \"set<%=isinteraction?\"Parameter\":\"Attribute\"%>s: Exception caught!\" );\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprivate void set<%=isinteraction?\"Parameter\":\"Attribute\"%>( int handle, byte[] val ) {\r\n\t\tif ( val == null ) {\r\n\t\t\tSystem.err.println( \"set:  Attempt to set null value in class \\\"\" + getClass().getName() + \"\\\"\" );\r\n\t\t}\r\n\t\tString valAsString = new String( val, 0, val.length );\r\n\t\tif (valAsString != null && valAsString.length() > 0 && valAsString.charAt(valAsString.length() - 1) == '\\0') {\r\n\t\t\tvalAsString = valAsString.substring(0, valAsString.length() - 1);\r\n\t\t}\r\n\t\tif (   !set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux(  handle, valAsString  )   ) {\r\n\t\t\tSystem.err.println( \"set:  bad <%=isinteraction?\"parameter\":\"attribute\"%> handle in class \\\"\" + getClass().getName() + \"\\\"\" );\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t* Sets the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" to \"value\"\r\n\t* in this <%=isinteraction?\"interaction\":\"object\"%>.  \"value\" is converted to data type of \"datamemberName\"\r\n\t* if needed.\r\n\t* This action can also be affected by calling the set_<datamemberName>( value )\r\n\t* method on the <%=isinteraction?\"interaction\":\"object\"%> using a reference to the <%=isinteraction?\"interaction\":\"object\"%>'s actual\r\n\t* class.\r\n\t*\r\n\t* @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be set\r\n\t* to \"value\"\r\n\t* @param value new value of <%=isinteraction?\"parameter\":\"attribute\"%> called \"datamemberName\"\r\n\t*/\r\n\tpublic void set<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName, String value ) {\r\n\t\tif (  !set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, value )  ) {\r\n\t\t\tSystem.err.println( \"Error:  <%=isinteraction?\"interaction\":\"object\"%>Root:  invalid <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" + datamemberName + \"\\\"\" );\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* Sets the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" to \"value\"\r\n\t* in this <%=isinteraction?\"interaction\":\"object\"%>.  \"value\" should have the same data type as that of\r\n\t* the \"datamemberName\" <%=isinteraction?\"parameter\":\"attribute\"%>.\r\n\t* This action can also be affected by calling the set_<datamemberName>( value )\r\n\t* method on the <%=isinteraction?\"interaction\":\"object\"%> using a reference to the <%=isinteraction?\"interaction\":\"object\"%>'s actual\r\n\t* class.\r\n\t*\r\n\t* @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be set\r\n\t* to \"value\"\r\n\t* @param value new value of <%=isinteraction?\"parameter\":\"attribute\"%> called \"datamemberName\"\r\n\t*/\r\n\tpublic void set<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName, Object value ) {\r\n\t\tif (  !set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, value )  ) {\r\n\t\t\tSystem.err.println( \"Error:  <%=isinteraction?\"interaction\":\"object\"%>Root:  invalid <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" + datamemberName + \"\\\"\" );\r\n\t\t}\r\n\t}\r\n\r\n\tprotected boolean set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( int param_handle, String val ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprotected boolean set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( String datamemberName, String value ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprotected boolean set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( String datamemberName, Object value ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprotected Supplied<%=isinteraction?\"Parameter\":\"Attribute\"%>s createSuppliedDatamembers(<% if(isinteraction){ %><%}else{%>boolean force<%}%>) {\r\n\t\treturn _factory.createSupplied<%=isinteraction?\"Parameter\":\"Attribute\"%>s();\r\n\t}\r\n\t\r\n<% if(isinteraction){ %>\r\n\t/**\r\n\t* Sends this interaction to the RTI, with the specified timestamp \"time\".\r\n\t* This method should be used to send interactions that have \"timestamp\"\r\n\t* ordering.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t* @param time timestamp for this interaction.  The timestamp should be no\r\n\t* less than the current federation time + the LOOKAHEAD value of the federate\r\n\t* sending this interaction.\r\n\t*/\r\n\tpublic void sendInteraction( RTIambassador rti, double time ) throws Exception {\r\n\t\tsynchronized( rti ) {\r\n\t\t\ttry {\r\n\t\t\t\tSuppliedParameters datamembers = createSuppliedDatamembers();\r\n\t\t\t\trti.sendInteraction(  getClassHandle(), datamembers, null, new DoubleTime( time )  );\r\n\t\t\t\tcreateLog(datamembers,time);\r\n\t\t\t} catch ( Exception e ) {\r\n\t\t\t\tSystem.err.println( \"ERROR:  \" + getClass().getName() + \":  could not send interaction\" );\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* Sends this interaction to the RTI (without a timestamp).\r\n\t* This method should be used to send interactions that have \"receive\"\r\n\t* ordering.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic void sendInteraction( RTIambassador rti ) throws Exception {\r\n\t\tsynchronized( rti ) {\r\n\t\t\ttry {\r\n\t\t\t\tSuppliedParameters datamembers = createSuppliedDatamembers();\r\n\t\t\t\trti.sendInteraction( getClassHandle(), datamembers, null );\r\n\t\t\t\tcreateLog(datamembers,0);\r\n\t\t\t} catch ( Exception e ) {\r\n\t\t\t\tSystem.err.println( \"ERROR:  \" + getClass().getName() + \":  could not send interaction\" );\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tprotected static String fedName = null;\r\n\tpublic static Boolean enablePubLog = false;\r\n\tpublic static Boolean enableSubLog = false;\r\n\tpublic static String pubLogLevel = null;\r\n\tpublic static String subLogLevel = null;\r\n\t\r\n\tpublic static void enablePublishLog(String interaction, String fed, String thislevel, String globallevel){\r\n\t\tif(globallevel == null || \"\".equals(globallevel)) return;\r\n\t\tif(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;\r\n\t\tfedName = fed;\r\n\t\tenablePubLog = true;\r\n\t\tpubLogLevel = thislevel;\r\n\t\tC2WLogger.addLog(interaction, fedName, true);\r\n\t}\r\n\t\r\n\tpublic static void enableSubscribeLog(String interaction, String fed, String thislevel, String globallevel){\r\n\t\tif(globallevel == null || \"\".equals(globallevel)) return;\r\n\t\tif(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;\r\n\t\tfedName = fed;\r\n\t\tenableSubLog = true;\r\n\t\tsubLogLevel = thislevel;\r\n\t\tC2WLogger.addLog(interaction, fedName, false);\r\n\t}\r\n\t\r\n\tprotected void createLog(final SuppliedParameters datamembers, final double time) {\r\n\t\tif(!enablePubLog) return;\r\n        Thread t = new Thread(new Runnable() {                                                                                 // NOMELD\r\n            public void run() {                                                                                                // NOMELD\r\n\t\t\t\ttry {\r\n\t\t\t\t\tString interactionId = fedName != null ? fedName + \"_pub_\"+ getSimpleClassName() :getSimpleClassName() + \"_pub\";\r\n\r\n\t\t\t\t\t// First just record the interaction event as a log\r\n\t\t\t\t\tC2WLogger.addEventLog(time, interactionId);\r\n\r\n\t\t\t\t\t// Now, log detailed simulation data of the interaction\r\n\t\t\t\t\tString logIdLocal = null;\r\n\t\t\t\t\tsynchronized( <%=isinteraction?\"Interaction\":\"Object\"%>Root.class ) {\r\n\t\t\t\t\t\tlogIdLocal = Integer.toString( logId++ );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tint noDatamembers = datamembers.size();\r\n\t\t\t\t\tif ( noDatamembers == 0 ) {\r\n\t\t\t\t\t\tC2WLogger.addLog( interactionId, time, null, null, null, pubLogLevel, logIdLocal );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor(int ix =0; ix < datamembers.size();ix++){\r\n\t\t\t\t\t\t\tString parameter = get_parameter_name(datamembers.getHandle( ix ) );\r\n\t\t\t\t\t\t\tString value = new String(datamembers.getValue(ix));\t\r\n\t\t\t\t\t\t\tString type = new String(_datamemberTypeMap.get(parameter));\r\n\t\t\t\t\t\t\tC2WLogger.addLog( interactionId, time, parameter, value, type, pubLogLevel, logIdLocal );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch ( Exception e ) {\r\n\t\t\t\t\tSystem.err.println( \"ERROR:  \" + getClass().getName() + \":  could not send interaction\" );\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n            }\r\n        });\r\n        t.start();\r\n\t}\r\n\r\n<%}else{%>\r\n    private boolean _isRegistered = false;\r\n\r\n\t/**\r\n\t* Registers this object with the RTI.  This method is usually called by a\r\n\t* federate who \"owns\" this object, i.e. the federate that created it and\r\n\t* has write-privileges to its attributes (so, it is responsible for updating\r\n\t* these attribute and conveying their updated values to the RTI).\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/ \r\n    public void registerObject( RTIambassador rti ) {\r\n        \r\n        while( !_isRegistered ) {\r\n            try {\r\n                synchronized( rti ) {\r\n                    _object_handle = rti.registerObjectInstance( getClassHandle() );\r\n                }\r\n                _isRegistered = true;\r\n                _objectMap.put( getObjectHandle(), this );\r\n                \r\n            } catch ( ObjectClassNotDefined o ) {\r\n                o.printStackTrace();\r\n                return;\r\n            } catch ( ObjectClassNotPublished o ) {\r\n                o.printStackTrace();\r\n                return;\r\n            } catch ( FederateNotExecutionMember f ) {\r\n                f.printStackTrace();\r\n                return;\r\n            } catch ( Exception e ) {\r\n                try {\r\n                    Thread.sleep( 500 );\r\n                } catch ( InterruptedException e1 ) {\r\n                    e1.printStackTrace();\r\n                } \r\n            }\r\n        }\r\n\r\n    }\r\n    \r\n\t/**\r\n\t* Unregisters this object with the RTI.  The RTI will destroy all information\r\n\t* it contains regarding this object as a result.  This method is usually\r\n\t* called by a federate who \"owns\" this object, i.e. the federate that created\r\n\t* it and has write-privileges to its attributes.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/ \r\n    public void unregisterObject( RTIambassador rti ) {\r\n        \r\n        while( _isRegistered ) {\r\n            try {\r\n                synchronized( rti ) {\r\n                    rti.deleteObjectInstance( _object_handle, null );\r\n                }\r\n                _isRegistered = false;\r\n                _objectMap.remove( getObjectHandle() );\r\n                \r\n            } catch ( ObjectNotKnown o ) {\r\n                o.printStackTrace();\r\n                return;\r\n            } catch ( DeletePrivilegeNotHeld d ) {\r\n                d.printStackTrace();\r\n                return;\r\n            } catch ( FederateNotExecutionMember f ) {\r\n                f.printStackTrace();\r\n                return;\r\n            } catch ( Exception e ) {\r\n                try {\r\n                    Thread.sleep( 500 );\r\n                } catch ( InterruptedException e1 ) {\r\n                    e1.printStackTrace();\r\n                } \r\n            }\r\n        }\r\n    }\r\n\r\n\t/**\r\n\t* Broadcasts the attributes of this object and their values to the RTI, where\r\n\t* the values have \"time\" as their timestamp.  This call should be used for\r\n\t* objects whose attributes have \"timestamp\" ordering.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t* @param time timestamp on attribute values of this object\r\n\t* @param force if \"false\", only the attributes whose values have changed since\r\n\t* the last call to \"updateAttributeValues\" will be broadcast to the RTI.  If\r\n\t* \"true\", all attributes and their values are broadcast to the RTI.\r\n\t*/\r\n    public void updateAttributeValues( RTIambassador rti, double time, boolean force ) {\r\n\r\n        SuppliedAttributes suppliedAttributes = createSuppliedDatamembers( force );\r\n        if ( suppliedAttributes.size() == 0 ) return;\r\n\r\n        synchronized( rti ) {\r\n            try {\r\n                rti.updateAttributeValues(  getObjectHandle(), suppliedAttributes, null, new DoubleTime( time )  );\r\n                createLog(suppliedAttributes, time);\r\n            } catch ( ObjectNotKnown o ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Object Not Known\" );\r\n                o.printStackTrace();\r\n                return;\r\n            } catch ( FederateNotExecutionMember f ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Federate Not Execution Member\" );\r\n                f.printStackTrace();\r\n                return;\r\n            } catch ( AttributeNotDefined a ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Attribute Not Defined\" );\r\n                a.printStackTrace();\r\n                return;\r\n            } catch ( AttributeNotOwned a ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Attribute Not Owned\" );\r\n                a.printStackTrace();\r\n                return;\r\n            } catch ( ConcurrentAccessAttempted c ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Concurrent Access Attempted\" );\r\n                c.printStackTrace();\r\n                return;\r\n            } catch ( InvalidFederationTime i ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Invalid Federation Time\" );\r\n                i.printStackTrace();\r\n                return;\r\n            } catch ( Exception e ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes\" );\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n\t/**\r\n    * Like {@link #updateAttributeValues( RTIambassador rti, double time, boolean force )},\r\n    * except \"force\" is always false.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t* @param time timestamp on attribute values of this object\r\n\t*/\r\n    public void updateAttributeValues( RTIambassador rti, double time ) {\r\n    \tupdateAttributeValues( rti, time, false );\r\n    }\r\n\r\n\t/**\r\n\t* Broadcasts the attributes of this object and their values to the RTI (with\r\n\t* no timestamp).  This call should be used for objects whose attributes have\r\n\t* \"receive\" ordering.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t* @param force if \"false\", only the attributes whose values have changed since\r\n\t* the last call to \"updateAttributeValues\" will be broadcast to the RTI.  If\r\n\t* \"true\", all attributes and their values are broadcast to the RTI.\r\n\t*/\r\n    public void updateAttributeValues( RTIambassador rti, boolean force ) {\r\n\r\n        SuppliedAttributes suppliedAttributes = createSuppliedDatamembers( force );\r\n        if ( suppliedAttributes.size() == 0 ) return;\r\n\r\n        synchronized( rti ) {\r\n            try {\r\n                rti.updateAttributeValues( getObjectHandle(), suppliedAttributes, null );\r\n                createLog(suppliedAttributes, 0);\r\n            } catch ( ObjectNotKnown o ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Object Not Known\" );\r\n                o.printStackTrace();\r\n                return;\r\n            } catch ( FederateNotExecutionMember f ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Federate Not Execution Member\" );\r\n                f.printStackTrace();\r\n                return;\r\n            } catch ( AttributeNotDefined a ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Attribute Not Defined\" );\r\n                a.printStackTrace();\r\n                return;\r\n            } catch ( AttributeNotOwned a ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Attribute Not Owned\" );\r\n                a.printStackTrace();\r\n                return;\r\n            } catch ( ConcurrentAccessAttempted c ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Concurrent Access Attempted\" );\r\n                c.printStackTrace();\r\n                return;\r\n            } catch ( Exception e ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes\" );\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n\t/**\r\n    * Like {@link #updateAttributeValues( RTIambassador rti, boolean force )},\r\n    * except \"force\" is always false.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic void updateAttributeValues( RTIambassador rti ) {\r\n\t\tupdateAttributeValues( rti, false );\r\n\t}\r\n\r\n\tprotected static String _fedName = null;\r\n\tprotected static Map< String, String > _pubAttributeLogMap = new HashMap< String, String >();\r\n\tprotected static Map< String, String > _subAttributeLogMap = new HashMap< String, String >();\r\n\t\r\n\tpublic static void enablePublishLog(String object, String attribute, String fed, String thislevel, String globallevel){\r\n\t\tif(globallevel == null || \"\".equals(globallevel)) return;\r\n\t\tif(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;\r\n\t\t_fedName = fed;\r\n\t\t_pubAttributeLogMap.put(attribute, thislevel);\r\n\t\tC2WLogger.addLog(object, attribute, fed, true);\r\n\t}\r\n\t\r\n\tpublic static void enableSubscribeLog(String object, String attribute, String fed, String thislevel, String globallevel){\r\n\t\tif(globallevel == null || \"\".equals(globallevel)) return;\r\n\t\tif(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;\r\n\t\t_fedName = fed;\r\n\t\t_subAttributeLogMap.put(attribute, thislevel);\r\n\t\tC2WLogger.addLog(object, attribute, fed, true);\r\n\t}\r\n\t\r\n\tprotected void createLog(final SuppliedAttributes suppliedAttributes, final double time) {\r\n\t\tif(_pubAttributeLogMap.isEmpty()) return;\r\n        Thread t = new Thread(new Runnable() {                                                       // NOMELD\r\n            public void run() {                                                                      // NOMELD\r\n\t\t\t\ttry {\r\n\t\t\t\t\tString eventName = _fedName+\"_pub_\"+getSimpleClassName();\r\n\r\n\t\t\t\t\t// First just record the interaction event as a log\r\n\t\t\t\t\tC2WLogger.addEventLog(time, eventName);\r\n\r\n\t\t\t\t\t// Now, log detailed simulation data of the object update\r\n\t\t\t\t\tString logIdLocal = null;\r\n\t\t\t\t\tsynchronized( <%=isinteraction?\"Interaction\":\"Object\"%>Root.class ) {\r\n\t\t\t\t\t\tlogIdLocal = Integer.toString( logId++ );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor(int ix =0; ix < suppliedAttributes.size();ix++){\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tString attribute = get_attribute_name(suppliedAttributes.getHandle( ix ) );\t\t\t\r\n\t\t\t\t\t\tif(!_pubAttributeLogMap.containsKey(attribute)) continue;\r\n\t\t\t\t\t\tString id = _fedName+\"_pub_\"+getSimpleClassName()+\"_\"+attribute;\r\n\t\t\t\t\t\tString value = new String(suppliedAttributes.getValue(ix));\t\r\n\t\t\t\t\t\tString type = new String(_datamemberTypeMap.get(attribute));\r\n\t\t\t\t\t\tString loglevel = _pubAttributeLogMap.get(attribute);\r\n\t\t\t\t\t\tC2WLogger.addLog( id, time, attribute, value, type, loglevel, logIdLocal );\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch ( Exception e ) {\r\n\t\t\t\t\tSystem.err.println( \"ERROR:  \" + getClass().getName() + \":  could not send interaction\" );\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n            }\r\n        });\r\n        t.start();\r\n\t}\r\n\t\r\n<%}%>\r\n\r\n\t/**\r\n\t* For use with the melding API -- this method is used to cast\r\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>Root instance reference into the\r\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface interface.\r\n\t*\r\n\t* @param rootInstance <%=isinteraction?\"Interaction\":\"Object\"%>Root instance reference to be\r\n\t* cast into the <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface interface\r\n\t* @return <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface reference to the instance\r\n\t*/\r\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface cast( <%=isinteraction?\"Interaction\":\"Object\"%>Root rootInstance ) {\r\n\t\treturn rootInstance;\r\n\t}\t\t\r\n\r\n\t/**\r\n\t* For use with the melding API -- this method creates a new\r\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>Root instance and returns a\r\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface reference to it.\r\n\t*\r\n\t* @return <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface reference to a newly created\r\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>Root instance\r\n\t*/\r\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface create() {\r\n\t\treturn new <%=isinteraction?\"Interaction\":\"Object\"%>Root();\r\n\t}\t\t\r\n\r\n\tpublic void copyFrom( Object object ) { }\r\n}\r\n",
    "java/federate-config.json.ejs": "{\r\n  \"federateRTIInitWaitTimeMs\": 200,\r\n  \"federateType\": \"<%=classname%>\",\r\n  \"federationId\": \"<%=projectName%>\",\r\n  \"isLateJoiner\": false,\r\n  \"lookAhead\": <%=lookahead%>,\r\n  \"stepSize\": <%=step%>\r\n}\r\n",
    "java/federate.java.ejs": "<%/* group federate;\r\n\r\nfederate(\r\n\tsimname,\r\n\tmelderpackagename,\r\n\tclassname,\r\n\tisnonmapperfed,\r\n\ttimeconstrained,\r\n\ttimeregulating,\r\n\tasynchronousdelivery,\r\n\tpublishedinteractiondata,\r\n\tsubscribedinteractiondata,\r\n\tallinteractiondata,\r\n\tpublishedobjectdata,\r\n\tsubscribedobjectdata,\r\n\tallobjectdata\r\n) ::= <<*/ -%>\r\n\r\npackage <%= simname %>;\r\n\r\nimport hla.rti.EventRetractionHandle;\r\nimport hla.rti.LogicalTime;\r\nimport hla.rti.ReceivedInteraction;\r\n\r\nimport org.cpswt.hla.C2WInteractionRoot;\r\nimport org.cpswt.hla.InteractionRoot;\r\nimport org.cpswt.hla.SubscribedInteractionFilter;\r\nimport org.cpswt.hla.SynchronizedFederate;\r\n\r\nimport org.cpswt.config.FederateConfig;\r\n\r\nimport org.cpswt.hla.*;\r\n<% if(melderpackagename){ -%>\r\nimport <%= melderpackagename %>.<%= classname %>;\r\nimport <%= melderpackagename %>.<%= classname %>RTIFactory;\r\n<% } -%>\r\n\r\npublic class <%= classname %>Base extends <% if(melderpackagename) { %><%= classname %><% }else{ %>SynchronizedFederate<% } %> {\r\n\r\n<% if(melderpackagename){ -%>\r\n\tstatic {\r\n\t\t<%= classname %>RTIFactory rtiFactory = new <%= classname %>RTIFactory();\r\n<% /*allinteractiondata:setfactoryvar()*/ -%>\r\n\t\t<% allinteractiondata.forEach(function(rticlass){ %>\r\n\t\trtiFactory.set_<%= rticlass.name %>Interface( new <%= rticlass.name %>Melder() );<%});%>\r\n<% /*allobjectdata:setfactoryvar()*/ -%>\r\n\t\t<% allobjectdata.forEach(function(rticlass){ %>\r\n\t\trtiFactory.set_<%= rticlass.name %>Interface( new <%= rticlass.name %>Melder() );<%});%>\t\r\n\r\n\t\t<%= classname %>.set<%= classname %>RTIFactory( rtiFactory );\r\n\t}\r\n<% } -%>\r\n\tprivate SubscribedInteractionFilter _subscribedInteractionFilter = new SubscribedInteractionFilter();\r\n\t\r\n\t// constructor\r\n\tpublic <%= classname %>Base(FederateConfig config) throws Exception {\r\n\t\tsuper(config);\r\n\r\n\t\tsuper.createLRC();\r\n\t\tsuper.joinFederation();\r\n\r\n<% if(timeconstrained){ -%>\r\n\t\tenableTimeConstrained();\r\n<% } %>\r\n<% if(timeregulating){ -%>\r\n\t\tenableTimeRegulation(getLookAhead());\r\n<% } -%>\r\n<% if(asynchronousdelivery){ -%>\r\n\t\tenableAsynchronousDelivery();\r\n<% } -%>\r\n        // interaction pubsub\r\n<% /* publishedinteractiondata:pubinter() */ -%>\r\n        <% publishedinteractiondata.forEach(function(interactiondata){ %>\r\n        <%= interactiondata.name %>.publish(getLRC());<%});%>\r\n<% /* subscribedinteractiondata:subinter() */ -%>\r\n        <% subscribedinteractiondata.forEach(function(interactiondata){ %>\r\n        <%= interactiondata.name %>.subscribe(getLRC());\r\n        _subscribedInteractionFilter.setFedFilters( \r\n\t\t\t<%= interactiondata.name %>.get_handle(), \r\n\t\t\tSubscribedInteractionFilter.OriginFedFilter.<%= interactiondata.originFedFilter() %>, \r\n\t\t\tSubscribedInteractionFilter.SourceFedFilter.<%= interactiondata.srcFedFilter() %> \r\n\t\t);<%}); -%>\r\n\t\t\r\n\t\t// object pubsub\r\n<%/* publishedobjectdata:pubobjectdata() */ -%>\r\n        <% publishedobjectdata.forEach(function(objectdata){ %>\r\n        \t<% objectdata.publishedAttributeData.forEach(function(a){ %>\r\n        <%= objectdata.name %>.publish_<%= a.name %>();<%});%>\r\n        <%= objectdata.name %>.publish(getLRC());\r\n        <%}); -%>\r\n<%/* subscribedobjectdata:subobjectdata() */ -%>\r\n        <% subscribedobjectdata.forEach(function(objectdata){ %>\r\n        \t<% objectdata.subscribedAttributeData.forEach(function(a){ %>\r\n        <%= objectdata.name %>.subscribe_<%= a.name %>();<%});%>\r\n        <%= objectdata.name %>.subscribe(getLRC());\r\n        <%}); -%>\r\n        }\r\n        \r\n<%/* publishedinteractiondata:create_interaction() */ -%>\r\n\t<%publishedinteractiondata.forEach(function(interaction_data){%>\r\n\tpublic <%= interaction_data.name %> create_<%= interaction_data.name %>() {\r\n\t   <%= interaction_data.name%> interaction = new <%= interaction_data.name %>();\r\n\t   interaction.set_sourceFed( getFederateId() );\r\n\t   interaction.set_originFed( getFederateId() );\r\n\t   return interaction;\r\n\t}<%}); %>\r\n<%/* filter_interaction() */ -%>\r\n\t@Override\r\n\tpublic void receiveInteraction(\r\n\t int interactionClass, ReceivedInteraction theInteraction, byte[] userSuppliedTag\r\n\t) {\r\n\t\tInteractionRoot interactionRoot = InteractionRoot.create_interaction( interactionClass, theInteraction );\r\n\t\tif ( interactionRoot instanceof C2WInteractionRoot ) {\r\n\t\t\t\r\n\t\t\tC2WInteractionRoot c2wInteractionRoot = (C2WInteractionRoot)interactionRoot;\r\n\r\n\t        // Filter interaction if src/origin fed requirements (if any) are not met\r\n\t        if (  _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRoot )  ) {\r\n\t        \treturn;\r\n\t        } \r\n\t\t}\r\n\t\t\r\n\t\tsuper.receiveInteraction( interactionClass, theInteraction, userSuppliedTag );\t\t\t\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void receiveInteraction(\r\n\t int interactionClass,\r\n\t ReceivedInteraction theInteraction,\r\n\t byte[] userSuppliedTag,\r\n\t LogicalTime theTime,\r\n\t EventRetractionHandle retractionHandle\r\n\t) {\r\n\t\tInteractionRoot interactionRoot = InteractionRoot.create_interaction( interactionClass, theInteraction, theTime );\r\n\t\tif ( interactionRoot instanceof C2WInteractionRoot ) {\r\n\r\n\t\t\tC2WInteractionRoot c2wInteractionRoot = (C2WInteractionRoot)interactionRoot;\r\n\r\n\t        // Filter interaction if src/origin fed requirements (if any) are not met\r\n\t        if (  _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRoot )  ) {\r\n\t        \treturn;\r\n\t        } \r\n\t\t}\r\n\r\n\t\tsuper.receiveInteraction( interactionClass, theInteraction, userSuppliedTag, theTime, retractionHandle );\t\t\t\r\n\t}\r\n}\r\n",
    "java/federatebase.java.ejs": "<% /* ////////////////////////////////////////////////////////////////////////////////////// */ -%>\r\n<% /* This template generates the Java code for the implementation of the federate           */ -%>\r\n<% /* \"helper\" class located in the \"base\" package of the generated file set, as indicated   */ -%>\r\n<% /* by the item marked with '*****' below                                                  */ -%>\r\n<% /*                                                                                        */ -%>\r\n<% /*     [top]                                                                              */ -%>\r\n<% /*         base                                                                           */ -%>\r\n<% /*             _SomeFederate.java     *****                                               */ -%>\r\n<% /*         interactions                                                                   */ -%>\r\n<% /*             SomeInteractionA.java                                                      */ -%>\r\n<% /*             SomeInteractionB.java                                                      */ -%>\r\n<% /*             ...                                                                        */ -%>\r\n<% /*         reflections                                                                    */ -%>\r\n<% /*             SomeReflectionA.java                                                       */ -%>\r\n<% /*             SomeReflectionB.java                                                       */ -%>\r\n<% /*             ...                                                                        */ -%>\r\n<% /*         SomeFederate.java                                                              */ -%>\r\n<% /* ////////////////////////////////////////////////////////////////////////////////////// */ -%>\r\n<%/* group federate;\r\nfederate(\r\n        simname,\r\n        melderpackagename,\r\n        classname,\r\n        isnonmapperfed,\r\n        timeconstrained,\r\n        timeregulating,\r\n        asynchronousdelivery,\r\n        publishedinteractiondata,\r\n        subscribedinteractiondata,\r\n        allinteractiondata,\r\n        publishedobjectdata,\r\n        subscribedobjectdata,\r\n        allobjectdata\r\n) ::= <<\r\n*/ -%>\r\n/*\r\n * This software is contributed as a public service by The National Institute of Standards\r\n * and Technology (NIST) and is not subject to U.S. Copyright\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the \"Software\"), to deal in the Software\r\n * without restriction, including without limitation the rights to use, copy, modify,\r\n * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above NIST contribution notice and this permission and disclaimer notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\r\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\r\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. THE AUTHORS OR COPYRIGHT HOLDERS SHALL\r\n * NOT HAVE ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR\r\n * MODIFICATIONS.\r\n */\r\npackage <%= groupId %>.<%= classname.toLowerCase() %>.base;\r\n\r\nimport gov.nist.ucef.hla.base.HLAInteraction;\r\nimport gov.nist.ucef.hla.base.HLAObject;\r\nimport gov.nist.ucef.hla.ucef.NoOpFederate;\r\n\r\n<% if( publishedinteractiondata.length || subscribedinteractiondata.length ){ new Set([...publishedinteractiondata.map(x=>x.name), ...subscribedinteractiondata.map(x=>x.name)].sort()).forEach( function ( intClassName, idx ) { -%>\r\nimport <%= groupId %>.interactions.<%= intClassName %>;\r\n<% }); } -%>\r\n<% if( publishedobjectdata.length || subscribedobjectdata.length ){ new Set([...publishedobjectdata.map(x=>x.name), ...subscribedobjectdata.map(x=>x.name)].sort()).forEach( function ( objClassName, idx ) { -%>\r\nimport <%= groupId %>.reflections.<%= objClassName %>;\r\n<% }); } -%>\r\n\r\n/**\r\n *                    ___\r\n *                  _/   \\_     _     _\r\n *                 / \\   / \\   / \\   / \\\r\n *                ( U )─( C )─( E )─( F )\r\n *                 \\_/   \\_/   \\_/   \\_/\r\n *                <─┴─> <─┴─────┴─────┴─>\r\n *               Universal CPS Environment\r\n *                     for Federation\r\n */\r\npublic class _<%= classname %> extends NoOpFederate\r\n{\r\n    //----------------------------------------------------------\r\n    //                   STATIC VARIABLES\r\n    //----------------------------------------------------------\r\n\r\n    //----------------------------------------------------------\r\n    //                   INSTANCE VARIABLES\r\n    //----------------------------------------------------------\r\n\r\n    //----------------------------------------------------------\r\n    //                      CONSTRUCTORS\r\n    //----------------------------------------------------------\r\n    public _<%= classname %>()\r\n    {\r\n        super();\r\n        <% if(timeconstrained){ -%>enableTimeConstrained();<% } %>\r\n\r\n        <% if(timeregulating){ -%>enableTimeRegulation(getLookAhead());<% } %>\r\n\r\n    }\r\n\r\n    //----------------------------------------------------------\r\n    //                    INSTANCE METHODS\r\n    //----------------------------------------------------------\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////////////////\r\n    /////////////////////////////////// RTI Callback Methods ///////////////////////////////////\r\n    ////////////////////////////////////////////////////////////////////////////////////////////\r\n<% if( subscribedinteractiondata.length > 0 ) { -%>\r\n    @Override\r\n    public void receiveInteraction( HLAInteraction hlaInteraction )\r\n    {\r\n        String interactionClassName = hlaInteraction.getInteractionClassName();\r\n        <% subscribedinteractiondata.map(x=>x.name).forEach( function ( className, idx ) { -%>\r\n<% if( idx > 0 ) { -%>else <% } -%>if( <%= className %>.interactionClassName().equals( interactionClassName ) )\r\n\r\n        {\r\n            receive<%= className %>Interaction( new <%= className %>( hlaInteraction ) );\r\n        }\r\n<% }); -%>\r\n        else\r\n        {\r\n            // this is unexpected - we shouldn't receive any thing we didn't subscribe to\r\n            System.err.println( String.format( \"Received an unexpected interaction of type '%s'\",\r\n                                                interactionClassName ) );\r\n        }\r\n    }\r\n<% } -%>\r\n\r\n<% if( subscribedobjectdata.length > 0 ) { -%>\r\n    @Override\r\n    public void receiveAttributeReflection( HLAObject hlaObject )\r\n    {\r\n        String objectClassName = hlaObject.getObjectClassName();\r\n        <% subscribedobjectdata.map(x=>x.name).forEach( function ( className, idx ) { -%>\r\n<% if( idx > 0 ) { %>else <% } %>if( <%= className %>.objectClassName().equals( objectClassName ) )\r\n        {\r\n            receive<%= className %>Update( new <%= className %>( hlaObject ) );\r\n        }\r\n<%}); -%>\r\n        else\r\n        {\r\n            // this is unexpected - we shouldn't receive any thing we didn't subscribe to\r\n            System.err.println( String.format( \"Received an unexpected attribute reflection of type '%s'\",\r\n                                                objectClassName ) );\r\n        }\r\n    }\r\n<% } -%>\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////////////////\r\n    ///////////////////////////////// Internal Utility Methods /////////////////////////////////\r\n    ////////////////////////////////////////////////////////////////////////////////////////////\r\n<% if( subscribedobjectdata.length > 0 ) { subscribedobjectdata.forEach( function ( objectData, idx ) { -%>\r\n    protected <%= objectData.name %> register( <%= objectData.name %> <%= objectData.name.toLowerCase() %> ) { return (<%= objectData.name %>)super.register( <%= objectData.name.toLowerCase() %> ); }\r\n<% }); } -%>\r\n\r\n<% if( subscribedinteractiondata.length > 0 ) { subscribedinteractiondata.map(x=>x.name).forEach( function ( objClassName, idx ) { var objParamName = objClassName.charAt(0).toLowerCase()+objClassName.substr(1); -%>\r\n    /**\r\n    * Handle receipt of a {@link <%= objClassName %>} interaction.\r\n    *\r\n    * @param <%= objParamName %> the interaction to handle\r\n    */\r\n    protected abstract void receive<%= objClassName %>Interaction( <%= objClassName %> <%= objParamName %> );\r\n<% }); } -%>\r\n\r\n<% if( subscribedobjectdata.length > 0 ) { subscribedobjectdata.map(x=>x.name).forEach( function ( objClassName, idx ) { var objParamName = objClassName.charAt(0).toLowerCase()+objClassName.substr(1); -%>\r\n    /**\r\n    * Handle receipt of a {@link <%= objClassName %>} object attribute reflection.\r\n    *\r\n    * @param <%= objParamName %> the object attribute reflection to handle\r\n    */\r\n    protected abstract void receive<%= objClassName %>Update( <%= objClassName %> <%= objParamName %> );\r\n<% }); } -%>\r\n}\r\n",
    "java/federateimpl.java.ejs": "<% /* ////////////////////////////////////////////////////////////////////////////////////// */ -%>\r\n<% /* This template generates the Java code for the implementation of the federate           */ -%>\r\n<% /* class located in the root package of the generated file set, as indicated by the item  */ -%>\r\n<% /* marked with '*****' below                                                              */ -%>\r\n<% /*                                                                                        */ -%>\r\n<% /*     [top]                                                                              */ -%>\r\n<% /*         base                                                                           */ -%>\r\n<% /*             _SomeFederate.java                                                         */ -%>\r\n<% /*         interactions                                                                   */ -%>\r\n<% /*             SomeInteractionA.java                                                      */ -%>\r\n<% /*             SomeInteractionB.java                                                      */ -%>\r\n<% /*             ...                                                                        */ -%>\r\n<% /*         reflections                                                                    */ -%>\r\n<% /*             SomeReflectionA.java                                                       */ -%>\r\n<% /*             SomeReflectionB.java                                                       */ -%>\r\n<% /*             ...                                                                        */ -%>\r\n<% /*         SomeFederate.java          *****                                               */ -%>\r\n<% /* ////////////////////////////////////////////////////////////////////////////////////// */ -%>\r\n/*\r\n* This software is contributed as a public service by The National Institute of Standards\r\n* and Technology (NIST) and is not subject to U.S. Copyright\r\n*\r\n* Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n* software and associated documentation files (the \"Software\"), to deal in the Software\r\n* without restriction, including without limitation the rights to use, copy, modify,\r\n* merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\r\n* permit persons to whom the Software is furnished to do so, subject to the following\r\n* conditions:\r\n*\r\n* The above NIST contribution notice and this permission and disclaimer notice shall be\r\n* included in all copies or substantial portions of the Software.\r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n* INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\n* PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\r\n* CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\r\n* OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. THE AUTHORS OR COPYRIGHT HOLDERS SHALL\r\n* NOT HAVE ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR\r\n* MODIFICATIONS.\r\n*/\r\n<% var DEFAULT_PARAM_VALUES = {char: \"'-'\", string: '\"\"', short:'0', int:'0', long:'0', float:'0.0', double:'0.0', byte:'(byte)0', 'boolean':'false'}; -%>\r\n<% var SKIP_EXAMPLE_PARAMS = new Set(['actualLogicalGenerationTime', 'federateFilter', 'originFed', 'sourceFed']); -%>\r\npackage <%= groupId %>.<%= classname.toLowerCase() %>;\r\n\r\nimport <%= groupId %>.<%= classname.toLowerCase() %>.base._<%= classname %>;\r\n\r\n<% if( publishedinteractiondata.length || subscribedinteractiondata.length ){ new Set([...publishedinteractiondata.map(x=>x.name), ...subscribedinteractiondata.map(x=>x.name)].sort()).forEach( function ( interactionClassName, idx ) { -%>\r\nimport <%= groupId %>.interactions.<%= interactionClassName %>;\r\n<% }); } -%>\r\n<% if( publishedobjectdata.length || subscribedobjectdata.length ){ new Set([...publishedobjectdata.map(x=>x.name), ...subscribedobjectdata.map(x=>x.name)].sort()).forEach( function ( reflectionClassName, idx ) { -%>\r\nimport <%= groupId %>.reflections.<%= reflectionClassName %>;\r\n<% }); } -%>\r\n\r\n/**\r\n *                    ___\r\n *                  _/   \\_     _     _\r\n *                 / \\   / \\   / \\   / \\\r\n *                ( U )─( C )─( E )─( F )\r\n *                 \\_/   \\_/   \\_/   \\_/\r\n *                <─┴─> <─┴─────┴─────┴─>\r\n *               Universal CPS Environment\r\n *                     for Federation\r\n */\r\npublic class <%= classname %> extends _<%= classname %>\r\n{\r\n    //----------------------------------------------------------\r\n    //                   STATIC VARIABLES\r\n    //----------------------------------------------------------\r\n\r\n    //----------------------------------------------------------\r\n    //                   INSTANCE VARIABLES\r\n    //----------------------------------------------------------\r\n<% if( publishedobjectdata.length ){ -%>\r\n    // published object attribute reflections\r\n<% publishedobjectdata.map(x=>x.name).forEach( function ( objClassName, idx ) { var objParamName = objClassName.charAt(0).toLowerCase()+objClassName.substr(1); -%>\r\n    private <%= objClassName %> <%= objParamName %>;\r\n<% }); } -%>\r\n\r\n    //----------------------------------------------------------\r\n    //                      CONSTRUCTORS\r\n    //----------------------------------------------------------\r\n    public <%= classname %>( String[] args )\r\n    {\r\n        super();\r\n    }\r\n\r\n    //----------------------------------------------------------\r\n    //                    INSTANCE METHODS\r\n    //----------------------------------------------------------\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////////////////\r\n    ///////////////////////////////// Lifecycle Callback Methods ///////////////////////////////\r\n    ////////////////////////////////////////////////////////////////////////////////////////////\r\n    @Override\r\n    public void beforeFirstStep()\r\n    {\r\n        /////////////////////////////////////////////////////////////////\r\n        // INITIALIZE SIMULATION VALUES AS REQUIRED\r\n        /////////////////////////////////////////////////////////////////\r\n<% if( publishedobjectdata.length ){ %>\r\n        // initialise published object attribute reflections\r\n<% publishedobjectdata.map(x=>x.name).forEach( function ( objClassName, idx ) { var objParamName = objClassName.charAt(0).toLowerCase()+objClassName.substr(1); -%>\r\n        this.<%= objParamName %> = register( new <%= objClassName %>() );\r\n<% }); } -%>\r\n    }\r\n\r\n    @Override\r\n    public boolean step( double currentTime )\r\n    {\r\n        /////////////////////////////////////////////////////////////////\r\n        // INSERT SIMULATION LOGIC HERE\r\n        /////////////////////////////////////////////////////////////////\r\n        System.out.println( \"Tick... \" + currentTime );\r\n\r\n<% if( publishedinteractiondata.length ){ -%>\r\n        // send interactions\r\n<% publishedinteractiondata.forEach( function ( item, idx ) { -%>\r\n<% var itemClassName = item.name; -%>\r\n<% var itemParamName = itemClassName.charAt(0).toLowerCase()+itemClassName.substr(1); -%>\r\n        <%= itemClassName %> <%= itemParamName %> = new <%= itemClassName %>();\r\n<% var params = item.parameters.filter(p=>!SKIP_EXAMPLE_PARAMS.has(p.name)); -%>\r\n<% if(params.length) { -%>\r\n        // set <%= itemClassName %> interaction parameter values as required\r\n<% params.forEach(function(param){ -%>\r\n        // <%= itemParamName %>.<%= param.name %>( <%- DEFAULT_PARAM_VALUES[param.parameterType.toLowerCase()] %> );\r\n<% }); -%>\r\n<% } -%>\r\n        sendInteraction( <%= itemParamName %> );\r\n<% }); -%>\r\n<% } -%>\r\n\r\n<% if( publishedobjectdata.length ){ %>\r\n        // send object attribute reflections\r\n<% publishedobjectdata.forEach( function ( item, idx ) { -%>\r\n<% var itemClassName = item.name; -%>\r\n<% var itemParamName = itemClassName.charAt(0).toLowerCase()+itemClassName.substr(1); -%>\r\n<% var params = item.parameters.filter(p=>!SKIP_EXAMPLE_PARAMS.has(p.name)); -%>\r\n<% if(params.length) { -%>\r\n        // set <%= itemClassName %> object attribute values as required\r\n<% params.forEach(function(param){ -%>\r\n        // this.<%= itemParamName %>.<%= param.name %>( <%- DEFAULT_PARAM_VALUES[param.parameterType.toLowerCase()] %> );\r\n<% }); -%>\r\n<% } -%>\r\n        updateAttributeValues( this.<%= itemParamName %> );\r\n<% }); -%>\r\n<% } -%>\r\n\r\n        // return true to continue simulation loop, false to terminate\r\n        return true;\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////////////////\r\n    ////////////////////////// Interaction/Reflection Handler Callbacks ////////////////////////\r\n    ////////////////////////////////////////////////////////////////////////////////////////////\r\n<% if( subscribedinteractiondata.length > 0 ) { subscribedinteractiondata.forEach( function ( item, idx ) { -%>\r\n<% var itemClassName = item.name; -%>\r\n<% var itemParamName = itemClassName.charAt(0).toLowerCase()+itemClassName.substr(1); -%>\r\n    /**\r\n    * Handle receipt of a {@link <%= itemClassName %>} interaction\r\n    *\r\n    * @param <%= itemParamName %> the interaction to handle\r\n    */\r\n    @Override\r\n    protected void receive<%= itemClassName %>Interaction( <%= itemClassName %> <%= itemParamName %> )\r\n    {\r\n        /////////////////////////////////////////////////////////////////\r\n        // INSERT HANDLING HERE\r\n        /////////////////////////////////////////////////////////////////\r\n        System.out.println( \"Received <%= item.name %> interaction\" );\r\n<% var params = item.parameters.filter(p=>!SKIP_EXAMPLE_PARAMS.has(p.name)); -%>\r\n<% if(params.length) { -%>\r\n<% params.forEach(function(param){ -%>\r\n<% var isPresentMethod = 'is'+param.name.charAt(0).toUpperCase()+param.name.substr(1)+'Present()' -%>\r\n        System.out.println( \"\\tInteraction parameter '<%= param.name %>' is \" + (<%= itemParamName %>.<%= isPresentMethod %>?<%= itemParamName %>.<%= param.name %>():\"not set\") );\r\n<% }); -%>\r\n<% } -%>\r\n    }\r\n<% }); } -%>\r\n\r\n<% if( subscribedobjectdata.length > 0 ) { subscribedobjectdata.forEach( function ( item, idx ) { -%>\r\n<% var itemClassName = item.name; -%>\r\n<% var itemParamName = itemClassName.charAt(0).toLowerCase()+itemClassName.substr(1); -%>\r\n    /**\r\n    * Handle receipt of a {@link <%= itemClassName %>} object attribute reflection\r\n    *\r\n    * @param <%= item.name.toLowerCase() %> the object attribute reflection to handle\r\n    */\r\n    @Override\r\n    protected void receive<%= itemClassName %>Update( <%= itemClassName %> <%= itemParamName %> )\r\n    {\r\n        /////////////////////////////////////////////////////////////////\r\n        // INSERT HANDLING HERE\r\n        /////////////////////////////////////////////////////////////////\r\n        System.out.println( \"Received <%= itemClassName %> object attribute reflection\" );\r\n        this.<%= itemParamName %>.setState( <%= itemParamName %> );\r\n<% var params = item.parameters.filter(p=>!SKIP_EXAMPLE_PARAMS.has(p.name)); -%>\r\n<% if(params.length) { -%>\r\n<% params.forEach(function(param){ -%>\r\n<% var isPresentMethod = 'is'+param.name.charAt(0).toUpperCase()+param.name.substr(1)+'Present()' -%>\r\n        System.out.println( \"\\tObject attribute '<%= param.name %>' is \" + (this.<%= itemParamName %>.<%= isPresentMethod %>?this.<%= itemParamName %>.<%= param.name %>():\"not set\") );\r\n<% }); -%>\r\n<% } -%>\r\n    }\r\n<% }); } -%>\r\n\r\n    //----------------------------------------------------------\r\n    //                     STATIC METHODS\r\n    //----------------------------------------------------------\r\n    /**\r\n     * Main method\r\n     *\r\n     * @param args ignored\r\n     */\r\n    public static void main( String[] args )\r\n    {\r\n        System.out.println( \"------------------------------------------------------------------\" );\r\n        System.out.println( \"<%= classname %> Federate starting...\" );\r\n        System.out.println( \"------------------------------------------------------------------\" );\r\n        System.out.println();\r\n\r\n        try\r\n        {\r\n            <%= classname %> federate = new <%= classname %>( args );\r\n            federate.getFederateConfiguration().fromJSON( \"config.json\" );\r\n            federate.runFederate();\r\n        }\r\n        catch( Exception e )\r\n        {\r\n            e.printStackTrace();\r\n            System.err.println( e.getMessage() );\r\n            System.err.println( \"Cannot proceed - shutting down now.\" );\r\n            System.exit( 1 );\r\n        }\r\n\r\n        System.out.println( \"Completed - shutting down now.\" );\r\n        System.exit( 0 );\r\n    }\r\n}\r\n",
    "java/federateimpl_pom.xml.ejs": "<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n\r\n    <modelVersion>4.0.0</modelVersion>\r\n    <parent>\r\n        <groupId><%= mainPom.groupId %></groupId>\r\n        <artifactId><%= projectName %>-java-federates</artifactId>\r\n        <version><%= project_version %></version>\r\n    </parent>\r\n   <artifactId><%= artifactId %></artifactId>\r\n    <packaging>pom</packaging>\r\n    <modules>\r\n        <% for (federate in javafederateName) { %>\r\n        <module><%= javafederateName[federate] %></module>\r\n        <% } %>\r\n    </modules>\r\n</project>",
    "java/federateimpl_uberpom.xml.ejs": "<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n\r\n    <modelVersion>4.0.0</modelVersion>\r\n    <groupId><%= groupId + \".\" + classname.toLowerCase() %></groupId>\r\n    <artifactId><%= classname %></artifactId>\r\n    <version><%= projectVersion %></version>\r\n    <packaging>jar</packaging>\r\n\r\n    <properties>\r\n        <federation.name><%= projectName %></federation.name>\r\n        <package.name><%= groupId + \".\" + classname.toLowerCase() %></package.name>\r\n        <federate.name><%= classname %></federate.name>\r\n        <federation.version><%= projectVersion %></federation.version>\r\n        <cpswt.version><%= cpswtVersion %></cpswt.version>\r\n        <nar.version>3.3.0</nar.version>\r\n        <configFile><%= configFile %></configFile>\r\n    </properties>\r\n\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId>org.cpswt</groupId>\r\n            <artifactId>federate-base</artifactId>\r\n            <version><%= cpswtVersion %></version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.cpswt</groupId>\r\n            <artifactId>base-events</artifactId>\r\n            <version><%= cpswtVersion %></version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId><%= porticoPOM.groupId %></groupId>\r\n            <artifactId><%= porticoPOM.artifactId %></artifactId>\r\n            <version><%= porticoPOM.version %></version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.apache.logging.log4j</groupId>\r\n            <artifactId>log4j-api</artifactId>\r\n            <version>2.8.2</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.apache.logging.log4j</groupId>\r\n            <artifactId>log4j-core</artifactId>\r\n            <version>2.8.2</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>com.lmax</groupId>\r\n            <artifactId>disruptor</artifactId>\r\n            <version>3.3.6</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>junit</groupId>\r\n            <artifactId>junit</artifactId>\r\n            <version>4.7</version>\r\n            <scope>test</scope>\r\n        </dependency>\r\n    </dependencies>\r\n\r\n    <repositories>\r\n        <repository>\r\n            <id>archiva.internal</id>\r\n            <name>Internal Release Repository</name>\r\n            <url><%= releaseUrl %></url>\r\n        </repository>\r\n        <repository>\r\n            <id>archiva.snapshots</id>\r\n            <name>Internal Snapshot Repository</name>\r\n            <url><%= snapshotUrl %></url>\r\n        </repository>\r\n    </repositories>\r\n    <distributionManagement>\r\n        <repository>\r\n            <id>archiva.internal</id>\r\n            <name>Internal Release Repository</name>\r\n            <url><%= releaseUrl %></url>\r\n        </repository>\r\n        <snapshotRepository>\r\n            <id>archiva.snapshots</id>\r\n            <name>Internal Snapshot Repository</name>\r\n            <url><%= snapshotUrl %></url>\r\n        </snapshotRepository>\r\n    </distributionManagement>\r\n\r\n    <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.apache.maven.plugins</groupId>\r\n                <artifactId>maven-shade-plugin</artifactId>\r\n                <version>2.4.3</version>\r\n                <executions>\r\n                    <execution>\r\n                        <phase>package</phase>\r\n                        <goals>\r\n                            <goal>shade</goal>\r\n                        </goals>\r\n                        <configuration>\r\n                            <transformers>\r\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\r\n                                <mainClass>${package.name}.${federate.name}</mainClass>\r\n                                </transformer>\r\n                            </transformers>\r\n                            <filters>\r\n                                <filter>\r\n                                    <artifact>*:*</artifact>\r\n                                    <excludes>\r\n                                        <exclude>META-INF/*.SF</exclude>\r\n                                        <exclude>META-INF/*.DSA</exclude>\r\n                                        <exclude>META-INF/*.RSA</exclude>\r\n                                    </excludes>\r\n                                </filter>\r\n                            </filters>\r\n                        </configuration>\r\n                    </execution>\r\n                </executions>\r\n            </plugin>\r\n            <plugin>\r\n                <groupId>org.apache.maven.plugins</groupId>\r\n                <artifactId>maven-surefire-plugin</artifactId>\r\n                <version>2.19.1</version>\r\n                <configuration>\r\n                    <forkMode>once</forkMode>\r\n                    <argLine>-Djava.library.path=${project.basedir}/target/nar/processid-${cpswt.version}-amd64-Linux-gpp-jni/lib/amd64-Linux-gpp/jni/</argLine>\r\n                </configuration>\r\n            </plugin>\r\n            <plugin>\r\n                <groupId>org.apache.maven.plugins</groupId>\r\n                <artifactId>maven-antrun-plugin</artifactId>\r\n                <version>1.8</version>\r\n                <executions>\r\n                    <execution>\r\n                        <phase>package</phase>\r\n                        <goals>\r\n                            <goal>run</goal>\r\n                        </goals>\r\n                        <configuration>\r\n                            <tasks>\r\n                                <copy todir=\"${basedir}/target/conf\" overwrite=\"true\">\r\n                                    <fileset dir=\"${basedir}/conf\" />\r\n                                </copy>\r\n                                <copy todir=\"${basedir}/target\" overwrite=\"true\">\r\n                                    <fileset file=\"${basedir}/RTI.rid\" />\r\n                                </copy>\r\n                            </tasks>\r\n                        </configuration>\r\n                    </execution>\r\n                </executions>\r\n            </plugin>\r\n            <plugin>\r\n                <groupId>org.apache.maven.plugins</groupId>\r\n                <artifactId>maven-compiler-plugin</artifactId>\r\n                <version>3.5.1</version>\r\n                <configuration>\r\n                    <source>1.8</source>\r\n                    <target>1.8</target>\r\n                </configuration>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n        <profiles>\r\n        <profile>\r\n            <id>${federate.name}</id>\r\n        </profile>\r\n        <profile>\r\n            <id>JavaFed</id>\r\n            <build>\r\n                <plugins>\r\n                    <plugin>\r\n                        <groupId>org.codehaus.mojo</groupId>\r\n                        <artifactId>exec-maven-plugin</artifactId>\r\n                        <version>1.5.0</version>\r\n                        <goals>\r\n                            <goal>java</goal>\r\n                        </goals>\r\n                        <configuration>\r\n                            <systemProperties>\r\n                                <systemProperty>\r\n                                    <key>java.net.preferIPv4Stack</key>\r\n                                    <value>true</value>\r\n                                </systemProperty>\r\n                            </systemProperties>\r\n                            <classpathScope>runtime</classpathScope>\r\n                            <mainClass>${package.name}.${federate.name}</mainClass>\r\n                            <arguments>\r\n                                <argument>-configFile</argument>\r\n                                <argument>${configFile}</argument>\r\n                            </arguments>\r\n                        </configuration>\r\n                    </plugin>\r\n                </plugins>\r\n            </build>\r\n        </profile>\r\n    </profiles>\r\n</project>\r\n",
    "java/federatertifactory.java.ejs": "<% /*federatertifactory( melderpackagename, classname, allinteractiondata, allobjectdata ) ::= <<*/%>\r\npackage <%= melderpackagename %>;\r\n\r\npublic class <%=classname %> {\r\n\r\n\t<%/* allinteractiondata:interfacemember() */%>\r\n\tprivate <%=allinteractiondata.name %>Interface _<%=allinteractiondata.name %>_var;\r\n\t\r\n\t<%/*  allobjectdata:interfacemember() */%>\r\n\tprivate <%=allobjectdata.name %>Interface _<%=allobjectdata.name %>_var;\r\n\t\r\n\t<%/*  allinteractiondata:setinterfacemember() */%>\r\n\tpublic void set_<%= allinteractiondata.name  %>Interface( <%= allinteractiondata.name  %>Interface interface_var ) {\r\n\t\t_<%= allinteractiondata.name %>_var = interface_var;\r\n\t}\r\n\r\n\t<%/*  allobjectdata:setinterfacemember() */%>\r\n\tpublic void set_<%= allobjectdata.name  %>Interface( <%= allobjectdata.name  %>Interface interface_var ) {\r\n\t\t_<%= allobjectdata.name %>_var = interface_var;\r\n\t}\r\n\r\n\t<%/*  allinteractiondata:getinterfacemember() */%>\r\n\tpublic <%= allinteractiondata.name %>Interface get_<%= allinteractiondata.name %>Interface() {\r\n\t\treturn _<%= allinteractiondata.name %>_var;\r\n\t}\r\n\t\r\n\t<%/*  allobjectdata:getinterfacemember() */%>\r\n\tpublic <%= allobjectdata.name %>Interface get_<%= allobjectdata.name %>Interface() {\r\n\t\treturn _<%= allobjectdata.name %>_var;\r\n\t}\r\n}",
    "java/gridlabd-config.json.ejs": "{\r\n    \"federateName\": \"<%=classname%>\",\r\n    \"federationId\": \"<%=projectName%>\",\r\n    \"fomFilepath\": \"conf/<%=classname%>.xml\",\r\n    \"maxReconnectAttempts\": 12,\r\n    \"waitReconnectMs\": 5000,\r\n    \"isLateJoiner\": false,\r\n    \"stepSize\": <%=step%>,\r\n    \"lookAhead\": <%=lookahead%>,\r\n    \"workingDirectory\": \".\",\r\n    \"modelFilePath\": \"model.glm\"\r\n}\r\n",
    "java/gridlabd-run.sh.ejs": "#!/bin/bash\r\njava -Djava.net.preferIPv4Stack=true -Dlog4j.configurationFile=conf/log4j2.xml -jar <%=jarfile%> conf/<%=classname%>.json\r\n",
    "java/interaction.java.ejs": "<% /* ////////////////////////////////////////////////////////////////////////////////////// */ -%>\r\n<% /* This template generates the Java code for the implementation of the federate           */ -%>\r\n<% /* interaction classes located in the \"interactions\" package of the generated file set,   */ -%>\r\n<% /* as indicated by the items marked with '*****' below                                    */ -%>\r\n<% /*                                                                                        */ -%>\r\n<% /*     [top]                                                                              */ -%>\r\n<% /*         base                                                                           */ -%>\r\n<% /*             _SomeFederate.java                                                         */ -%>\r\n<% /*         interactions                                                                   */ -%>\r\n<% /*             SomeInteractionA.java  *****                                               */ -%>\r\n<% /*             SomeInteractionB.java  *****                                               */ -%>\r\n<% /*             ...                                                                        */ -%>\r\n<% /*         reflections                                                                    */ -%>\r\n<% /*             SomeReflectionA.java                                                       */ -%>\r\n<% /*             SomeReflectionB.java                                                       */ -%>\r\n<% /*             ...                                                                        */ -%>\r\n<% /*         SomeFederate.java                                                              */ -%>\r\n<% /* ////////////////////////////////////////////////////////////////////////////////////// */ -%>\r\n/*\r\n * This software is contributed as a public service by The National Institute of Standards\r\n * and Technology (NIST) and is not subject to U.S. Copyright\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the \"Software\"), to deal in the Software\r\n * without restriction, including without limitation the rights to use, copy, modify,\r\n * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above NIST contribution notice and this permission and disclaimer notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\r\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\r\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. THE AUTHORS OR COPYRIGHT HOLDERS SHALL\r\n * NOT HAVE ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR\r\n * MODIFICATIONS.\r\n */\r\n\r\nimport java.util.Collections;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\nimport gov.nist.ucef.hla.base.HLAInteraction;\r\nimport gov.nist.ucef.hla.base.RTIAmbassadorWrapper;\r\nimport gov.nist.ucef.hla.base.Types.DataType;\r\n\r\npublic class <%= classname %> extends HLAInteraction\r\n{\r\n    //----------------------------------------------------------\r\n    //                    STATIC VARIABLES\r\n    //----------------------------------------------------------\r\n    // HLA identifier of this type of interaction\r\n    private static final String INTERACTION_NAME = \"HLAinteractionRoot.<%= classname %>\";\r\n\r\n    // interaction parameters and types\r\n<% datamembers.forEach(function(parameter){ -%>\r\n<% var paramName = parameter.name.trim() -%>\r\n<% var allCapsParamName = paramName.toUpperCase() -%>\r\n<% var allCapsParamType = parameter.parameterType.toUpperCase().trim() -%>\r\n    private static final String PARAM_KEY_<%= allCapsParamName %> = \"<%= paramName %>\";\r\n    private static final DataType PARAM_TYPE_<%= allCapsParamName %> = DataType.<%= parameter.parameterType.toUpperCase() %>;\r\n<% }); -%>\r\n\r\n    // a map for finding a data type for a parameter name - this is to provide\r\n    // quick lookups and avoid iterating over all parameters\r\n    private static final Map<String,DataType> PARAMETERS_LOOKUP =\r\n        Collections.unmodifiableMap( initializeMapping() );\r\n\r\n    //----------------------------------------------------------\r\n    //                   INSTANCE VARIABLES\r\n    //----------------------------------------------------------\r\n\r\n    //----------------------------------------------------------\r\n    //                      CONSTRUCTORS\r\n    //----------------------------------------------------------\r\n    /**\r\n     * Default constructor\r\n    */\r\n    public <%= classname %>()\r\n    {\r\n        super( INTERACTION_NAME, null );\r\n    }\r\n\r\n    /**\r\n    * @param interaction the {@link HLAInteraction} instance\r\n    */\r\n    public <%= classname %>( HLAInteraction interaction )\r\n    {\r\n        super( interaction );\r\n    }\r\n\r\n    //----------------------------------------------------------\r\n    //                    INSTANCE METHODS\r\n    //----------------------------------------------------------\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////////////////\r\n    /////////////////////////////// Accessor and Mutator Methods ///////////////////////////////\r\n    ////////////////////////////////////////////////////////////////////////////////////////////\r\n<% datamembers.forEach(function(parameter){ -%>\r\n<% var paramName = parameter.name.trim() -%>\r\n<% var allCapsParamName = paramName.toUpperCase() -%>\r\n<% var initialCapParamName = allCapsParamName.charAt(0)+paramName.substr(1) -%>\r\n<% var paramType = parameter.parameterType.trim() -%>\r\n<% var allLowerParamType = paramType.toLowerCase() -%>\r\n<% var initialCapParamType = paramType.charAt(0).toUpperCase()+paramType.substr(1) -%>\r\n<% paramType = allLowerParamType === 'string'?initialCapParamType:allLowerParamType -%>\r\n    /**\r\n    * Determine whether the '<%= paramName %>' parameter has a value set for it\r\n    *\r\n    * @return true if a value has been set, false if the parameter value has\r\n    *         never been initialised (i.e., is currently invalid/indeterminate)\r\n    */\r\n    public boolean is<%= initialCapParamName %>Present()\r\n    {\r\n        return isPresent( PARAM_KEY_<%= allCapsParamName %> );\r\n    }\r\n\r\n    /**\r\n    * Set the value for the '<%= paramName %>' parameter\r\n    *\r\n    * @param value the value to set\r\n    * @return this {@link <%= classname %>} instance for method chaining\r\n    */\r\n    public <%= classname %> <%= paramName %>( <%= paramType %> value )\r\n    {\r\n        setValue( PARAM_KEY_<%= allCapsParamName %>, value );\r\n        return this;\r\n    }\r\n\r\n    /**\r\n    * Obtain the current value for the '<%= paramName %>' parameter.\r\n    *\r\n    * <b>NOTE:</b>The {@link #is<%= initialCapParamName %>Present()} method  should be used first\r\n    * to determine whether the parameter has any value <i>>at all</i>. Trying to obtain the\r\n    * value from a parameter which has never been initialized with a value\r\n    * (i.e., is currently invalid/indeterminate) will cause a {@link RuntimeException}.\r\n    *\r\n    * See also {@link #<%= paramName %>OrDefault()}, which provides a alternative\r\n    * \"safe\" way to obtain the parameter's value.\r\n    *\r\n    * @return the current value for the parameter\r\n    */\r\n    public <%= paramType %> <%= paramName %>()\r\n    {\r\n        return getAs<%= initialCapParamType %>( PARAM_KEY_<%= allCapsParamName %> );\r\n    }\r\n\r\n    /**\r\n    * Provides a \"safe\" way to obtain the current value for the '<%= paramName %>' parameter,\r\n    * using the the given default value in the case that the parameter has not been initialized\r\n    * with a value.\r\n    *\r\n    * @return the current value for the parameter, or the default value if the\r\n    *         parameter has not yet been initialized.\r\n    */\r\n    public <%= paramType %> <%= paramName %>OrDefault( <%= paramType %> defaultValue )\r\n    {\r\n        try { return this.<%= paramName %>(); } catch( Exception e) { return defaultValue; }\r\n    }\r\n<% }); -%>\r\n\r\n    //----------------------------------------------------------\r\n    //                     STATIC METHODS\r\n    //----------------------------------------------------------\r\n    /**\r\n    * Obtain the HLA interaction name identifying this type of interaction\r\n    *\r\n    * @return the HLA interaction name identifying this interaction\r\n    */\r\n    public static String interactionClassName()\r\n    {\r\n        return INTERACTION_NAME;\r\n    }\r\n\r\n    /**\r\n    * Determine whether a named parameter is associated with this kind of interaction\r\n    *\r\n    * @param parameter the name of the parameter to check for\r\n    * @return true if the named parameter is associated with this kind of interaction,\r\n    *         and false otherwise\r\n    */\r\n    public static boolean hasParameter( String parameter )\r\n    {\r\n        return PARAMETERS_LOOKUP.containsKey( parameter );\r\n    }\r\n\r\n    /**\r\n    * Obtain the names of the parameters associated with this kind of interaction\r\n    *\r\n    * @return a {@link Set<String>} containing the {@link String} names of the parameters\r\n    */\r\n    public static Set<String> parameterNames()\r\n    {\r\n        return PARAMETERS_LOOKUP.keySet();\r\n    }\r\n\r\n    /**\r\n    * Obtain the {@link DataType} of a parameter of this kind of interaction\r\n    *\r\n    * @param parameter the name of the parameter to obtain the type for\r\n    * @return a {@link DataType} corresponding to the type of the parameter. If no such\r\n    *         parameter exists for this interaction, {@link DataType#UNKNOWN} will be\r\n    *         returned.\r\n    */\r\n    public static DataType parameterType( String parameter )\r\n    {\r\n        return PARAMETERS_LOOKUP.getOrDefault( parameter, DataType.UNKNOWN );\r\n    }\r\n\r\n    /**\r\n    * Obtain the parameters associated with this kind of interaction\r\n    *\r\n    * @return an (unmodifiable) {@link Map} associating the {@link String} names of the\r\n    *         parameters and their {@link DataType}s\r\n    */\r\n    public static Map<String,DataType> parameters()\r\n    {\r\n        return Collections.unmodifiableMap( PARAMETERS_LOOKUP );\r\n    }\r\n\r\n    /**\r\n    * Private initializer method for the parameter-datatype lookup map\r\n    *\r\n    * @return a lookup map which pairs parameter names and the corresponding {@link DataType}s\r\n    */\r\n    private static Map<String,DataType> initializeMapping()\r\n    {\r\n        Map<String,DataType> lookupMap = new HashMap<String,DataType>();\r\n<% datamembers.forEach(function(parameter){ -%>\r\n        lookupMap.put( PARAM_KEY_<%= parameter.name.toUpperCase() %>, PARAM_TYPE_<%= parameter.name.toUpperCase() %> );\r\n<% }); -%>\r\n        return lookupMap;\r\n    }\r\n}\r\n",
    "java/interfacecommon.java.ejs": "<% /*interfacecommon(isinteraction,classname,parentclassname,hlaclassname,datamembers,alldatamembers) */ %>\r\n\r\n/**\r\n* Returns the handle (RTI assigned) of this instance's <%=isinteraction?\"interaction\":\"object\"%> class .\r\n* \r\n* @return the handle (RTI assigned) if this instance's <%=isinteraction?\"interaction\":\"object\"%> class\r\n*/\r\npublic int getClassHandle();\r\n\r\n/**\r\n* Returns the fully-qualified (dot-delimited) name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class.\r\n* \r\n* @return the fully-qualified (dot-delimited) name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class\r\n*/\r\npublic String getClassName();\r\n\r\n/**\r\n* Returns the simple name (last name in its fully-qualified dot-delimited name)\r\n* of this instance's <%=isinteraction?\"interaction\":\"object\"%> class.\r\n* \r\n* @return the simple name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class \r\n*/\r\npublic String getSimpleClassName();\r\n\r\n/**\r\n* Returns a set containing the names of all of the non-hidden<%=isinteraction?\"parameter\":\"attribute\"%>s of an\r\n* <%=isinteraction?\"interaction\":\"object\"%> class instance.\r\n*\r\n* @return set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\r\n* <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n*/\r\npublic Set< String > get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names();\r\n\r\n/**\r\n* Returns a set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\r\n* <%=isinteraction?\"interaction\":\"object\"%> class instance.\r\n*\r\n* @return set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\r\n* <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n*/\r\npublic Set< String > getAll<%=isinteraction?\"Parameter\":\"Attribute\"%>Names();\r\n\r\n/**\r\n* Publishes the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of the class for a federate.\r\n*\r\n* @param rti handle to the Local RTI Component\r\n*/\r\npublic void publish<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti );\r\n\r\n/**\r\n* Unpublishes the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class for a federate.\r\n*\r\n* @param rti handle to the Local RTI Component\r\n*/\r\npublic void unpublish<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti );\r\n\r\n/**\r\n* Subscribes a federate to the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class.\r\n*\r\n* @param rti handle to the Local RTI Component\r\n*/\r\npublic void subscribe<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti );\r\n\r\n/**\r\n* Unsubscribes a federate from the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class.\r\n*\r\n* @param rti handle to the Local RTI Component\r\n*/\r\npublic void unsubscribe<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti );\r\n\r\n<% if(isinteraction){ %><% }else{ %>\r\n/**\r\n* Returns a data structure containing the handles of all attributes for this object\r\n* class that are currently marked for subscription.  To actually subscribe to these\r\n* attributes, a federate must call <objectclassname>.subscribe( RTIambassador rti ).\r\n*\r\n* @return data structure containing the handles of all attributes for this object\r\n* class that are currently marked for subscription\r\n*/\r\npublic AttributeHandleSet getSubscribedAttributeHandleSet();\r\n<%}%>",
    "java/interfaceroot.java.ejs": "<% /* classrootinterface(isinteraction)*/ %>\r\npackage org.cpswt.hla;\r\n\r\nimport java.util.*;\r\nimport hla.rti.*;\r\n\r\npublic interface <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface\r\n{\r\n    public int getUniqueID();\r\n\r\n    <%-ejs.render(\r\n        TEMPLATES[\"java/interfacecommon.java.ejs\"],{\r\n            isinteraction: isinteraction,\r\n            classname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\r\n            parentclassname: \"\",\r\n            hlaclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\r\n            datamembers: [],\r\n            alldatamembers: []\r\n    })%>\r\n\r\n    \r\n<% if(isinteraction){ %><%}else{%>\r\n    /**\r\n    * Requests an attribute update for this object instance from the federate that\r\n    * has modification rights on these attributes.\r\n    *\r\n    * @param rti handle to the Local RTI Component\r\n    */\r\n    public void requestUpdate( RTIambassador rti );\r\n\r\n    /**\r\n    * Returns the handle (RTI assigned) the corresponds to this object class\r\n    * instance.  This handle is the instance's unique identifier to the RTI.\r\n    *\r\n    * @return the handle (RTI assigned) of this object class instance.\r\n    */\r\n    public int getObjectHandle();\r\n<%}%>\r\n\r\n    /**\r\n    * Returns the timestamp for this <%=isinteraction?\"interaction\":\"object\"%>.  \"receive order\" <%=isinteraction?\"interaction\":\"object\"%>s\r\n    * should have a timestamp of -1.\r\n    *\r\n    * @return timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\r\n    */\r\n    public double getTime();\r\n    \r\n    /**\r\n    * Sets the timestamp of this <%=isinteraction?\"interaction\":\"object\"%> to \"time\".\r\n    *\r\n    * @param time new timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\r\n    */\r\n    public void setTime( double time );\r\n\r\n    /**\r\n    * Sets the timestamp of this <%=isinteraction?\"interaction\":\"object\"%> to \"logicalTime\".\r\n    *\r\n    * @param logicalTime new timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\r\n    */\r\n    public void setTime( LogicalTime logicalTime );\r\n\r\n    /**\r\n    * Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" for this\r\n    * <%=isinteraction?\"interaction\":\"object\"%>.\r\n    *\r\n    * @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value to retrieve\r\n    * @return the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose name is \"datamemberName\"\r\n    */\r\n    public Object get<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName );\r\n\r\n    /**\r\n    * Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose handle is \"datamemberHandle\"\r\n    * (RTI assigned) for this <%=isinteraction?\"interaction\":\"object\"%>.\r\n    *\r\n    * @param datamemberHandle handle (RTI assigned) of <%=isinteraction?\"parameter\":\"attribute\"%> whose\r\n    * value to retrieve\r\n    * @return the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose handle is \"datamemberHandle\"\r\n    */\r\n    public Object get<%=isinteraction?\"Parameter\":\"Attribute\"%>( int datamemberHandle );\r\n        \r\n    /**\r\n    * Set the values of the <%=isinteraction?\"parameter\":\"attribute\"%>s in this <%=isinteraction?\"interaction\":\"object\"%> using\r\n    * \"datamemberMap\".  \"datamemberMap\" is usually acquired as an argument to\r\n    * an RTI federate callback method such as \"receiveInteraction\".\r\n    *\r\n    * @param datamemberMap  contains new values for the <%=isinteraction?\"parameter\":\"attribute\"%>s of\r\n    * this <%=isinteraction?\"interaction\":\"object\"%>\r\n    */\r\n    public void set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap );\r\n\r\n    /**\r\n    * Sets the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" to \"value\"\r\n    * in this <%=isinteraction?\"interaction\":\"object\"%>.  \"value\" is converted to data type of \"datamemberName\"\r\n    * if needed.\r\n    * This action can also be affected by calling the set_<datamemberName>( value )\r\n    * method on the <%=isinteraction?\"interaction\":\"object\"%> using a reference to the <%=isinteraction?\"interaction\":\"object\"%>'s actual\r\n    * class.\r\n    *\r\n    * @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be set\r\n    * to \"value\"\r\n    * @param value new value of <%=isinteraction?\"parameter\":\"attribute\"%> called \"datamemberName\"\r\n    */\r\n    public void set<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName, String value );\r\n\r\n    /**\r\n    * Sets the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" to \"value\"\r\n    * in this <%=isinteraction?\"interaction\":\"object\"%>.  \"value\" should have the same data type as that of\r\n    * the \"datamemberName\" <%=isinteraction?\"parameter\":\"attribute\"%>.\r\n    * This action can also be affected by calling the set_<datamemberName>( value )\r\n    * method on the <%=isinteraction?\"interaction\":\"object\"%> using a reference to the <%=isinteraction?\"interaction\":\"object\"%>'s actual\r\n    * class.\r\n    *\r\n    * @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be set\r\n    * to \"value\"\r\n    * @param value new value of <%=isinteraction?\"parameter\":\"attribute\"%> called \"datamemberName\"\r\n    */\r\n    public void set<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName, Object value );\r\n\r\n<% if(isinteraction){ %>\r\n    /**\r\n    * Sends this interaction to the RTI, with the specified timestamp \"time\".\r\n    * This method should be used to send interactions that have \"timestamp\"\r\n    * ordering.\r\n    *\r\n    * @param rti handle to the Local RTI Component\r\n    * @param time timestamp for this interaction.  The timestamp should be no\r\n    * less than the current federation time + the LOOKAHEAD value of the federate\r\n    * sending this interaction.\r\n    */\r\n    public void sendInteraction( RTIambassador rti, double time ) throws Exception;\r\n\r\n    /**\r\n    * Sends this interaction to the RTI (without a timestamp).\r\n    * This method should be used to send interactions that have \"receive\"\r\n    * ordering.\r\n    *\r\n    * @param rti handle to the Local RTI Component\r\n    */\r\n    public void sendInteraction( RTIambassador rti ) throws Exception ;\r\n<%}else{%>\r\n    /**\r\n    * Registers this object with the RTI.  This method is usually called by a\r\n    * federate who \"owns\" this object, i.e. the federate that created it and\r\n    * has write-privileges to its attributes (so, it is responsible for updating\r\n    * these attribute and conveying their updated values to the RTI).\r\n    *\r\n    * @param rti handle to the Local RTI Component\r\n    */ \r\n    public void registerObject( RTIambassador rti );\r\n    \r\n    /**\r\n    * Unregisters this object with the RTI.  The RTI will destroy all information\r\n    * it contains regarding this object as a result.  This method is usually\r\n    * called by a federate who \"owns\" this object, i.e. the federate that created\r\n    * it and has write-privileges to its attributes.\r\n    *\r\n    * @param rti handle to the Local RTI Component\r\n    */ \r\n    public void unregisterObject( RTIambassador rti );\r\n\r\n    /**\r\n    * Broadcasts the attributes of this object and their values to the RTI, where\r\n    * the values have \"time\" as their timestamp.  This call should be used for\r\n    * objects whose attributes have \"timestamp\" ordering.\r\n    *\r\n    * @param rti handle to the Local RTI Component\r\n    * @param time timestamp on attribute values of this object\r\n    * @param force if \"false\", only the attributes whose values have changed since\r\n    * the last call to \"updateAttributeValues\" will be broadcast to the RTI.  If\r\n    * \"true\", all attributes and their values are broadcast to the RTI.\r\n    */\r\n    public void updateAttributeValues( RTIambassador rti, double time, boolean force );\r\n\r\n    /**\r\n    * Like {@link #updateAttributeValues( RTIambassador rti, double time, boolean force )},\r\n    * except \"force\" is always false.\r\n    *\r\n    * @param rti handle to the Local RTI Component\r\n    * @param time timestamp on attribute values of this object\r\n    */\r\n    public void updateAttributeValues( RTIambassador rti, double time );\r\n\r\n    /**\r\n    * Broadcasts the attributes of this object and their values to the RTI (with\r\n    * no timestamp).  This call should be used for objects whose attributes have\r\n    * \"receive\" ordering.\r\n    *\r\n    * @param rti handle to the Local RTI Component\r\n    * @param force if \"false\", only the attributes whose values have changed since\r\n    * the last call to \"updateAttributeValues\" will be broadcast to the RTI.  If\r\n    * \"true\", all attributes and their values are broadcast to the RTI.\r\n    */\r\n    public void updateAttributeValues( RTIambassador rti, boolean force );\r\n\r\n    /**\r\n    * Like {@link #updateAttributeValues( RTIambassador rti, boolean force )},\r\n    * except \"force\" is always false.\r\n    *\r\n    * @param rti handle to the Local RTI Component\r\n    */\r\n    public void updateAttributeValues( RTIambassador rti );    \r\n<%}%>    \r\n}",
    "java/labview-config.json.ejs": "{\r\n    \"federateName\": \"<%=classname%>\",\r\n    \"federationId\": \"<%=projectName%>\",\r\n    \"fomFilepath\": \"conf/<%=classname%>.xml\",\r\n    \"maxReconnectAttempts\": 12,\r\n    \"waitReconnectMs\": 5000,\r\n    \"isLateJoiner\": false,\r\n    \"stepSize\": <%=step%>,\r\n    \"lookAhead\": <%=lookahead%>,\r\n    \"hostAddress\": \"localhost\",\r\n    \"outgoingPort\": 1234,\r\n    \"incomingPort\": 9119\r\n}\r\n",
    "java/labview-pom.xml.ejs": "<?xml version=\"1.0\"?>\r\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n    <modelVersion>4.0.0</modelVersion>\r\n    <parent>\r\n        <groupId><%= groupId %></groupId>\r\n        <artifactId><%= projectName %>-root</artifactId>\r\n        <version><%= projectVersion %></version>\r\n    </parent>\r\n    <artifactId>LabView</artifactId>\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId><%= labviewPOM.groupId %></groupId>\r\n            <artifactId><%= labviewPOM.artifactId %></artifactId>\r\n            <version><%= labviewPOM.version %></version>\r\n        </dependency>\r\n    </dependencies>\r\n    <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.apache.maven.plugins</groupId>\r\n                <artifactId>maven-dependency-plugin</artifactId>\r\n                <version>3.1.1</version>\r\n                <executions>\r\n                    <execution>\r\n                        <id>copy-dependencies</id>\r\n                        <phase>package</phase>\r\n                        <goals>\r\n                            <goal>copy-dependencies</goal>\r\n                        </goals>\r\n                        <configuration>\r\n                            <outputDirectory>${project.basedir}</outputDirectory>\r\n                            <overWriteReleases>true</overWriteReleases>\r\n                            <overWriteSnapshots>true</overWriteSnapshots>\r\n                            <overWriteIfNewer>true</overWriteIfNewer>\r\n                        </configuration>\r\n                    </execution>\r\n                </executions>\r\n            </plugin>\r\n            <plugin>\r\n                <groupId>org.apache.maven.plugins</groupId>\r\n                <artifactId>maven-resources-plugin</artifactId>\r\n                <version>3.1.0</version>\r\n                <executions>\r\n                    <execution>\r\n                        <id>copy-resources</id>\r\n                        <phase>package</phase>\r\n                        <goals>\r\n                            <goal>copy-resources</goal>\r\n                        </goals>\r\n                        <configuration>\r\n                            <outputDirectory>${basedir}/project</outputDirectory>\r\n                            <resources>\r\n                                <resource>\r\n                                    <directory><%= rootdir %>/ucef-labview/base-project</directory>\r\n                                </resource>\r\n                            </resources>\r\n                            <overwrite>false</overwrite>\r\n                        </configuration>\r\n                    </execution>\r\n                </executions>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n</project>\r\n\r\n",
    "java/labview-run.sh.ejs": "#!/bin/bash\r\njava -Djava.net.preferIPv4Stack=true -Dlog4j.configurationFile=conf/log4j2.xml -jar <%=jarfile%> conf/<%=classname%>.json\r\n",
    "java/log4j2.xml.ejs": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<Configuration status=\"WARN\">\r\n    <Appenders>\r\n        <Console\r\n            name=\"Console\"\r\n            target=\"SYSTEM_OUT\">\r\n            <PatternLayout pattern =\r\n                \"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/>\r\n        </Console>\r\n        <File\r\n            name=\"File\"\r\n            fileName=\"<%= projectName %>.log\"\r\n            immediateFlush=\"false\"\r\n            append=\"false\">\r\n            <PatternLayout pattern =\r\n              \"%d{yyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/>\r\n        </File>\r\n    </Appenders>\r\n    <Loggers>\r\n        <Root level=\"INFO\">\r\n            <AppenderRef ref=\"Console\" />\r\n        </Root>\r\n    </Loggers>\r\n</Configuration>\r\n",
    "java/mapperfederate.java.ejs": "<% /*group mapperfederate;\r\n\r\nmapperfederate(\r\n    classname,\r\n\tsimname,\r\n\tstep_size,\r\n\tmappingconnsdata,\r\n\tmappingobjectsdata\r\n) ::= <<*/ -%>\r\n\r\npackage <%=simname%>;\r\n\r\nimport java.util.StringTokenizer;\r\nimport java.util.regex.Pattern;\r\nimport java.util.regex.Matcher;\r\nimport hla.rti.EventRetractionHandle;\r\nimport hla.rti.LogicalTime;\r\nimport hla.rti.ReceivedInteraction;\r\nimport org.cpswt.hla.*;\r\n\r\npublic class <%=classname%> extends <%=classname%>Base {\r\n\r\n    private static Pattern pattern = Pattern.compile( \"[^#]\" );\r\n\r\n\tpublic <%=classname%>(String federationId, String federateId)\r\n\t\t\tthrows Exception {\r\n\t\tsuper(federationId, federateId);\r\n\t}\r\n\r\n    public <%=classname%>( String[] args ) throws Exception {\r\n        super( args );\r\n    }\r\n    \r\n    private static double STEP_EPSILON = 0.000001;\r\n    \r\n    public boolean isMapperFederate() {\r\n        return true;\r\n    }\r\n\r\n    <% /*mappingconnsdata:mappingconnections()*/ %>\r\n    <% mappingconnsdata.forEach(function(mappingconnectiondata){ %>\r\n\t///////////////////////////////////////////////////////////////////////////////////////\r\n\t//\r\n\t// For <% if(mappingconnectiondata.isSimpleConn){ %>Simple<% }else{ %>Complex<% } %>MappingConnection (ID: <%=mappingconnectiondata.uniqueId%>) between interactions:\r\n\t//\r\n\t//         <%=mappingconnectiondata.lHSInteractionName%> --to--> <%=mappingconnectiondata.rHSInteractionName%>\r\n\t//\r\n\t// This <% if(mappingconnectiondata.isSimpleConn){ %>Simple<% }else{ %>Complex<% } %>MappingConnection is located at:\r\n\t//\r\n\t//         <%=mappingconnectiondata.parentPath%>\r\n\t//\r\n\t///////////////////////////////////////////////////////////////////////////////////////\r\n\tpublic boolean isGuardConditionMet_<%=mappingconnectiondata.lHSInteractionName%>_to_<%=mappingconnectiondata.rHSInteractionName%>_<%=mappingconnectiondata.uniqueId%>(<%=mappingconnectiondata.lHSInteractionName%> i1) {\r\n\t\t<%-mappingconnectiondata.guardCondition%>\r\n\t\t<% if(mappingconnectiondata.guardConditionInvalid){ %>return true;<% } %>\r\n\t}\r\n\r\n\r\n\tpublic <%=mappingconnectiondata.rHSInteractionName%> map_<%=mappingconnectiondata.lHSInteractionName%>_to_<%=mappingconnectiondata.rHSInteractionName%>_<%=mappingconnectiondata.uniqueId%>(<%=mappingconnectiondata.lHSInteractionName%> i1) {\r\n\t\t<%=mappingconnectiondata.rHSInteractionName%> o1 = create_<%=mappingconnectiondata.rHSInteractionName%>();\r\n\t\tInteractionRoot o1IR = (InteractionRoot) o1;\r\n\t    <% if(mappingconnectiondata.isMappedInteractionANetworkPacket){ %>\r\n\t\tboolean __NETWORK_PACKET_CORRUPT__ = false;\r\n\t\tInteractionRoot __I1__ = (InteractionRoot) i1;\r\n\t\tif(__I1__ instanceof NetworkPacket ) {\r\n\t    \tint numParams = o1.getParameterNames().size();\r\n\t    \tString __DATA__ = ((NetworkPacket) __I1__).get_data();\r\n\t    \tif(numParams > 0) {\r\n\t\t\t    Matcher matcher = pattern.matcher( __DATA__ );\r\n\t\t\t    if ( !matcher.find() ) {\r\n\t    \t\t\t__NETWORK_PACKET_CORRUPT__ = true;\r\n\t    \t\t\tif(o1IR instanceof NetworkPacket && __DATA__.length() == 0 ) {\r\n\t\t\t    \t\t__NETWORK_PACKET_CORRUPT__ = false;\r\n\t\t\t    \t}\r\n\t    \t\t}\r\n\t    \t} else {\r\n\t    \t\tif(__DATA__.length() > 0) {\r\n\t    \t\t\t__NETWORK_PACKET_CORRUPT__ = true;\r\n\t    \t\t}\r\n\t    \t}\r\n\t\t}\r\n\t\tif(!__NETWORK_PACKET_CORRUPT__) {\r\n\t\t    <% if(mappingconnectiondata.isMappingSpecsNotEmpty){ %>\r\n\t\t\t<%-mappingconnectiondata.mappingSpecs%><%}%>\r\n\t\t}\r\n\t\t<% }else{ %>\r\n\t    <% if(mappingconnectiondata.isMappingSpecsNotEmpty){ %>\r\n\t\t<%-mappingconnectiondata.mappingSpecs%><%}%>\r\n\t\t<%}%>\r\n\r\n\t\to1.set_originFed(i1.get_originFed());\r\n\t\to1.set_actualLogicalGenerationTime(i1.get_actualLogicalGenerationTime());\r\n\r\n\t\treturn o1;\r\n\t}\r\n    <%/*EMPTY*/});%>\r\n    \r\n    <% /*mappingobjectsdata:mappingobjects()*/ %>\r\n    <% mappingobjectsdata.forEach(function(mappingobjectdata){ %><%/*EMPTY*/});%>\r\n    \r\n\r\n\t<% /*execute_method()*/ %>\r\n\tpublic void execute() throws Exception {\r\n\t    double currentTime = 0;\r\n\r\n\t    AdvanceTimeRequest atr = new AdvanceTimeRequest( currentTime );\r\n\t    putAdvanceTimeRequest( atr );\r\n\r\n\t    readyToPopulate();\r\n\t    readyToRun();\r\n\r\n\t    startAdvanceTimeThread(TIME_ADVANCE_MODE.NEXT_EVENT_REQUEST_AVAILABLE);\r\n\r\n\t    while( true ) {\r\n\t    \tSystem.out.print( \"<%=classname%>: Requesting RTI to proceed to (\" + currentTime + \")...\" );\r\n\t    \t\r\n\t        atr.requestSyncStart();\r\n\t        currentTime = atr.getCurrentTime();\r\n\r\n\t        System.out.println( \"granted!\" );\r\n\r\n\t        InteractionRoot interactionRoot;\r\n\r\n\t        System.out.println(\"Now waiting to receive an interaction...\");\r\n\t        while(  ( interactionRoot = getNextInteractionNoWait() ) != null ) {\r\n\t            \t\r\n\t\t\t\tSystem.out.println( \"<%=classname%>: received interaction: \\\"\" + interactionRoot + \"\\\" at time: \" + getCurrentTime() );\r\n\r\n\t\t\t\tboolean interactionMapped = false;\t\t\t\r\n\t\t\t\t<% /*mappingconnsdata:mappingCheck()*/ %>\r\n\t\t\t\t<% mappingconnsdata.forEach(function(mappingconnectiondata){%>\r\n\t\t\t\tif( interactionRoot instanceof <%=mappingconnectiondata.lHSInteractionName%> ) {\r\n\t\t\t\t\t<%=mappingconnectiondata.lHSInteractionName%> i1 = (<%=mappingconnectiondata.lHSInteractionName%>) interactionRoot;\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tif(  !(interactionRoot instanceof NetworkPacket) || \"<%=mappingconnectiondata.rHSInteractionName%>\".equals(((NetworkPacket) interactionRoot).get_packetType())  ) {\r\n\t\r\n\t\t\t\t\t\t\tif( isGuardConditionMet_<%=mappingconnectiondata.lHSInteractionName%>_to_<%=mappingconnectiondata.rHSInteractionName%>_<%=mappingconnectiondata.uniqueId%>(i1) ) {\r\n\t\t\t\t\t\t\t\t<%=mappingconnectiondata.rHSInteractionName%> o1 = map_<%=mappingconnectiondata.lHSInteractionName%>_to_<%=mappingconnectiondata.rHSInteractionName%>_<%=mappingconnectiondata.uniqueId%>(i1);\r\n\t\t\t\t\t\t\t\tSystem.out.println( \"<%=classname%>: Sending interaction: \" + o1 );\r\n\t\t\t\t\t\t\t\to1.sendInteraction( getRTI(), getMinTSOTimestamp() );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tinteractionMapped = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t<% if(mappingconnectiondata.areBothEndsOfMappingANetworkPacket){ %>\r\n\t\t\t\t\t\t// Or, if it is a mapping from an interaction type to itself then only check the guard condition\r\n\t\t\t\t\t\tif ( interactionRoot instanceof NetworkPacket && \"<%=mappingconnectiondata.lHSInteractionName%>\".equals(\"<%=mappingconnectiondata.rHSInteractionName%>\") ) {\r\n\t\t\t\t\t\t\tif( isGuardConditionMet_NetworkPacket_to_NetworkPacket_<%=mappingconnectiondata.uniqueId%>(i1) ) {\r\n\t\t\t\t\t\t\t\tNetworkPacket o1 = map_NetworkPacket_to_NetworkPacket_<%=mappingconnectiondata.uniqueId%>(i1);\r\n\t\t\t\t\t\t\t\tSystem.out.println( \"<%=classname%>: Sending interaction: \" + o1 );\r\n\t\t\t\t\t\t\t\to1.sendInteraction( getRTI(), getMinTSOTimestamp() );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tinteractionMapped = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t<% } %>\r\n\t\t\t\t}<%});%>\r\n\r\n\t\t\t\tif( !interactionMapped ) {\r\n\t          \t\tSystem.out.println( \"<%=classname%>: Received unknown interaction: \" + interactionRoot );\r\n\t           \t}\r\n\t        }\r\n\r\n\t        currentTime = getCurrentTime() + <%=step_size%> + STEP_EPSILON;\r\n\t        AdvanceTimeRequest newATR = new AdvanceTimeRequest( currentTime );\r\n\t        putAdvanceTimeRequest( newATR );\r\n\t        \r\n\t        atr.requestSyncEnd();\r\n\t        atr = newATR;\r\n\t    }\r\n\t}\r\n\r\n\t<% /*main_method()*/ %>\r\n\t/**\r\n\t * @param args\r\n\t */\r\n\tpublic static void main(String[] args) {\r\n\t    System.out.println( \"<%=classname%> federate starting\" );\r\n\t    try {\r\n\t    \t<%=classname%> mapperFed = new <%=classname%>( args );\r\n\t        mapperFed.execute();\r\n\t    } catch ( Exception e ) {\r\n\t        System.err.println( \"Exception caught: \" + e.getMessage() );\r\n\t        e.printStackTrace();\r\n\t    }\r\n\t}\r\n\r\n}\r\n",
    "java/reflection.java.ejs": "<% /* ////////////////////////////////////////////////////////////////////////////////////// */ -%>\r\n<% /* This template generates the Java code for the implementation of the federate           */ -%>\r\n<% /* reflection classes located in the \"reflections\" package of the generated file set,     */ -%>\r\n<% /* as indicated by the items marked with '*****' below                                    */ -%>\r\n<% /*                                                                                        */ -%>\r\n<% /*     [top]                                                                              */ -%>\r\n<% /*         base                                                                           */ -%>\r\n<% /*             _SomeFederate.java                                                         */ -%>\r\n<% /*         reflections                                                                    */ -%>\r\n<% /*             SomeInteractionA.java                                                      */ -%>\r\n<% /*             SomeInteractionB.java                                                      */ -%>\r\n<% /*             ...                                                                        */ -%>\r\n<% /*         reflections                                                                    */ -%>\r\n<% /*             SomeReflectionA.java   *****                                               */ -%>\r\n<% /*             SomeReflectionB.java   *****                                               */ -%>\r\n<% /*             ...                                                                        */ -%>\r\n<% /*         SomeFederate.java                                                              */ -%>\r\n<% /* ////////////////////////////////////////////////////////////////////////////////////// */ -%>\r\n/*\r\n * This software is contributed as a public service by The National Institute of Standards\r\n * and Technology (NIST) and is not subject to U.S. Copyright\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this\r\n * software and associated documentation files (the \"Software\"), to deal in the Software\r\n * without restriction, including without limitation the rights to use, copy, modify,\r\n * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to the following\r\n * conditions:\r\n *\r\n * The above NIST contribution notice and this permission and disclaimer notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\r\n * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF\r\n * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\r\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. THE AUTHORS OR COPYRIGHT HOLDERS SHALL\r\n * NOT HAVE ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR\r\n * MODIFICATIONS.\r\n */\r\n\r\nimport java.util.Collections;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n\r\nimport gov.nist.ucef.hla.base.HLAObject;\r\nimport gov.nist.ucef.hla.base.RTIAmbassadorWrapper;\r\nimport gov.nist.ucef.hla.base.Types.DataType;\r\n\r\npublic class <%= classname %> extends HLAObject\r\n{\r\n    //----------------------------------------------------------\r\n    //                    STATIC VARIABLES\r\n    //----------------------------------------------------------\r\n    // HLA identifier of this type of reflection\r\n    private static final String OBJECT_CLASS_NAME = \"HLAobjectRoot.<%= classname %>\";\r\n\r\n    // reflection attribute and types\r\n<% datamembers.forEach(function(attribute){ -%>\r\n<% var attrName = attribute.name.trim() -%>\r\n<% var allCapsAttrName = attrName.toUpperCase() -%>\r\n<% var allCapsParamType = attribute.parameterType.toUpperCase().trim() -%>\r\n    private static final String ATTRIBUTE_KEY_<%= allCapsAttrName %> = \"<%= attrName %>\";\r\n    private static final DataType ATTRIBUTE_TYPE_<%= allCapsAttrName %> = DataType.<%= attribute.parameterType.toUpperCase() %>;\r\n<% }); -%>\r\n\r\n    // a map for finding a data type for an attribute name - this is to provide\r\n    // quick lookups and avoid iterating over all attributes\r\n    private static final Map<String,DataType> ATTRIBUTES_LOOKUP =\r\n        Collections.unmodifiableMap( initializeMapping() );\r\n\r\n    //----------------------------------------------------------\r\n    //                   INSTANCE VARIABLES\r\n    //----------------------------------------------------------\r\n\r\n    //----------------------------------------------------------\r\n    //                      CONSTRUCTORS\r\n    //----------------------------------------------------------\r\n    /**\r\n     * Default constructor\r\n    */\r\n    public <%= classname %>()\r\n    {\r\n        super( OBJECT_CLASS_NAME, null );\r\n    }\r\n\r\n    /**\r\n    * @param reflection the {@link HLAObject} instance\r\n    */\r\n    public <%= classname %>( HLAObject reflection )\r\n    {\r\n        super( reflection );\r\n    }\r\n\r\n    //----------------------------------------------------------\r\n    //                    INSTANCE METHODS\r\n    //----------------------------------------------------------\r\n\r\n    ////////////////////////////////////////////////////////////////////////////////////////////\r\n    /////////////////////////////// Accessor and Mutator Methods ///////////////////////////////\r\n    ////////////////////////////////////////////////////////////////////////////////////////////\r\n<% datamembers.forEach(function(attribute){ -%>\r\n<% var attrName = attribute.name.trim() -%>\r\n<% var allCapsAttrName = attrName.toUpperCase() -%>\r\n<% var initialCapAttrName = allCapsAttrName.charAt(0)+attrName.substr(1) -%>\r\n<% var paramType = attribute.parameterType.trim() -%>\r\n<% var allLowerParamType = paramType.toLowerCase() -%>\r\n<% var initialCapParamType = paramType.charAt(0).toUpperCase()+paramType.substr(1) -%>\r\n<% paramType = allLowerParamType === 'string'?initialCapParamType:allLowerParamType -%>\r\n    /**\r\n    * Determine whether the '<%= attrName %>' attribute has a value set for it\r\n    *\r\n    * @return true if a value has been set, false if the attribute value has\r\n    *         never been initialised (i.e., is currently invalid/indeterminate)\r\n    */\r\n    public boolean is<%= initialCapAttrName %>Present()\r\n    {\r\n        return isPresent( ATTRIBUTE_KEY_<%= allCapsAttrName %> );\r\n    }\r\n\r\n    /**\r\n    * Set the value for the '<%= attrName %>' attribute\r\n    *\r\n    * @param value the value to set\r\n    * @return this {@link <%= classname %>} instance for method chaining\r\n    */\r\n    public <%= classname %> <%= attrName %>( <%= paramType %> value )\r\n    {\r\n        setValue( ATTRIBUTE_KEY_<%= allCapsAttrName %>, value );\r\n        return this;\r\n    }\r\n\r\n    /**\r\n    * Obtain the current value for the '<%= attrName %>' attribute.\r\n    *\r\n    * <b>NOTE:</b>The {@link #is<%= initialCapAttrName %>Present()} method  should be used first\r\n    * to determine whether the attribute has any value <i>>at all</i>. Trying to obtain the\r\n    * value from a attribute which has never been initialized with a value\r\n    * (i.e., is currently invalid/indeterminate) will cause a {@link RuntimeException}.\r\n    *\r\n    * See also {@link #<%= attrName %>OrDefault()}, which provides a alternative\r\n    * \"safe\" way to obtain the attribute's value.\r\n    *\r\n    * @return the current value for the attribute\r\n    */\r\n    public <%= paramType %> <%= attrName %>()\r\n    {\r\n        return getAs<%= initialCapParamType %>( ATTRIBUTE_KEY_<%= allCapsAttrName %> );\r\n    }\r\n\r\n    /**\r\n    * Provides a \"safe\" way to obtain the current value for the '<%= attrName %>' attribute,\r\n    * using the the given default value in the case that the attribute has not been initialized\r\n    * with a value.\r\n    *\r\n    * @return the current value for the attribute, or the default value if the\r\n    *         attribute has not yet been initialized.\r\n    */\r\n    public <%= paramType %> <%= attrName %>OrDefault( <%= paramType %> defaultValue )\r\n    {\r\n        try { return this.<%= attrName %>(); } catch( Exception e) { return defaultValue; }\r\n    }\r\n<% }); -%>\r\n\r\n    //----------------------------------------------------------\r\n    //                     STATIC METHODS\r\n    //----------------------------------------------------------\r\n    /**\r\n    * Obtain the HLA object name identifying this type of object\r\n    *\r\n    * @return the HLA object name identifying this object\r\n    */\r\n    public static String reflectionClassName()\r\n    {\r\n        return OBJECT_CLASS_NAME;\r\n    }\r\n\r\n    /**\r\n    * Determine whether a named attribute is associated with this kind of object\r\n    *\r\n    * @param attribute the name of the attribute to check for\r\n    * @return true if the named attribute is associated with this kind of object,\r\n    *         and false otherwise\r\n    */\r\n    public static boolean hasAttribute( String attribute )\r\n    {\r\n        return ATTRIBUTES_LOOKUP.containsKey( attribute );\r\n    }\r\n\r\n    /**\r\n    * Obtain the names of the attributes associated with this kind of object\r\n    *\r\n    * @return a {@link Set<String>} containing the {@link String} names of the attributes\r\n    */\r\n    public static Set<String> attributeNames()\r\n    {\r\n        return ATTRIBUTES_LOOKUP.keySet();\r\n    }\r\n\r\n    /**\r\n    * Obtain the {@link DataType} of a attribute of this kind of object\r\n    *\r\n    * @param attribute the name of the attribute to obtain the type for\r\n    * @return a {@link DataType} corresponding to the type of the attribute. If no such\r\n    *         attribute exists for this object, {@link DataType#UNKNOWN} will be\r\n    *         returned.\r\n    */\r\n    public static DataType attributeType( String attribute )\r\n    {\r\n        return ATTRIBUTES_LOOKUP.getOrDefault( attribute, DataType.UNKNOWN );\r\n    }\r\n\r\n    /**\r\n    * Obtain the attributes associated with this kind of object\r\n    *\r\n    * @return an (unmodifiable) {@link Map} associating the {@link String} names of the\r\n    *         attributes and their {@link DataType}s\r\n    */\r\n    public static Map<String,DataType> attributes()\r\n    {\r\n        return Collections.unmodifiableMap( ATTRIBUTES_LOOKUP );\r\n    }\r\n\r\n    /**\r\n    * Private initializer method for the attribute-datatype lookup map\r\n    *\r\n    * @return a lookup map which pairs attribute names and the corresponding {@link DataType}s\r\n    */\r\n    private static Map<String,DataType> initializeMapping()\r\n    {\r\n        Map<String,DataType> lookupMap = new HashMap<String,DataType>();\r\n<% datamembers.forEach(function(attribute){ -%>\r\n        lookupMap.put( ATTRIBUTE_KEY_<%= attribute.name.toUpperCase() %>, ATTRIBUTE_TYPE_<%= attribute.name.toUpperCase() %> );\r\n<% }); -%>\r\n        return lookupMap;\r\n    }\r\n}\r\n",
    "java/rti.rid.ejs": "# ================================\r\n# Portico RTI Initialization Data\r\n# ================================\r\n# This file contains all available configuration options for Portico. \r\n# Values are initially commented out and are provided shown with their default settings.\r\n#\r\n# All options are formatted as name=value pairs, the '#' and '!' characters mark comment lines\r\n#\r\n# To make use of this file, put it in the directory that your federate is executed from, or set the\r\n# RTI_RID_FILE environment variable to point at wherever it is located.\r\n#\r\n\r\n# ===================================\r\n# 1. General Portico Logging Options\r\n# ===================================\r\n# (NOTE) Some sub-components have their own log settings. See the sections relaing to them for\r\n#        those particular properties.\r\n\r\n# (1.1) Portico Log Directory\r\n#        Specify the directory to put the Portico log-files into. This defaults to \"logs\" and\r\n#        if a relative path is used, it will be releative to the location of the process that\r\n#        executed Portico\r\n#\r\n# portico.logdir = logs\r\n\r\n# (1.2) Portico Log Level\r\n#        Specify the level that Portico will log at. Valid values are: TRACE, DEBUG, INFO, WARN,\r\n#        ERROR, FATAL, OFF. The default value is \"WARN\".\r\n#\r\n# portico.loglevel = INFO\r\n\r\n# (1.3) Print FOM when federate Joins\r\n#        When a federate joins a federation, Portico can pretty-print the FOM data of that\r\n#        federation. If this is enabled, the FOM is logged to the INFO level (so make sure you\r\n#        have logging turned up high enough). By default this is disabled.\r\n#\r\n# portico.fom.print = disabled\r\n\r\n# (1.4) Logging by Handle/Name\r\n#        Making sense of log files can be difficult. To help make sense of this data, various bits\r\n#        of HLA information can be logged by their HLA handle or their name. For example, an HLA\r\n#        object class can be logged by its handle, or by its name.\r\n#\r\n#        Any items specified in logWithHandles are logged using their handles (and vice versa for\r\n#        logWithNames). The format of these properties is a comma-separated list containing any of\r\n#        the following identifiers (defaults specified in parentheses):\r\n#\r\n#        objectClass       (handle)\r\n#        attributeClass    (handle)\r\n#        interactionClass  (handle)\r\n#        parameterClass    (handle)\r\n#        objectInstance    (name)\r\n#        space             (handle)\r\n#        dimension         (handle)\r\n#        federate          (name)\r\n#\r\n#        (NOTE) You only have to specify the bits you want. If a value isn't specified in either\r\n#               list, it will assume its default value. If a value is specified in both lists, the\r\n#               logWithNames takes precedence.\r\n#\r\n# portico.logWithHandles=objectClass,attributeClass,interactionClass,parameterClass,space,dimension\r\n# portico.logWithNames=objectInstance,federate\r\n\r\n\r\n# ================================\r\n# 2. HLA Related RTI Properties\r\n# ================================\r\n# These settings relate to how the RTI works with regard to HLA operations\r\n\r\n# (2.1) Management Object Model\r\n#        This controls whether or not the MOM is enabled. By default it is turned on, but if you\r\n#        don't want it you can turn it off. Valid values are \"enabled\" and \"disabled\"\r\n#\r\n# portico.mom = enabled\r\n\r\n# (2.2) Save/Restore Data Files Directory\r\n#        This specifies the path to the directory where federate save/restore data files are stored.\r\n#        By default, this is the \"savedata\" directory relative to the directory that the federate\r\n#        was launched from. Any valid operating system path can be specified, as long as it is\r\n#        writeable by the operating system user under which the federate is executing\r\n#\r\n# portico.saveDirectory = ./savedata\r\n\r\n# (2.3) Unsupported Methods Throw Exceptions\r\n#        Portico does not support all the RTIambassador methods in all interface versions. To alert\r\n#        users to situations where a method is called that isn't support, Portico will log a warning\r\n#        and take no action. This is often a non-fatal action, but in some situations it may cause\r\n#        federates to stall or misbehave. As such, if this value is set to true, an RTIinternalError\r\n#        will be thrown when an unsupported method is called. By default, this is false.\r\n#\r\n# portico.unsupportedExceptions = false\r\n\r\n# (2.4) Object Names Negotiated With Federation\r\n#        When registering an object with a specific name, to ensure that name is unique, the\r\n#        federate much negotiate with the rest of the federation. This incurs a performance hit.\r\n#        By default, this negotiation is turned off. If you have problems with conflicting names,\r\n#        set this property to true. In the default mode (negotiation disabled) the RTI is not\r\n#        totally standards compliant, and conflicts can occur if federates try to register objects\r\n#        with the same name at the same time (if the requests are sufficiently spaced out in time,\r\n#        this problem shouldn't occur).\r\n#\r\n# portico.object.negotiateNames = false\r\n\r\n# (2.5) Unique Federate Names\r\n#        By default, Portico, like other RTIs, will ensure that all federates in a federation have\r\n#        unique names. However, in some situations this is not desirable (like running Portico with\r\n#        JSAF or VBS2). In this case, you can turn the unique name checking to false. When you do\r\n#        this, what happens is that when Portico sees a name conflict, rather than throwing an\r\n#        exception it will change the requested name from \"name\" to \"name (handle)\" thus making it\r\n#        unique. Default is true, set to false to turn unique name checking off.\r\n#\r\n# portico.uniqueFederateNames = true\r\n\r\n\r\n# ================================\r\n# 3. Advanced Options\r\n# ================================\r\n# These really shouldn't be changed unless you really know what you want\r\n\r\n# (3.1) Portico Communications Binding\r\n#        Defines the mechanism used by federates to communicate. Two valid options: jgroups, jvm.\r\n#\r\n#        jgroups: Use for LAN/WAN communications (default)\r\n#            jvm: Use when running many federates in separate threads within a single process.\r\n#\r\n# portico.connection = jgroups\r\n\r\n# (3.2) LRC Tick Timeout\r\n#        When a federate calls tick() and there is no work to do, the LRC will wait for a period of\r\n#        time to allow work to arrive before it returns. This is designed to avoid a busy-looping\r\n#        situation where people are calling tick in a loop while waiting for some event.\r\n#\r\n#        The period of time the LRC will wait is specified by this value (in *MILLISECONDS*).\r\n#        DEFAULT = 5\r\n#\r\n#        (NOTE) This does not apply to the tick(min,max) call (in that case, the LRC will wait\r\n#               for at most \"min\" seconds for work to arrive).\r\n#\r\n# portico.lrc.tt = 5\r\n\r\n\r\n# =========================================\r\n# 4. JGroups Network Settings\r\n# =========================================\r\n# Portico uses the JGroups library for its inter-federate network communication.\r\n# These settings control various parameters of the network layer and JGroups itself.\r\n\r\n# (4.1) JGroups UDP Address and Port\r\n#        Address and port to use for communication between federates.\r\n#        DEFAULT: 239.20.9.13:20913\r\n#\r\n# portico.jgroups.udp.address = 239.20.9.13\r\n# portico.jgroups.udp.port = 20913\r\n\r\n\r\n# (4.2) JGroups Bind Address\r\n#        The address/NIC Portico should use. Can use an IP address associated with a NIC, or\r\n#        one of the following special values:\r\n#\r\n#            GLOBAL: Pick a global IP address if available. If not, falls back to a SITE_LOCAL IP address.\r\n#        SITE_LOCAL: Picks a site local (non routable) IP address, e.g. from the 192.168.0.0 or 10.0.0.0 address range.\r\n#        LINK_LOCAL: Picks a link-local IP address, from 169.254.1.0 through 169.254.254.255.\r\n#      NON_LOOPBACK: Picks any non loopback address.\r\n#          LOOPBACK: Pick a loopback address, e.g. 127.0.0.1.\r\n#   match-interface: Pick an address which matches a pattern against the interface name, e.g. match-interface:eth.*\r\n#     match-address: Pick an address which matches a pattern against the host address, e.g. match-address:192.168.*\r\n#        match-host: Pick an address which matches a pattern against the host name, e.g. match-host:linux.*\r\n#\r\n#        DEFAULT: SITE_LOCAL\r\n#\r\nportico.jgroups.udp.bindAddress = <%= bindAddress%>\r\n\r\n# (4.3) JGroups UDP Sent/Receive Buffer Size\r\n#        Incoming/Outgoing buffer sizes. Default receive buffer is quite large to allow ample\r\n#        space on fast networks and avoid dropped packets.\r\n#\r\n# portico.jgroups.udp.receiveBuffer = 25M\r\n# portico.jgroups.udp.sendBuffer = 640K\r\n\r\n\r\n# (4.4) JGroups Bundling Support\r\n#         If you are sending lots of smaller messages, higher overall throughput can be obtained by\r\n#         bundling them together into a fewer number of larger messages. However, doing so comes at\r\n#         the cost of latency. Messages are buffered until either the timeout period (milliseconds)\r\n#         is reached, or the total size of the messages exceeds the specified threshold. Bundling\r\n#         is enabled by default. For latency-critical tasks, disable it or reduce the max-timeout.\r\n#\r\n# portico.jgroups.bundling = true\r\n# portico.jgroups.bundling.maxSize = 64K\r\n# portico.jgroups.bundling.maxTime = 30\r\n\r\n\r\n# (4.5) JGroups Flow Control\r\n#         Flow control is used to rate limit transmission so that slow receivers don't get overrun,\r\n#         causing them to drop messages and requiring expensive retransmission.\r\n#\r\n#         This value sets the maximum number of bytes that can be sent by a federate before it\r\n#         needs to receive more credits from other cluster members. These credits are not sent\r\n#         until the other federates have processed enough of the prior sent messages. The ratio\r\n#         setting defines how far through its current credits a sender can get before it should\r\n#         issue a request for more.\r\n#\r\n#         Setting the credit limit higher will allow a federate to send more messages before it\r\n#         gets blocked. Consider adjusting this value in conjunction with the buffer sizes, as\r\n#         they will dictate storage capacity on the sender side.\r\n#\r\n#         Note: If you start experiencing unstable behaviour, turn this value down. Flow control\r\n#               can be sensitive to the number of messages you try to send out in a hurry. If\r\n#               bundling is enabled, you can use a higher value because although you are sending\r\n#               more messages, the actual number hitting the network is smaller.\r\n#\r\n# portico.jgroups.flow.credits = 2M\r\n# portico.jgroups.flow.threshold = 0.4\r\n\r\n\r\n# (4.6) Packet Fragmentation Size\r\n#         Messages larger than this size will be broken down into smaller ones for transmission,\r\n#         reducing potentially lengthy delays retransmitting whole large messages when a single\r\n#         datagram is lost.\r\n#         Note: The max bundling size must be greater than this value.\r\n#\r\n# portico.jgroups.frag.size = 60K\r\n\r\n\r\n# (4.7) JGroups Traffic Auditing\r\n#         If this option is enabled a special log file will be produced for each federate listing\r\n#         the messages it has sent and received, along with their size and other useful details.\r\n#         This information can be used to make judgements about network config (such as bundling\r\n#         limits) or to just see what is happening in the federation at a network level.\r\n#\r\n#         The audit files are placed in the logs directory (see sec 1.1) with the name:\r\n#         \"audit-FEDERATENAME.log\"\r\n#\r\n#         If the auditor is enabled you can specify a detail level to control what is logged.\r\n#         When set to \"full\", each message will be logged with its specific details. (default)\r\n#         When set to \"summary\", only the summary tables will be printed\r\n#\r\n# portico.jgroups.auditor.enabled = false\r\n# portico.jgroups.auditor.details = full\r\n\r\n# (4.8) JGroups Traffic Audit Filtering\r\n#         Federates can generate a lot of messages. Sometimes you really just want to zero in\r\n#         on a particular type of message, or messages for a particular FOM type. These filters\r\n#         let you do that. These filters work in combination. For example, consider the following:\r\n#             - action  = sent\r\n#             - type    = UpdateAttributes\r\n#             - fomtype = Lifeform, GroundVehicle\r\n#\r\n#         Given this, only attribute updates for the FOM classes \"Lifeform\" and \"GroundVehicle\"\r\n#         that the local federate sends will be logged. Leaving a value empty, or using the\r\n#         keyword \"all\" will cause no filtering for that type to be applied.\r\n#\r\n#         NOTE: If the detail level is set to \"summary\", -no- individual messages will be logged,\r\n#               regardless of the filter settings.\r\n#         \r\n# portico.jgroups.auditor.filter.direction = \r\n# portico.jgroups.auditor.filter.message   = \r\n# portico.jgroups.auditor.filter.fomtype   = \r\n\r\n# =========================================\r\n# 5. WAN Connection Options\r\n# =========================================\r\n\r\n# (5.1) WAN Mode Enable/Disable\r\n#       If true, WAN mode will be enabled and this federate will act as both a\r\n#       local participant, and also as a bridge for all the local federates.\r\n#       Messages exchanged on the local JGroups channel will be forwarded to a\r\n#       central router (see 5.2) to be reflected out to other sites. Messagest\r\n#       received from the router will be pushed out to the local JGroups channel\r\n#       so everyone here can process them.\r\n#\r\n#       Note that this mode does not support bundling. If enabled in the RID, it\r\n#       will be active on the local JGroups network, but ignored for the WAN.\r\n#\r\n#       Note: Router must be running before federate startup. If not - federates\r\n#             will fail to start.\r\n#\r\n#       Default: false\r\n#       \r\n# portico.wan.enabled = false\r\n\r\n# (5.2) Router Address/Port\r\n#       Specifies the address and port of the WAN router to use. Note that the\r\n#       syntax is \"address:port\".\r\n#\r\n#       Default: 127.0.0.1:23114\r\n#\r\n# portico.wan.router = 127.0.0.1:23114\r\n\r\n# (5.2) Enable / Disable Bundling\r\n#       Bundling enables higher throughput by grouping together a number of\r\n#       smaller messages and sending them as one. This makes much more efficient\r\n#       use of the network and provides considerable improvements to throughput\r\n#       at a minor cost to latency.\r\n#\r\n#       If enabled, the subsequent options will control how it is applied.\r\n#\r\n#       Default: true\r\n#\r\n# portico.wan.bundle.enabled = true\r\n\r\n# (5.3) Max Bundle Size\r\n#       Messages sent over the WAN will be grouped into bundles and sents as\r\n#       a batch when their total size exceeds this value. Specify a size with\r\n#       a suffix of 'b', 'k' or 'm' (or 'g' if you dare!)\r\n#\r\n#       Default: 64k\r\n#\r\n# portico.wan.bundle.maxsize = 64K\r\n\r\n# (5.4) Max Bundle Timeout\r\n#       The maximum amount of time we will hold messages in the bundler for while\r\n#       waiting for more messages to arrive and bundle together. From the time that\r\n#       a message is received, the bundler will hold it for no longer than this\r\n#       value (specified in milliseconds).\r\n#\r\n#       Default: 20\r\n#\r\n# portico.wan.bundle.timeout = 20\r\n\r\n\r\n# =========================================\r\n# A51. Undocumented Settings\r\n# =========================================\r\n# This section is a catch-all of settings we use for internal work, and infrequently.\r\n# Their specific usecase and function is undocumented as they are not intended for general use.\r\n# portico.container.loglevel = OFF\r\n# portico.jgroups.loglevel = OFF\r\n# portico.jgroups.timeout = 1000\r\n"
}});