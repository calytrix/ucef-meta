//jshint ignore: start
/* Generated file based on ejs templates */
define([], function() {
    return {
    "class.cpp.ejs": "<% /*class(isinteraction,simname,classname,parentclassname,hlaclassname,datamembers,alldatamembers,isc2winteractionroot) ::= <<*/ %>\r\n// This code has been generated by the C2W code generator.\r\n// Do not edit manually!\r\n\r\n#include \"<%=classname%>.hpp\"\r\n\r\n<% /*classcommon(...)*/ %>\r\n<%-ejs.render(\r\n\tTEMPLATES[\"classcommon.cpp.ejs\"],{\r\n\t\tisinteraction: isinteraction,\r\n\t\tclassname: classname,\r\n\t\tparentclassname: parentclassname,\r\n\t\thlaclassname: hlaclassname,\r\n\t\tdatamembers: datamembers,\r\n\t\talldatamembers: alldatamembers\r\n})%>\r\n\r\n<% if(isc2winteractionroot){ %>\r\nvoid C2WInteractionRoot::sendInteraction( RTI::RTIambassador *rti, double time ) {\r\n\tif ( get_sourceFed().empty() || get_originFed().empty() ) {\r\n\t\tthrow C2WException( \"C2WInteractionRoot::sendInteraction:  source and/or origin federate not specified.\" );\r\n\t}\r\n\tSuper::sendInteraction( rti, time );\r\n}\r\n\r\nvoid C2WInteractionRoot::sendInteraction( RTI::RTIambassador *rti ) {\r\n\tif ( get_sourceFed().empty() || get_originFed().empty() ) {\r\n\t\tthrow C2WException( \"C2WInteractionRoot::sendInteraction:  source and/or origin federate not specified.\" );\r\n\t}\r\n\tSuper::sendInteraction( rti );\r\n}\r\n\t\r\n<%}%>\r\n\r\n<% if(datamembers && datamembers.length > 0){ %>\r\n<%=classname%>::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP <%=classname%>::createDatamemberHandleValuePairSet( RTI::ULong count<% if(!isinteraction){ %>, bool force <%}%> ) {\r\n\t<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP datamembers = Super::createDatamemberHandleValuePairSet( count + <%=datamembers.length%><% if(!isinteraction){ %>, force<%}%> );\r\n\r\n\tstd::string stringConversion;\r\n\t\t\r\n<% if(isinteraction){ %>\r\n\t<% /*datamembers:supplied_parameter()*/%>\r\n\t<% datamembers.forEach(function(datamember){ %>\r\n\tstringConversion = static_cast< std::string >(  TypeMedley( get_<%=datamember.name%>() )  );\r\n\tdatamembers->add( get_<%=datamember.name%>_handle(), stringConversion.c_str(), stringConversion.size() );\r\n\t<%});%>\r\n<% }else{ %>\r\n\tbool isPublished = false;\r\n\t<% /*datamembers:{ d |<supplied_attribute(classname=classname,datamember=d)>}*/ %>\r\n\t<% datamembers.forEach(function(datamember){ %>\r\n\ttry {\r\n\t\tisPublished = getPublishedAttributeHandleSet_var().isMember( get_<%=datamember.name%>_handle() );\r\n\t} catch ( ... ) {\r\n\t\tstd::cerr << \"ERROR:  <%=classname%>.createSuppliedAttributes:  could not determine if <%=datamember.name%> is published.\" << std::endl;\r\n\t\tisPublished = false;\r\n\t}\r\n\tif (  isPublished && _<%=datamember.name%>.shouldBeUpdated( force )  ) {\r\n\t\tstringConversion = static_cast< std::string >(  TypeMedley( get_<%=datamember.name%>() )  );\r\n\t\tdatamembers->add( get_<%=datamember.name%>_handle(), stringConversion.c_str(), stringConversion.size() );\r\n\t\t_<%=datamember.name%>.setHasBeenUpdated();\r\n\t}\r\n\r\n\t<%});%>\r\n<%}%>\r\n\treturn datamembers;\r\n}\r\n<%}%>\r\n",
    "class.hpp.ejs": "<% /*class(isinteraction,simname,classname,parentclassname,hlaclassname,datamembers,alldatamembers,isc2winteractionroot) ::= << */ %>\r\n/*\r\n * Copyright (c) 2008, Institute for Software Integrated Systems, Vanderbilt University\r\n * All rights reserved.\r\n *\r\n * Permission to use, copy, modify, and distribute this software and its\r\n * documentation for any purpose, without fee, and without written agreement is\r\n * hereby granted, provided that the above copyright notice, the following\r\n * two paragraphs and the author appear in all copies of this software.\r\n *\r\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\r\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\r\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\r\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\r\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\r\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\r\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\r\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\r\n *\r\n * @author Himanshu Neema\r\n * @author Harmon Nine\r\n */\r\n\r\n// This code has been generated by the C2W code generator.\r\n// Do not edit manually!\r\n\r\n/*\r\n * \tNOTE:  ALL \"if\" STATEMENTS IN THIS CODE THAT HAD THE FORM:\r\n *\r\n *  if (condition) statement;\r\n *\r\n *\tOR\r\n *\r\n *  if (condition) statement1;\r\n *  else           statement2;\r\n *\r\n *  HAVE BEEN CONVERTED TO THE FORMS:\r\n *\r\n *  if (condition) {\r\n *\t\tstatement;\r\n *\t}\r\n *\r\n *\tAND\r\n *\r\n *  if (condition) {\r\n *\t\tstatement1;\r\n *\t} else {\r\n *\t\tstatement2;\r\n *\t}\r\n *\r\n *\tRESPECTIVELY.  THIS IS BECAUSE THE OMNET DEBUGGER APPEARS TO HAVE A PROBLEM\r\n *  WITH THE NON-BRACED FORMS OF THE IF STATEMENT.  *PLEASE* DO NOT CHANGE IT BACK.\r\n *  -- H.S.N.\r\n *\r\n */\r\n\r\n#ifndef _<%=classname%>_CLASS\r\n#define _<%=classname%>_CLASS\r\n\r\n#include \"<%=parentclassname%>.hpp\"\r\n#include \"C2WException.hpp\"\r\n\r\n\r\nclass <%=classname%> : public <%=parentclassname%> {\r\n\r\npublic:\r\n\ttypedef <%=parentclassname%> Super;\r\n\ttypedef boost::shared_ptr< <%=classname%> > SP;\r\n\r\n\tstatic StringVector get_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\r\n\t\treturn getDatamemberNames();\r\n\t}\r\n\r\n\tstatic StringVector get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\r\n\t\treturn getAllDatamemberNames();\r\n\t}\r\n\r\n\t<%=classname%>( void ) { }\r\n\t\r\n\tstatic SP create( void ) { return SP( new <%=classname%> ); }\r\n\r\nprivate:\r\n\t<% /*datamembers:handle()*/ %>\r\n\t<% datamembers.forEach(function(datamember){ %>\r\n\tstatic int &get_<%=datamember.name%>_handle_var( void ) {\r\n\t\tstatic int <%=datamember.name%>_handle;\r\n\t\treturn <%=datamember.name%>_handle;\r\n\t}<%});%>\r\n\t\r\npublic:\r\n\t<% /*datamembers:gethandle()*/ %>\r\n\t<% datamembers.forEach(function(datamember){ %>\r\n\tstatic int get_<%=datamember.name%>_handle( void ) { return get_<%=datamember.name%>_handle_var(); }<%});%>\r\n\t\r\n<% /*classcommon(...)*/ %>\r\n<%-ejs.render(\r\n\tTEMPLATES[\"classcommon.hpp.ejs\"],{\r\n\t\tisinteraction: isinteraction,\r\n\t\tclassname: classname,\r\n\t\tparentclassname: parentclassname,\r\n\t\thlaclassname: hlaclassname,\r\n\t\tdatamembers: datamembers,\r\n\t\talldatamembers: alldatamembers\r\n})%>\r\n\r\n<% if(isc2winteractionroot){ %>\r\npublic:\r\n\tvoid sendInteraction( RTI::RTIambassador *rti, double time );\r\n\tvoid sendInteraction( RTI::RTIambassador *rti );\r\n\t\r\n<%}%>\r\n\r\n<% if(isinteraction){ %>\r\nprivate:\r\n\t<% /*datamembers:interactionmembers()*/ %>\r\n\t<% datamembers.forEach(function(datamember){ %>\r\n\t<%- helpers.cppjavaTypeMap(datamember.parameterType) %> _<%=datamember.name%>;\r\n\t<%});%>\r\npublic:\r\n\t<% /*datamembers:interactiongetters()*/ -%>\r\n\t<% datamembers.forEach(function(datamember){ %>\r\n\tvoid set_<%=datamember.name%>( <%- helpers.cppjavaArgumentTypeMap(datamember.parameterType) %> <%=datamember.name%> ) { _<%=datamember.name%> = <%=datamember.name%>; }\r\n\t<%- helpers.cppjavaArgumentTypeMap(datamember.parameterType) %> get_<%=datamember.name%>( void ) const { return _<%=datamember.name%>; }\r\n\t<%});%>\r\n<% }else{ %>\r\npublic:\r\n\t<% alldatamembers.forEach(function(attribute){ %>\r\n\t<% /*alldatamembers:{ a |<publish(classname=classname,attribute=a)> }*/ %>\r\n\tstatic void publish_<%=attribute.name%>( void ) {\r\n\t\tgetPublishAttributeNameVector().push_back( \"<%=attribute.name%>\" );\r\n\t}\r\n\tstatic void unpublish_<%=attribute.name%>( void ) {\r\n\t\tgetPublishAttributeNameVector().erase( std::remove( getPublishAttributeNameVector().begin(), getPublishAttributeNameVector().end(), \"<%=attribute.name%>\" ), getPublishAttributeNameVector().end() );\r\n\t}\r\n\t<% /*alldatamembers:{ a |<subscribe(classname=classname,attribute=a)> }*/ %>\r\n\tstatic void subscribe_<%=attribute.name%>( void ) {\r\n\t\tgetSubscribeAttributeNameVector().push_back( \"<%=attribute.name%>\" );\r\n\t}\r\n\tstatic void unsubscribe_<%=attribute.name%>(void ) {\r\n\t\tgetSubscribeAttributeNameVector().erase( std::remove( getSubscribeAttributeNameVector().begin(), getSubscribeAttributeNameVector().end(), \"<%=attribute.name%>\" ), getSubscribeAttributeNameVector().end() );\r\n\t}\r\n\t<%});%>\r\nprivate:\r\n\t<% /*datamembers:objectmembers()*/ %>\r\n\t<% datamembers.forEach(function(datamember){ %>\r\n\tAttribute< int, <%- helpers.cppjavaTypeMap(datamember.parameterType) %> > _<%=datamember.name%>;\r\n\t<%});%>\r\npublic:\r\n\t<% datamembers.forEach(function(datamember){ %>\r\n\t<% /*datamembers:objectsetters()*/ %>\r\n\tvoid set_<%=datamember.name%>( <%- helpers.cppjavaArgumentTypeMap(datamember.parameterType) %> <%=datamember.name%> ) {\r\n\t\t_<%=datamember.name%>.setValue( <%=datamember.name%> );\r\n\t\t_<%=datamember.name%>.setTime( getTime() );\r\n\t}\r\n\t<% /*datamembers:objectgetters()*/ %>\r\n\t<%- helpers.cppjavaArgumentTypeMap(datamember.parameterType) %> get_<%=datamember.name%>( void ) const {\r\n\t\treturn _<%=datamember.name%>.getValue();\r\n\t}\r\n\t<% /*datamembers:objecttimegetters()*/ %>\r\n\tdouble get_<%=datamember.name%>_time( void ) {\r\n\t\treturn _<%=datamember.name%>.getTime();\r\n\t}\r\n\t<%});%>\r\n<%}%>\r\n\r\n\t<%=classname%>( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) : Super( datamemberMap ) { }\r\n\t\r\n\t<%=classname%>( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &logicalTime ) : Super( datamemberMap, logicalTime ) { }\r\n\t\r\n\t<% if(datamembers && datamembers.length > 0){ %>\r\npublic:\r\n\tTypeMedley get<%=isinteraction?\"Parameter\":\"Attribute\"%>( const std::string &datamemberName ) const {\r\n\t\t<% /*first(datamembers):startgetbyname()*/ %>\r\n\t\t<% for(var i = 0; i<datamembers.length; i++ ){ %>\r\n\t\t<%= i == 0  ? 'if' : 'else if' %> ( \"<%=datamembers[i].name%>\" == datamemberName ) {\r\n\t\t\treturn TypeMedley( get_<%=datamembers[i].name%>() );\r\n\t\t}<%}%> else {\r\n\t\t\treturn Super::get<%=isinteraction?\"Parameter\":\"Attribute\"%>( datamemberName );\r\n\t\t}\r\n\t}\r\n\t\r\n\tTypeMedley get<%=isinteraction?\"Parameter\":\"Attribute\"%>( int datamemberHandle ) const {\r\n\t\t<% /*first(datamembers):startgetbyhandle()*/ %>\r\n\t\t<% for(var i = 0; i<datamembers.length; i++ ){ %>\r\n\t\t<%= i == 0  ? 'if' : 'else if'%> ( get_<%=datamembers[i].name%>_handle() == datamemberHandle ) {\r\n\t\t\treturn TypeMedley( get_<%=datamembers[i].name%>() );\r\n\t\t}<%}%> else {\r\n\t\t\treturn Super::get<%=isinteraction?\"Parameter\":\"Attribute\"%>( datamemberHandle );\r\n\t\t}\r\n\t}\r\n\r\nprotected:\r\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( int param_handle, const std::string &val ) {\r\n\t\tbool retval = true;\t\t\r\n\t\t<% /*first(datamembers):startif()*/ %>\r\n\t\t<% for(var i = 0; i<datamembers.length; i++ ){ %>\r\n\t\t<%= i == 0  ? 'if' : 'else if'%> ( param_handle == get_<%=datamembers[i].name%>_handle() ) {\r\n\t\t\tset_<%=datamembers[i].name%>(  TypeMedley( val )  );\r\n\t\t}<%}%> else {\r\n\t\t\tretval = Super::set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( param_handle, val );\r\n\t\t}\r\n\t\treturn retval;\r\n\t}\r\n\t\r\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( const std::string &datamemberName, const std::string &val ) {\r\n\t\tbool retval = true;\r\n\t\t<% /*first(datamembers):startifstring()*/ %>\r\n\t\t<% for(var i = 0; i<datamembers.length; i++ ){ %>\r\n\t\t<%= i == 0  ? 'if' : 'else if'%> ( \"<%=datamembers[i].name%>\" == datamemberName ) {\r\n\t\t\tset_<%=datamembers[i].name%>(  TypeMedley( val )  );\r\n\t\t}<%}%> else {\r\n\t\t\tretval = Super::set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, val );\r\n\t\t}\r\n\t\t\r\n\t\treturn retval;\r\n\t}\r\n\t\r\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( const std::string &datamemberName, const TypeMedley &val ) {\r\n\t\tbool retval = true;\r\n\t\t<% /*first(datamembers):startifname()*/ %>\r\n\t\t<% for(var i = 0; i<datamembers.length; i++ ){ %>\r\n\t\t<%= i == 0  ? 'if' : 'else if'%> ( \"<%=datamembers[i].name%>\" == datamemberName ) {\\\r\n\t\t\tset_<%=datamembers[i].name%>( val );\r\n\t\t}<%}%> else {\r\n\t\t\tretval = Super::set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, val );\r\n\t\t}\r\n\t\t\r\n\t\treturn retval;\r\n\t}\r\n\r\n\tvirtual <%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP createDatamemberHandleValuePairSet( RTI::ULong count<% if(!isinteraction){%>, bool force <%}%> );\r\n\r\n\tvirtual <%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP createDatamemberHandleValuePairSet( <% if(!isinteraction){%> bool force <%}%>) {\r\n\t\treturn createDatamemberHandleValuePairSet( 0<% if(!isinteraction){%>, force<%}%> );\r\n\t}\r\n\t<%}%>\r\n\t\r\n};\r\n\r\ntypedef <%=classname%>::SP <%=classname%>SP;\r\n\r\nstatic bool call_<%=classname%>_static_init = <%=classname%>::static_init();\r\n\r\nstd::ostream &operator<<( std::ostream &os, <%=classname%>::SP entitySP );\r\nstd::ostream &operator<<( std::ostream &os, const <%=classname%> &entity );\r\n#endif\r\n",
    "class.java.ejs": "<% /*class(isinteraction,simname,classname,parentclassname,hlaclassname,datamembers,alldatamembers,isc2winteractionroot) */%>\r\n// This code has been generated by the C2W code generator.\r\n// Do not edit manually!\r\n\r\npackage <%=simname%>;\r\n\r\nimport java.util.HashSet;\r\nimport java.util.Set;\r\n\r\nimport hla.rti.*;\r\n<% if(simname !== 'c2w.hla'){ %>\r\nimport c2w.hla.*;\r\n<% } %>\r\n/**\r\n* The <%=classname%> class implements the <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> in the\r\n* <%=simname%> simulation.\r\n*/\r\npublic class <%=classname%> extends <%=parentclassname%> {\r\n\r\n\t/**\r\n\t* Default constructor -- creates an instance of the <%=classname%> <%=isinteraction?\"interaction\":\"object\"%>\r\n\t* class with default <%=isinteraction?\"parameter\":\"attribute\"%> values.\r\n\t*/\r\n\tpublic <%=classname%>() { }\r\n\r\n\t<% /*datamembers:handle()*/ %>\r\n\t<% datamembers.forEach(function(datamember){ %>\r\n\tprivate static int _<%=datamember.name%>_handle;<%});%>\r\n\t<% /*datamembers:gethandle()*/ %>\r\n\t<% datamembers.forEach(function(datamember){ %>\r\n\t/**\r\n\t* Returns the handle (RTI assigned) of the \"<%=datamember.name%>\" <%=isinteraction?\"parameter\":\"attribute\"%> of\r\n\t* its containing <%=isinteraction?\"interaction\":\"object\"%> class.\r\n\t*\r\n\t* @return the handle (RTI assigned) of the \"<%=datamember.name%>\" <%=isinteraction?\"parameter\":\"attribute\"%>\r\n\t*/\r\n\tpublic static int get_<%=datamember.name%>_handle() { return _<%=datamember.name%>_handle; }\r\n\t<%});%>\r\n\t<% /*classcommon(...)*/ %>\r\n\t<%- ejs.render(TEMPLATES[\"classcommon.java.ejs\"],\r\n\t\t{\tisinteraction: isinteraction,\r\n\t\t\tclassname: classname,\r\n\t\t\tparentclassname: parentclassname,\r\n\t\t\thlaclassname: hlaclassname,\r\n\t\t\tdatamembers: datamembers,\r\n\t\t\talldatamembers: alldatamembers\r\n\t}) %>\r\n\t\r\n<% if(isc2winteractionroot){%>\r\n\t@Override\r\n\tpublic void sendInteraction( RTIambassador rti, double time ) throws Exception {\r\n\t\tif (  get_sourceFed() == null || \"\".equals( get_sourceFed() ) || get_originFed() == null || \"\".equals( get_originFed() )  ) {\r\n\t\t\tthrow new Exception( \"C2WInteractionRoot.sendInteraction:  source and/or origin federate not specified.\" );\r\n\t\t}\r\n\t\tsuper.sendInteraction( rti, time );\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void sendInteraction( RTIambassador rti ) throws Exception {\r\n\t\tif (  get_sourceFed() == null || \"\".equals( get_sourceFed() ) || get_originFed() == null || \"\".equals( get_originFed() )  ) {\r\n\t\t\tthrow new Exception( \"C2WInteractionRoot.sendInteraction:  source and/or origin federate not specified.\" );\r\n\t\t}\r\n\t\tsuper.sendInteraction( rti );\r\n\t}\r\n<%}%>\r\n\r\n<% if(isinteraction){ %>\r\n\t<% datamembers.forEach(function(parameter){ %>\r\n\t<% /*datamembers:interactionmembers()*/ %>\r\n\tprivate <%=parameter.parameterType%> _<%=parameter.name%> = <%-helpers.initialvalue(parameter.parameterType)%>;<%});%>\r\n\r\n\t<% datamembers.forEach(function(parameter){ %>\r\n\t<% /*datamembers:interactionsetters()*/ %>\r\n\t/**\r\n\t* Set the value of the \"<%=parameter.name%>\" parameter to \"value\" for this parameter.\r\n\t*\r\n\t* @param value the new value for the \"<%=parameter.name%>\" parameter\r\n\t*/\r\n\tpublic void set_<%=parameter.name%>( <%=parameter.parameterType%> value ) { _<%=parameter.name%> = value; }\r\n\t<% /*datamembers:interactiongetters()*/ %>\r\n\t/**\r\n\t* Returns the value of the \"<%=parameter.name%>\" parameter of this interaction.\r\n\t*\r\n\t* @return the value of the \"<%=parameter.name%>\" parameter\r\n\t*/\r\n\tpublic <%=parameter.parameterType%> get_<%=parameter.name%>() { return _<%=parameter.name%>; }\r\n\t<%});%>\r\n<% }else{ %>\r\n\t<% alldatamembers.forEach(function(attribute){ %>\r\n\t<% /* alldatamembers:{ a |<publish(attribute=a)> } */ %>\r\n\t/**\r\n\t* Publishes the \"<%=attribute.name%>\" attribute of the attribute's containing object\r\n\t* class for a federate.\r\n\t* Note:  This method only marks the \"<%=attribute.name%>\" attribute for publication.\r\n\t* To actually publish the attribute, the federate must (re)publish its containing\r\n\t* object class.\r\n\t* (using <objectClassName>.publish( RTIambassador rti ) ).\r\n\t*/\r\n\tpublic static void publish_<%=attribute.name%>() {\r\n\t\t_publishAttributeNameSet.add( \"<%=attribute.name%>\" );\r\n\t}\r\n\r\n\t/**\r\n\t* Unpublishes the \"<%=attribute.name%>\" attribute of the attribute's containing object\r\n\t* class for a federate.\r\n\t* Note:  This method only marks the \"<%=attribute.name%>\" attribute for unpublication.\r\n\t* To actually publish the attribute, the federate must (re)publish its containing\r\n\t* object class.\r\n\t* (using <objectClassName>.publish( RTIambassador rti ) ).\r\n\t*/\r\n\tpublic static void unpublish_<%=attribute.name%>() {\r\n\t\t_publishAttributeNameSet.remove( \"<%=attribute.name%>\" );\r\n\t}\r\n\t<% /* alldatamembers:{ a |<subscribe(attribute=a)> } */ %>\r\n\t/**\r\n\t* Subscribes a federate to the \"<%=attribute.name%>\" attribute of the attribute's\r\n\t* containing object class.\r\n\t* Note:  This method only marks the \"<%=attribute.name%>\" attribute for subscription.\r\n\t* To actually subscribe to the attribute, the federate must (re)subscribe to its\r\n\t* containing object class.\r\n\t* (using <objectClassName>.subscribe( RTIambassador rti ) ).\r\n\t*/\r\n\tpublic static void subscribe_<%=attribute.name%>() {\r\n\t\t_subscribeAttributeNameSet.add( \"<%=attribute.name%>\" );\r\n\t}\r\n\r\n\t/**\r\n\t* Unsubscribes a federate from the \"<%=attribute.name%>\" attribute of the attribute's\r\n\t* containing object class.\r\n\t* Note:  This method only marks the \"<%=attribute.name%>\" attribute for unsubscription.\r\n\t* To actually unsubscribe to the attribute, the federate must (re)subscribe to its\r\n\t* containing object class.\r\n\t* (using <objectClassName>.subscribe( RTIambassador rti ) ).\r\n\t*/\r\n\tpublic static void unsubscribe_<%=attribute.name%>() {\r\n\t\t_subscribeAttributeNameSet.remove( \"<%=attribute.name%>\" );\r\n\t}\r\n\t<%});%>\r\n\r\n\t<% datamembers.forEach(function(datamember){ %>\r\n\t<% /*datamembers:objectmembers()*/ %>\r\n\tprivate Attribute< <%= helpers.primitive2object(datamember.parameterType) %> > _<%=datamember.name%> =\r\n \t\tnew Attribute< <%= helpers.primitive2object(datamember.parameterType) %> >(  new <%= helpers.primitive2object(datamember.parameterType)%>( <%-helpers.initialvalue(datamember.parameterType)%> )  );\r\n\t<% /*datamembers:objectsetters()*/ %>\r\n\t/**\r\n\t* Set the value of the \"<%=datamember.name%>\" attribute to \"value\" for this object.\r\n\t*\r\n\t* @param value the new value for the \"<%=datamember.name%>\" attribute\r\n\t*/\r\n\tpublic void set_<%=datamember.name%>( <%=datamember.parameterType%> value ) {\r\n\t\t_<%=datamember.name%>.setValue( value );\r\n\t\t_<%=datamember.name%>.setTime( getTime() );\r\n\t}\r\n\t<% /*datamembers:objectgetters()*/ %>\r\n\t/**\r\n\t* Returns the value of the \"<%=datamember.name%>\" attribute of this object.\r\n\t*\r\n\t* @return the value of the \"<%=datamember.name%>\" attribute\r\n\t*/\r\n\tpublic <%=datamember.parameterType%> get_<%=datamember.name%>() {\r\n\t\treturn _<%=datamember.name%>.getValue();\r\n\t}\r\n\t<% /*datamembers:objecttimegetters()*/ %>\r\n\t/**\r\n\t* Returns the current timestamp of the \"<%=datamember.name%>\" attribute of this object.\r\n\t* \r\n\t* @return the current timestamp of the \"<%=datamember.name%>\" attribute\r\n\t*/\r\n\tpublic double get_<%=datamember.name%>_time() {\r\n\t\treturn _<%=datamember.name%>.getTime();\r\n\t}\r\n\t<%});%>\r\n<% } %>\r\n\r\n\tprotected <%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, boolean initFlag ) {\r\n\t\tsuper( datamemberMap, false );\r\n\t\tif ( initFlag ) set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>s( datamemberMap );\r\n\t}\r\n\t\r\n\tprotected <%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime, boolean initFlag ) {\r\n\t\tsuper( datamemberMap, logicalTime, false );\r\n\t\tif ( initFlag ) set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>s( datamemberMap );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* Creates an instance of the <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class, using\r\n\t* \"datamemberMap\" to initialize its <%=isinteraction?\"parameter\":\"attribute\"%> values.\r\n\t* \"datamemberMap\" is usually acquired as an argument to an RTI federate\r\n\t* callback method, such as \"receiveInteraction\".\r\n\t*\r\n\t* @param datamemberMap data structure containing initial values for the\r\n\t* <%=isinteraction?\"parameter\":\"attribute\"%>s of this new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n\t*/\r\n\tpublic <%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\r\n\t\tthis( datamemberMap, true );\r\n\t}\r\n\t\r\n\t/**\r\n\t* Like {@link #<%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap )}, except this\r\n\t* new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance is given a timestamp of\r\n\t* \"logicalTime\".\r\n\t*\r\n\t* @param datamemberMap data structure containing initial values for the\r\n\t* <%=isinteraction?\"parameter\":\"attribute\"%>s of this new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n\t* @param logicalTime timestamp for this new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class\r\n\t* instance\r\n\t*/\r\n\tpublic <%=classname%>( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime ) {\r\n\t\tthis( datamemberMap, logicalTime, true );\r\n\t}\r\n\r\n\t/**\r\n\t* Creates a new <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance that is a duplicate\r\n\t* of the instance referred to by <%=classname%>_var.\r\n\t*\r\n\t* @param <%=classname%>_var <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance of which\r\n\t* this newly created <%=classname%> <%=isinteraction?\"interaction\":\"object\"%> class instance will be a\r\n\t* duplicate\r\n\t*/\r\n\tpublic <%=classname%>( <%=classname%> <%=classname%>_var ) {\r\n\t\tsuper( <%=classname%>_var );\r\n\t\t<% /*datamembers:{ d |<rticlasscopyvalue(classname=classname,datamember=d)>}*/ %>\r\n\t\t<% datamembers.forEach(function(datamember){ %>\r\n\t\tset_<%=datamember.name%>( <%=classname%>_var.get_<%=datamember.name%>() );<%});%>\r\n\t}\r\n\r\n<% if(datamembers && datamembers.length > 0){ %>\r\n\t/**\r\n\t* Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose name is \"datamemberName\"\r\n\t* for this <%=isinteraction?\"interaction\":\"object\"%>.\r\n\t*\r\n\t* @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be\r\n\t* returned\r\n\t* @return value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose name is \"datamemberName\"\r\n\t* for this <%=isinteraction?\"interaction\":\"object\"%>\r\n\t*/\r\n\tpublic Object get<%= isinteraction ? \"Parameter\" : \"Attribute\" %>( String datamemberName ) {\r\n\t\t<% /*first(datamembers):startgetbyname()*/ %>\r\n\t\t<% /*rest(datamembers):continuegetbyname()*/ %>\r\n\t\t<% for(var i = 0; i<datamembers.length; i++ ){ %>\r\n\t\t<%= i == 0  ? 'if' : 'else if'%> (  \"<%=datamembers[i].name%>\".equals( datamemberName )  ) return <%=helpers.get(datamembers[i].parameterType, datamembers[i].name)%>;<%}%>\r\n\t\telse return super.get<%= isinteraction ? \"Parameter\" : \"Attribute\" %>( datamemberName );\r\n\t}\r\n\t\r\n\t/**\r\n\t* Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose handle (RTI assigned)\r\n\t* is \"datamemberHandle\" for this <%=isinteraction?\"interaction\":\"object\"%>.\r\n\t*\r\n\t* @param datamemberHandle handle (RTI assigned) of <%=isinteraction?\"parameter\":\"attribute\"%> whose\r\n\t* value is to be returned\r\n\t* @return value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose handle (RTI assigned) is\r\n\t* \"datamemberHandle\" for this <%=isinteraction?\"interaction\":\"object\"%>\r\n\t*/\r\n\tpublic Object get<%= isinteraction ? \"Parameter\" : \"Attribute\" %>( int datamemberHandle ) {\r\n\t\t<% /*first(datamembers):startgetbyhandle()*/ %>\r\n\t\t<% /*rest(datamembers):continuegetbyhandle()*/ %>\t\t\r\n\t\t<% for(var i = 0; i<datamembers.length; i++ ){ %>\r\n\t\t<%= i == 0  ? 'if' : 'else if'%> ( get_<%=datamembers[i].name%>_handle() == datamemberHandle ) return <%=helpers.get(datamembers[i].parameterType, datamembers[i].name)%>;<%}%>\r\n\t\telse return super.get<%= isinteraction ? \"Parameter\" : \"Attribute\" %>( datamemberHandle );\r\n\t}\r\n\t\r\n\tprotected boolean set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( int param_handle, String val ) {\r\n\t\tboolean retval = true;\t\t\r\n\t\t<% /*first(datamembers):startif()*/ %>\r\n\t\t<% /*rest(datamembers):continueif()*/ %>\t\r\n\t\t<% for(var i = 0; i<datamembers.length; i++ ){ %>\r\n\t\t<%= i == 0  ? 'if' : 'else if'%> ( param_handle == get_<%=datamembers[i].name%>_handle() ) set_<%=datamembers[i].name%>( <%=helpers.set(datamembers[i].parameterType)%> );<%}%>\r\n\t\telse retval = super.set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( param_handle, val );\r\n\t\t\r\n\t\treturn retval;\r\n\t}\r\n\t\r\n\tprotected boolean set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( String datamemberName, String val ) {\r\n\t\tboolean retval = true;\r\n\t\t<% /*first(datamembers):startifstring()*/ %>\r\n\t\t<% /*rest(datamembers):continueifstring()*/ %>\t\r\n\t\t<% for(var i = 0; i<datamembers.length; i++ ){ %>\r\n\t\t<%= i == 0  ? 'if' : 'else if'%> (  \"<%=datamembers[i].name%>\".equals( datamemberName )  ) set_<%=datamembers[i].name%>( <%=helpers.set(datamembers[i].parameterType)%> );<%}%>\t\r\n\t\telse retval = super.set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( datamemberName, val );\r\n\t\t\r\n\t\treturn retval;\r\n\t}\r\n\t\r\n\tprotected boolean set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( String datamemberName, Object val ) {\r\n\t\tboolean retval = true;\r\n\t\t<% /*first(datamembers):startifname()*/ %>\r\n\t\t<% /*rest(datamembers):continueifname()*/ %>\r\n\t\t<% for(var i = 0; i<datamembers.length; i++ ){ %>\r\n\t\t<%= i == 0  ? 'if' : 'else if'%> (  \"<%=datamembers[i].name%>\".equals( datamemberName )  ) set_<%=datamembers[i].name%>( (<%= helpers.primitive2object(datamembers[i].parameterType)%>)val );<%}%>\t\t\r\n\t\telse retval = super.set<%= isinteraction ? \"Parameter\" : \"Attribute\" %>Aux( datamemberName, val );\r\n\t\t\r\n\t\treturn retval;\r\n\t}\r\n\r\n\tprotected Supplied<%= isinteraction ? \"Parameter\" : \"Attribute\" %>s createSuppliedDatamembers(<%= isinteraction ? \"\" :\" boolean force \" %>) {\r\n\t\tSupplied<%= isinteraction ? \"Parameter\" : \"Attribute\" %>s datamembers = super.createSuppliedDatamembers(<%= isinteraction ? \"\" : \" force \"%>);\r\n\r\n\t<%if(isinteraction){%>\r\n\t\t<% /*datamembers:supplied_parameter()*/ %>\r\n\t\t<% datamembers.forEach(function(datamember){ %>\r\n\t\t\tdatamembers.add( get_<%=datamember.name%>_handle(), <%=helpers.supplied(datamember.parameterType, datamember.name)%>.getBytes() );\r\n\t\t<%});%>\r\n\t<%}else{%>\r\n\t\tboolean isPublished = false;\r\n\t\t<% /* datamembers:{ d |<%supplied_attribute(hlaclassname=hlaclassname,datamember=d)>} */ %>\r\n\t\t<% datamembers.forEach(function(datamember){ %>\r\n\t\t\ttry {\r\n\t\t\t\tisPublished = _publishedAttributeHandleSet.isMember( get_<%=datamember.name%>_handle() );\r\n\t\t\t} catch ( Exception e ) {\r\n\t\t\t\tSystem.err.println( \"ERROR:  <%=hlaclassname%>.createSuppliedAttributes:  could not determine if <%=datamember.name%> is published.\" );\r\n\t\t\t\tisPublished = false;\r\n\t\t\t}\r\n\t\t\tif (  isPublished && _<%=datamember.name%>.shouldBeUpdated( force )  ) {\r\n\t\t\t\tdatamembers.add( get_<%=datamember.name%>_handle(), <%=helpers.supplied(datamember.parameterType, datamember.name)%>.getBytes() );\r\n\t\t\t\t_<%=datamember.name%>.setHasBeenUpdated();\r\n\t\t\t}<%});%>\r\n\t<%}%>\r\n\t\treturn datamembers;\r\n\t}\r\n<%}%>\r\n\t\r\n\tpublic void copyFrom( Object object ) {\r\n\t\tsuper.copyFrom( object );\r\n\t\tif ( object instanceof <%=classname%> ) {\r\n\t\t\t<%=classname%> data = (<%=classname%>)object;\r\n\t\t\t<% /*datamembers:copydatamember();separator = \"\\n\"*/ %>\r\n\t\t\t<% datamembers.forEach(function(datamember){ %>\r\n\t\t\t\t_<%=datamember.name%> = data._<%=datamember.name%>;<%});%>\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n}\r\n",
    "classcommon.cpp.ejs": "<% /*classcommon(isinteraction,classname,parentclassname,hlaclassname,datamembers,alldatamembers) ::= << */ %>\r\n\r\nvoid <%=classname%>::init( RTI::RTIambassador *rti ) {\r\n\tstatic bool isInitialized = false;\r\n\tif ( isInitialized ) {\r\n\t\treturn;\r\n\t}\r\n\tisInitialized = true;\r\n\r\n\t<% if(parentclassname){ %><%=parentclassname%>::init( rti );<%}%>\r\n\r\n\tbool isNotInitialized = true;\r\n\twhile( isNotInitialized ) {\r\n\t\ttry {\r\n\t\t\tgetHandle() = rti->get<%=isinteraction?\"Interaction\":\"Object\"%>ClassHandle( \"<%=hlaclassname%>\" );\r\n\t\t\tisNotInitialized = false;\r\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\r\n\t\t\tstd::cerr << getInitErrorMessage() << \"Federate Not Execution Member\" << std::endl;\r\n\t\t\treturn;\t\t\t\t\r\n\t\t} catch ( RTI::NameNotFound & ) {\r\n\t\t\tstd::cerr << getInitErrorMessage() << \"Name Not Found\" << std::endl;\r\n\t\t\treturn;\t\t\t\t\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << getInitErrorMessage() << \"Exception caught ... retry\" << std::endl;\r\n\t\t}\r\n\t}\r\n\r\n\tgetClassNameHandleMap().insert(  std::make_pair( \"<%=classname%>\", get_handle() )  );\r\n\tgetClassHandleNameMap().insert(  std::make_pair( get_handle(), \"<%=classname%>\" )  );\r\n\r\n<% if(datamembers){ %>\r\n\tisNotInitialized = true;\r\n\twhile( isNotInitialized ) {\r\n\t\ttry {\t\t\r\n\t\t\t<% /*datamembers:handle_init()*/ %>\r\n\t\t\t<% datamembers.forEach(function(datamember){ %>\r\n\t\t\tget_<%=datamember.name%>_handle_var() = rti->get<%=isinteraction?\"Parameter\":\"Attribute\"%>Handle( \"<%=datamember.name%>\", get_handle() );<%});%>\r\n\t\t\tisNotInitialized = false;\r\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\r\n\t\t\tstd::cerr << getInitErrorMessage() << \"Federate Not Execution Member\" << std::endl;\r\n\t\t\treturn;\t\t\t\t\r\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\r\n\t\t\tstd::cerr << getInitErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\r\n\t\t\treturn;\t\t\t\t\r\n\t\t} catch ( RTI::NameNotFound & ) {\r\n\t\t\tstd::cerr << getInitErrorMessage() << \"Name Not Found\" << std::endl;\r\n\t\t\treturn;\t\t\t\t\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << getInitErrorMessage() << \"Exception caught ... retry\" << std::endl;\r\n\t\t}\r\n\t}\r\n\t<% datamembers.forEach(function(datamember){ %>\r\n\t<% /*datamembers: { d |<initDatamemberNameHandleMap(classname=classname,datamember=d)>}*/ %>\r\n\tgetDatamemberNameHandleMap().insert(  std::make_pair( \"<%=classname%>,<%=datamember.name%>\", get_<%=datamember.name%>_handle() )  );\r\n\t<% /*datamembers:initDatamemberHandleNameMap()*/ %>\r\n\tgetDatamemberHandleNameMap().insert(  std::make_pair( get_<%=datamember.name%>_handle(), \"<%=datamember.name%>\" )  );\r\n\t<% /*datamembers:initDatamemberTypeMap()*/ %>\r\n\tgetDatamemberTypeMap().insert( std::make_pair(\"<%=datamember.name%>\", \"<%=datamember.parameterType%>\") );\r\n\t<%});%>\r\n<%}%>\r\n}\r\n\r\nvoid <%=classname%>::publish( RTI::RTIambassador *rti ) {\r\n\tif ( getIsPublished() ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tinit( rti );\r\n\r\n<% if(!isinteraction){ %>\t\r\n\tgetPublishedAttributeHandleSet_var().empty();\r\n\tfor( StringVector::iterator stsItr = getPublishAttributeNameVector().begin() ; stsItr != getPublishAttributeNameVector().end() ; (void)++stsItr ) {\r\n\t\ttry {\r\n\t\t\tgetPublishedAttributeHandleSet_var().add(  getDatamemberNameHandleMap().find( \"<%=classname%>,\" + *stsItr )->second  );\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << getPublishErrorMessage() << \"Could not publish \\\"\" << *stsItr + \"\\\" attribute.\" << std::endl;\r\n\t\t}\r\n\t}\r\n<%}%>\r\n\r\n\tbool isNotPublished = true;\r\n\twhile( isNotPublished ) {\r\n\t\ttry {\r\n\t\t\trti->publish<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle()<% if(!isinteraction){ %>, getPublishedAttributeHandleSet_var()<%}%> );\r\n\t\t\tisNotPublished = false;\r\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\r\n\t\t\tstd::cerr << getPublishErrorMessage() << \"Federate Not Execution Member\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\r\n\t\t\tstd::cerr << getPublishErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << getPublishErrorMessage() << \"Exception caught ... retry\" << std::endl;\r\n\t\t}\r\n\t}\r\n\r\n\tgetIsPublished() = true;\r\n}\r\n\r\nvoid <%=classname%>::unpublish( RTI::RTIambassador *rti ) {\r\n\tif ( !getIsPublished() ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tinit( rti );\r\n\r\n\tbool isNotUnpublished = true;\r\n\twhile( isNotUnpublished ) {\r\n\t\ttry {\r\n\t\t\trti->unpublish<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle() );\r\n\t\t\tisNotUnpublished = false;\r\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\r\n\t\t\tstd::cerr << getUnpublishErrorMessage() + \"Federate Not Execution Member\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\r\n\t\t\tstd::cerr << getUnpublishErrorMessage() + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotPublished & ) {\r\n\t\t\tstd::cerr << getUnpublishErrorMessage() + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Published\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << getUnpublishErrorMessage() << \"Exception caught ... retry\" << std::endl;\r\n\t\t}\r\n\t}\r\n\r\n\tgetIsPublished() = false;\r\n}\r\n\r\nvoid <%=classname%>::subscribe( RTI::RTIambassador *rti ) {\r\n\tif ( getIsSubscribed() ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tinit( rti );\r\n<% if(!isinteraction){ %>\t\r\n\tgetSubscribedAttributeHandleSet_var().empty();\r\n\tfor(  StringVector::iterator sstItr = getSubscribeAttributeNameVector().begin() ; sstItr != getSubscribeAttributeNameVector().end() ; (void)++sstItr  ) {\r\n\t\ttry {\r\n\t\t\tgetSubscribedAttributeHandleSet_var().add(  getDatamemberNameHandleMap().find( \"<%=classname%>,\" + *sstItr )->second  );\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << getSubscribeErrorMessage() << \"Could not subscribe to \\\"\" << *sstItr << \"\\\" attribute.\" << std::endl;\r\n\t\t}\r\n\t}\r\n<%}%>\r\n\t\r\n\tbool isNotSubscribed = true;\r\n\twhile( isNotSubscribed ) {\r\n\t\ttry {\r\n\t\t\trti->subscribe<% if(isinteraction){ %>InteractionClass( get_handle() )<% }else{ %>ObjectClassAttributes( get_handle(), getSubscribedAttributeHandleSet_var() )<%}%>;\r\n\t\t\tisNotSubscribed = false;\r\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\r\n\t\t\tstd::cerr << getSubscribeErrorMessage() << \"Federate Not Execution Member\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\r\n\t\t\tstd::cerr << getSubscribeErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << getSubscribeErrorMessage() << \"Exception caught ... retry\" << std::endl;\r\n\t\t}\r\n\t}\r\n\r\n\tgetIsSubscribed() = true;\r\n}\r\n\t\r\nvoid <%=classname%>::unsubscribe( RTI::RTIambassador *rti ) {\r\n\tif ( !getIsSubscribed() ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tinit( rti );\r\n\t\r\n\tbool isNotUnsubscribed = true;\r\n\twhile( isNotUnsubscribed ) {\r\n\t\ttry {\r\n\t\t\trti->unsubscribe<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle() );\r\n\t\t\tisNotUnsubscribed = false;\r\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\r\n\t\t\tstd::cerr << getUnsubscribeErrorMessage() << \"Federate Not Execution Member\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined & ) {\r\n\t\t\tstd::cerr << getUnsubscribeErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::<%=isinteraction?\"Interaction\":\"Object\"%>ClassNotSubscribed & ) {\r\n\t\t\tstd::cerr << getUnsubscribeErrorMessage() << \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Subscribed\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << getUnsubscribeErrorMessage() << \"Exception caught ... retry\" << std::endl;\r\n\t\t}\r\n\t}\r\n\r\n\tgetIsSubscribed() = false;\r\n}\r\n\r\nbool <%=classname%>::static_init( void ) {\r\n\tstatic bool isInitialized = false;\r\n\tif ( isInitialized ) {\r\n\t\treturn true;\r\n\t}\r\n\tisInitialized = true;\r\n\t\r\n\tgetClassNameSet().insert( \"<%=classname%>\" );\r\n\t\r\n\tgetClassNameFactoryMap().insert(  std::make_pair( \"<%=classname%>\", &<%=classname%>::factory )  );\r\n\tgetClassNamePublishMap().insert(   std::make_pair(  \"<%=classname%>\", (PubsubFunctionPtr)( &<%=classname%>::publish )  )   );\r\n\tgetClassNameUnpublishMap().insert(   std::make_pair(  \"<%=classname%>\", (PubsubFunctionPtr)( &<%=classname%>::unpublish )  )   );\r\n\tgetClassNameSubscribeMap().insert(   std::make_pair(  \"<%=classname%>\", (PubsubFunctionPtr)( &<%=classname%>::subscribe )  )   );\r\n\tgetClassNameUnsubscribeMap().insert(   std::make_pair(  \"<%=classname%>\", (PubsubFunctionPtr)( &<%=classname%>::unsubscribe )  )   );\r\n\r\n\tgetDatamemberClassNameVectorPtrMap().insert(  std::make_pair( \"<%=classname%>\", &getDatamemberNames() )  );\r\n\tgetAllDatamemberClassNameVectorPtrMap().insert(  std::make_pair( \"<%=classname%>\", &getAllDatamemberNames() )  );\r\n\t\r\n\t<% /*datamembers:initDatamemberNameSet()*/ %>\r\n\t<% datamembers.forEach(function(datamember){ %>\r\n\t<% if(!datamember.hidden && !datamember.inherited){%>getDatamemberNames().push_back( \"<%=datamember.name%>\" );<%}%><%});%>\r\n\t<% /*alldatamembers:initAllDatamemberNameSet()*/ %>\r\n\t<% datamembers.forEach(function(datamember){ %>\r\n\tgetAllDatamemberNames().push_back( \"<%=datamember.name%>\" );<%});%>\r\n\r\n<% if(!isinteraction){ %>\r\n\tgetClassNamePublishAttributeNameVectorPtrMap().insert(  std::make_pair( \"<%=classname%>\", &getPublishAttributeNameVector() )  );\r\n\tgetClassNameSubscribeAttributeNameVectorPtrMap().insert(  std::make_pair( \"<%=classname%>\", &getSubscribeAttributeNameVector() )  );\r\n\t\r\n\tgetClassNamePublishedAttributesPtrMap().insert(  std::make_pair( \"<%=classname%>\", &getPublishedAttributeHandleSet_var() )  );\r\n\tgetClassNameSubscribedAttributesPtrMap().insert( std::make_pair( \"<%=classname%>\", &getSubscribedAttributeHandleSet_var() )  );\r\n<%}%>\r\n\r\n\treturn true;\r\n}\r\n\r\nstd::ostream &operator<<( std::ostream &os, <%=classname%>::SP entitySP ) {\r\n\treturn os << *entitySP;\r\n}\r\nstd::ostream &operator<<( std::ostream &os, const <%=classname%> &entity ) {\r\n\treturn os << \"<%=classname%>(\" <% alldatamembers.forEach(function(datamember,i){ %><% if( i > 0){%> << \", \"<%}%> << \"<%=datamember.name%>:\" << entity.get_<%=datamember.name%>()<%});%>\t<< \")\";\r\n}\r\n",
    "classcommon.hpp.ejs": "<% /*classcommon(isinteraction,classname,parentclassname,hlaclassname,datamembers,alldatamembers) ::= <<*/ %>\r\nprivate:\r\n\tstatic int &getHandle( void ) {\r\n\t\tstatic int handle;\r\n\t\treturn handle;\r\n\t}\r\n\r\npublic:\r\n\tstatic int get_handle( void ) { return getHandle(); }\r\n\tstatic std::string get_class_name( void ) { return \"<%=classname%>\"; }\r\n\r\nprivate:\r\n\tstatic StringVector &getDatamemberNames( void ) {\r\n\t\tstatic StringVector datamemberNames;\r\n\t\treturn datamemberNames;\r\n\t}\r\n\r\n\tstatic StringVector &getAllDatamemberNames( void ) {\r\n\t\tstatic StringVector allDatamemberNames;\r\n\t\treturn allDatamemberNames;\r\n\t}\r\n\r\n<% if(!isinteraction){ %>\r\nprivate:\r\n\tstatic RTI::AttributeHandleSet &getPublishedAttributeHandleSet_var( void ) {\r\n\t\tstatic RTI::AttributeHandleSet *publishedAttributeHandleSetPtr = RTI::AttributeHandleSetFactory::create( <%= alldatamembers.length %> );\r\n\t\treturn *publishedAttributeHandleSetPtr;\r\n\t}\r\n\tstatic StringVector &getPublishAttributeNameVector( void ) {\r\n\t\tstatic StringVector publishAttributeNameVector;\r\n\t\treturn publishAttributeNameVector;\r\n\t}\t\r\n\t\r\n\tstatic RTI::AttributeHandleSet &getSubscribedAttributeHandleSet_var( void ) {\r\n\t\tstatic RTI::AttributeHandleSet *subscribedAttributeHandleSet = RTI::AttributeHandleSetFactory::create( <%= alldatamembers.length %> );\r\n\t\treturn *subscribedAttributeHandleSet;\r\n\t}\r\n\tstatic StringVector &getSubscribeAttributeNameVector( void ) {\r\n\t\tstatic StringVector subscribeAttributeNameVector;\r\n\t\treturn subscribeAttributeNameVector;\r\n\t}\t\r\n<%}%>\r\n\r\nprivate:\r\n<% if(isinteraction){ %>\r\n\tstatic InteractionRoot::SP factory( void ) {\r\n\t\treturn InteractionRoot::SP( new <%=classname%>() );\r\n\t}\r\n<% }else{ %>\r\n\tstatic ObjectRoot::SP factory( void ) {\r\n\t\treturn ObjectRoot::SP( new <%=classname%>() );\r\n\t}\r\n<%}%>\r\n\r\n\tstatic std::string &getInitErrorMessage( void ) {\r\n\t\tstatic std::string initErrorMessage( \"Error:  <%=classname%>:  could not initialize:  \" );\r\n\t\treturn initErrorMessage;\r\n\t}\r\n\r\nprotected:\r\n\tstatic void init( RTI::RTIambassador *rti );\r\n\t\r\nprivate:\r\n\tstatic bool &getIsPublished( void ) {\r\n\t\tstatic bool isPublished = false;\r\n\t\treturn isPublished;\r\n\t}\r\n\t\r\n\tstatic std::string &getPublishErrorMessage( void ) {\r\n\t\tstatic std::string publishErrorMessage = \"Error:  <%=classname%>:  could not publish:  \";\r\n\t\treturn publishErrorMessage;\r\n\t}\r\n\t\r\npublic:\r\n\tstatic void publish( RTI::RTIambassador *rti );\r\n\t\r\nprivate:\r\n\tstatic std::string &getUnpublishErrorMessage( void ) {\r\n\t\tstatic std::string unpublishErrorMessage = \"Error:  <%=classname%>:  could not unpublish:  \";\r\n\t\treturn unpublishErrorMessage;\r\n\t}\r\n\r\npublic:\r\n\tstatic void unpublish( RTI::RTIambassador *rti );\r\n\r\nprivate:\r\n\tstatic bool &getIsSubscribed( void ) {\r\n\t\tstatic bool isSubscribed = false;\r\n\t\treturn isSubscribed;\r\n\t}\r\n\tstatic std::string &getSubscribeErrorMessage( void ) {\r\n\t\tstatic std::string subscribedErrorMessage = \"Error:  <%=classname%>:  could not subscribe:  \";\r\n\t\treturn subscribedErrorMessage;\r\n\t}\r\n\r\npublic:\r\n\tstatic void subscribe( RTI::RTIambassador *rti );\r\n\t\t\r\nprivate:\r\n\tstatic std::string getUnsubscribeErrorMessage( void ) {\r\n\t\tstatic std::string unsubscribeErrorMessage = \"Error:  <%=classname%>:  could not unsubscribe:  \";\r\n\t\treturn unsubscribeErrorMessage;\r\n\t}\r\n\t\r\npublic:\r\n\tstatic void unsubscribe( RTI::RTIambassador *rti );\r\n\t\r\n\tstatic bool static_init( void );\r\n\t\r\n\tstatic bool match( int handle ) { return handle == get_handle(); }\r\n\r\n\tvirtual int getClassHandle( void ) const { return get_handle(); }\r\n\tvirtual std::string getClassName( void ) const { return get_class_name(); }\r\n\tvirtual StringVector get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names( void ) const { return get_<%=isinteraction?\"parameter\":\"attribute\"%>_names(); }\r\n\tvirtual StringVector getAll<%=isinteraction?\"Parameter\":\"Attribute\"%>Names( void ) const { return get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names(); }\r\n\r\n\tvirtual void publish<%=isinteraction?\"Interaction\":\"Object\"%>( RTI::RTIambassador *rti ) { publish( rti ); }\r\n\tvirtual void subscribe<%=isinteraction?\"Interaction\":\"Object\"%>( RTI::RTIambassador *rti ) { subscribe( rti ); }\r\n\r\n\tvirtual <%=isinteraction?\"Interaction\":\"Object\"%>Root::SP clone( void ) {\r\n\t\treturn <%=isinteraction?\"Interaction\":\"Object\"%>Root::SP(  new <%=classname%>( *this )  );\r\n\t}\r\n\r\n<% if(!isinteraction){%>\r\n\tvirtual const RTI::AttributeHandleSet &getSubscribedAttributeHandleSet( void ) { return getSubscribedAttributeHandleSet_var(); }\r\n<%}%>\r\n",
    "classcommon.java.ejs": "<% /*classcommon(isinteraction,classname,parentclassname,hlaclassname,datamembers,alldatamembers) */ %>\r\n\tprivate static boolean _isInitialized = false;\r\n\r\n\tprivate static int _handle;\r\n\r\n\t/**\r\n\t* Returns the handle (RTI assigned) of the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\r\n\t* Note: As this is a static method, it is NOT polymorphic, and so, if called on\r\n\t* a reference will return the handle of the class pertaining to the reference,\\\r\n\t* rather than the handle of the class for the instance referred to by the reference.\r\n\t* For the polymorphic version of this method, use {@link #getClassHandle()}.\r\n\t*/\r\n\tpublic static int get_handle() { return _handle; }\r\n\r\n\t/**\r\n\t* Returns the fully-qualified (dot-delimited) name of the <%= classname %>\r\n\t* <%=isinteraction?\"interaction\":\"object\"%> class.\r\n\t* Note: As this is a static method, it is NOT polymorphic, and so, if called on\r\n\t* a reference will return the name of the class pertaining to the reference,\\\r\n\t* rather than the name of the class for the instance referred to by the reference.\r\n\t* For the polymorphic version of this method, use {@link #getClassName()}.\r\n\t*/\r\n\tpublic static String get_class_name() { return \"<%=hlaclassname%>\"; }\r\n\r\n\t/**\r\n\t* Returns the simple name (the last name in the dot-delimited fully-qualified\r\n\t* class name) of the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\r\n\t*/\r\n\tpublic static String get_simple_class_name() { return \"<%= classname %>\"; }\r\n\r\n\tprivate static Set< String > _datamemberNames = new HashSet< String >();\r\n\tprivate static Set< String > _allDatamemberNames = new HashSet< String >();\r\n\r\n\t/**\r\n\t* Returns a set containing the names of all of the non-hidden <%=isinteraction?\"parameter\":\"attribute\"%>s in the\r\n\t* <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\r\n\t* Note: As this is a static method, it is NOT polymorphic, and so, if called on\r\n\t* a reference will return a set of parameter names pertaining to the reference,\\\r\n\t* rather than the parameter names of the class for the instance referred to by\r\n\t* the reference.  For the polymorphic version of this method, use\r\n\t* {@link #get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names()}.\r\n\t*/\r\n\tpublic static Set< String > get_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\r\n\t\treturn new HashSet< String >( _datamemberNames );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* Returns a set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s in the\r\n\t* <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\r\n\t* Note: As this is a static method, it is NOT polymorphic, and so, if called on\r\n\t* a reference will return a set of parameter names pertaining to the reference,\\\r\n\t* rather than the parameter names of the class for the instance referred to by\r\n\t* the reference.  For the polymorphic version of this method, use\r\n\t* {@link #get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names()}.\r\n\t*/\r\n\tpublic static Set< String > get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\r\n\t\treturn new HashSet< String >( _allDatamemberNames );\r\n\t}\r\n\r\n\r\n\t<% if(!isinteraction){ %>\r\n\tprivate static AttributeHandleSet _publishedAttributeHandleSet;\r\n\tprivate static Set< String > _publishAttributeNameSet = new HashSet< String >();\r\n\r\n\tprivate static AttributeHandleSet _subscribedAttributeHandleSet; \r\n\tprivate static Set< String > _subscribeAttributeNameSet = new HashSet< String >();\r\n\r\n\t<%}%>\r\n\r\n\tstatic {\r\n\t\t_classNameSet.add( \"<%= hlaclassname %>\" );\r\n\t\t_classNameClassMap.put( \"<%= hlaclassname %>\", <%= classname %>.class );\r\n\t\t\r\n\t\t_datamemberClassNameSetMap.put( \"<%= hlaclassname %>\", _datamemberNames );\r\n\t\t_allDatamemberClassNameSetMap.put( \"<%= hlaclassname %>\", _allDatamemberNames );\r\n\r\n\t\t<%/*alldatamembers:initDatamemberNameSet()*/%>\r\n\t\t<% alldatamembers.forEach(function(datamember){%>\r\n\t\t<% if(!datamember.hidden && !datamember.inherited){ %>_datamemberNames.add( \"<%=datamember.name%>\" );<%}%><%}); %>\r\n\t\t<%/*alldatamembers:initAllDatamemberNameSet()*/%>\r\n\t\t<% alldatamembers.forEach(function(datamember){%>\r\n\t\t_allDatamemberNames.add( \"<%=datamember.name%>\" );<%}); %>\r\n\t\t<%/*datamembers:initDatamemberTypeMap()*/%>\r\n\t\t<% datamembers.forEach(function(datamember){%>\r\n\t\t_datamemberTypeMap.put( \"<%=datamember.name%>\", \"<%=datamember.parameterType%>\" );<%}); %>\r\n\t<% if(isinteraction){ %>\r\n\t<% }else{ %>\r\n\r\n\t\t_classNamePublishAttributeNameMap.put( \"<%= hlaclassname %>\", _publishAttributeNameSet );\r\n\t\t_publishedAttributeHandleSet = _factory.createAttributeHandleSet();\r\n\t\t_classNamePublishedAttributeMap.put( \"<%= hlaclassname %>\", _publishedAttributeHandleSet );\r\n\r\n\t\t_classNameSubscribeAttributeNameMap.put( \"<%= hlaclassname %>\", _subscribeAttributeNameSet );\r\n\t\t_subscribedAttributeHandleSet = _factory.createAttributeHandleSet();\r\n\t\t_classNameSubscribedAttributeMap.put( \"<%= hlaclassname %>\", _subscribedAttributeHandleSet );\r\n\t<%}%>\r\n\r\n\t}\r\n\r\n\r\n\tprivate static String initErrorMessage = \"Error:  <%= hlaclassname %>:  could not initialize:  \";\r\n\tprotected static void init( RTIambassador rti ) {\r\n\t\tif ( _isInitialized ) return;\r\n\t\t_isInitialized = true;\r\n\t\t\r\n\t\t<% if(parentclassname){ %><%=parentclassname%>.init( rti );<%}%>\r\n\t\t\r\n\t\tboolean isNotInitialized = true;\r\n\t\twhile( isNotInitialized ) {\r\n\t\t\ttry {\r\n\t\t\t\t_handle = rti.get<%=isinteraction?\"Interaction\":\"Object\"%>ClassHandle( \"<%= hlaclassname %>\" );\r\n\t\t\t\tisNotInitialized = false;\r\n\t\t\t} catch ( FederateNotExecutionMember f ) {\r\n\t\t\t\tSystem.err.println( initErrorMessage + \"Federate Not Execution Member\" );\r\n\t\t\t\tf.printStackTrace();\r\n\t\t\t\treturn;\t\t\t\t\r\n\t\t\t} catch ( NameNotFound n ) {\r\n\t\t\t\tSystem.err.println( initErrorMessage + \"Name Not Found\" );\r\n\t\t\t\tn.printStackTrace();\r\n\t\t\t\treturn;\t\t\t\t\r\n\t\t\t} catch ( Exception e ) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t\ttry { Thread.sleep( 50 ); } catch( Exception e1 ) { }\t\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t_classNameHandleMap.put( \"<%= hlaclassname %>\", get_handle() );\r\n\t\t_classHandleNameMap.put( get_handle(), \"<%= hlaclassname %>\" );\r\n\t\t_classHandleSimpleNameMap.put( get_handle(), \"<%= classname %>\" );\r\n\r\n\t\t<% if(datamembers && datamembers.length > 0){ %>\r\n\t\tisNotInitialized = true;\r\n\t\twhile( isNotInitialized ) {\r\n\t\t\ttry {<%/*datamembers:handle_init()*/%>\r\n\t\t\t\t<% datamembers.forEach(function(datamember){%>\t\t\t\r\n\t\t\t\t_<%=datamember.name%>_handle = rti.get<%=isinteraction?\"Parameter\":\"Attribute\"%>Handle( \"<%=datamember.name%>\", get_handle() );<%}); %>\r\n\t\t\t\tisNotInitialized = false;\r\n\t\t\t} catch ( FederateNotExecutionMember f ) {\r\n\t\t\t\tSystem.err.println( initErrorMessage + \"Federate Not Execution Member\" );\r\n\t\t\t\tf.printStackTrace();\r\n\t\t\t\treturn;\t\t\t\t\r\n\t\t\t} catch ( <%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined i ) {\r\n\t\t\t\tSystem.err.println( initErrorMessage + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" );\r\n\t\t\t\ti.printStackTrace();\r\n\t\t\t\treturn;\t\t\t\t\r\n\t\t\t} catch ( NameNotFound n ) {\r\n\t\t\t\tSystem.err.println( initErrorMessage + \"Name Not Found\" );\r\n\t\t\t\tn.printStackTrace();\r\n\t\t\t\treturn;\t\t\t\t\r\n\t\t\t} catch ( Exception e ) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t\ttry { Thread.sleep( 50 ); } catch( Exception e1 ) { }\t\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\t\t<%/*  datamembers: { d |<initDatamemberNameHandleMap(hlaclassname=hlaclassname,datamember=d)>}  */%>\r\n\t\t\t<% datamembers.forEach(function(datamember){%>\r\n\t\t_datamemberNameHandleMap.put( \"<%=hlaclassname%>,<%=datamember.name%>\", get_<%=datamember.name%>_handle() );<%}); %>\r\n\t\t\t<%/*datamembers:initDatamemberHandleNameMap()*/%>\r\n\t\t\t<% datamembers.forEach(function(datamember){%>\r\n\t\t_datamemberHandleNameMap.put( get_<%=datamember.name%>_handle(), \"<%=datamember.name%>\" );<%}); %>\r\n\t\t<%}%>\r\n\t}\r\n\r\n\r\n\tprivate static boolean _isPublished = false;\r\n\tprivate static String publishErrorMessage = \"Error:  <%= hlaclassname %>:  could not publish:  \";\r\n\r\n\t/**\r\n\t* Publishes the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class for a federate.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic static void publish( RTIambassador rti ) {\r\n\t\tif ( _isPublished ) return;\r\n\t\t\r\n\t\tinit( rti );\r\n\r\n\t<% if(isinteraction){ %><% }else{ %>\t\r\n\t\t_publishedAttributeHandleSet.empty();\r\n\t\tfor( String attributeName : _publishAttributeNameSet ) {\r\n\t\t\ttry {\r\n\t\t\t\t_publishedAttributeHandleSet.add(  _datamemberNameHandleMap.get( \"<%= hlaclassname %>,\" + attributeName )  );\r\n\t\t\t} catch ( Exception e ) {\r\n\t\t\t\tSystem.err.println( publishErrorMessage + \"Could not publish \\\"\" + attributeName + \"\\\" attribute.\" );\r\n\t\t\t}\r\n\t\t}\r\n\t<%}%>\r\n\r\n\t\tsynchronized( rti ) {\r\n\t\t\tboolean isNotPublished = true;\r\n\t\t\twhile( isNotPublished ) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\trti.publish<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle()<% if(isinteraction){ %><% }else{ %>, _publishedAttributeHandleSet<%}%> );\r\n\t\t\t\t\tisNotPublished = false;\r\n\t\t\t\t} catch ( FederateNotExecutionMember f ) {\r\n\t\t\t\t\tSystem.err.println( publishErrorMessage + \"Federate Not Execution Member\" );\r\n\t\t\t\t\tf.printStackTrace();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} catch ( <%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined i ) {\r\n\t\t\t\t\tSystem.err.println( publishErrorMessage + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" );\r\n\t\t\t\t\ti.printStackTrace();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} catch ( Exception e ) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\ttry { Thread.sleep( 50 ); } catch( Exception e1 ) { }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t_isPublished = true;\r\n\t}\r\n\r\n\tprivate static String unpublishErrorMessage = \"Error:  <%= hlaclassname %>:  could not unpublish:  \";\r\n\t/**\r\n\t* Unpublishes the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class for a federate.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic static void unpublish( RTIambassador rti ) {\r\n\t\tif ( !_isPublished ) return;\r\n\t\t\r\n\t\tinit( rti );\r\n\t\tsynchronized( rti ) {\r\n\t\t\tboolean isNotUnpublished = true;\r\n\t\t\twhile( isNotUnpublished ) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\trti.unpublish<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle() );\r\n\t\t\t\t\tisNotUnpublished = false;\r\n\t\t\t\t} catch ( FederateNotExecutionMember f ) {\r\n\t\t\t\t\tSystem.err.println( unpublishErrorMessage + \"Federate Not Execution Member\" );\r\n\t\t\t\t\tf.printStackTrace();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} catch ( <%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined i ) {\r\n\t\t\t\t\tSystem.err.println( unpublishErrorMessage + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" );\r\n\t\t\t\t\ti.printStackTrace();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} catch ( <%=isinteraction?\"Interaction\":\"Object\"%>ClassNotPublished i ) {\r\n\t\t\t\t\tSystem.err.println( unpublishErrorMessage + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Published\" );\r\n\t\t\t\t\ti.printStackTrace();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} catch ( Exception e ) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\ttry { Thread.sleep( 50 ); } catch( Exception e1 ) { }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t_isPublished = false;\r\n\t}\r\n\r\n\tprivate static boolean _isSubscribed = false;\r\n\tprivate static String subscribeErrorMessage = \"Error:  <%= hlaclassname %>:  could not subscribe:  \";\r\n\t/**\r\n\t* Subscribes a federate to the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic static void subscribe( RTIambassador rti ) {\r\n\t\tif ( _isSubscribed ) return;\r\n\t\t\r\n\t\tinit( rti );\r\n\t<% if(isinteraction){ %><% }else{ %>\t\r\n\t\t_subscribedAttributeHandleSet.empty();\r\n\t\tfor( String attributeName : _subscribeAttributeNameSet ) {\r\n\t\t\ttry {\r\n\t\t\t\t_subscribedAttributeHandleSet.add(  _datamemberNameHandleMap.get( \"<%= hlaclassname %>,\" + attributeName )  );\r\n\t\t\t} catch ( Exception e ) {\r\n\t\t\t\tSystem.err.println( subscribeErrorMessage + \"Could not subscribe to \\\"\" + attributeName + \"\\\" attribute.\" );\r\n\t\t\t}\r\n\t\t}\r\n\t<%}%>\r\n\t\t\r\n\t\tsynchronized( rti ) {\r\n\t\t\tboolean isNotSubscribed = true;\r\n\t\t\twhile( isNotSubscribed ) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\trti.subscribe<% if(isinteraction){ %>InteractionClass( get_handle() )<% }else{ %>ObjectClassAttributes( get_handle(), _subscribedAttributeHandleSet )<%}%>;\r\n\t\t\t\t\tisNotSubscribed = false;\r\n\t\t\t\t} catch ( FederateNotExecutionMember f ) {\r\n\t\t\t\t\tSystem.err.println( subscribeErrorMessage + \"Federate Not Execution Member\" );\r\n\t\t\t\t\tf.printStackTrace();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} catch ( <%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined i ) {\r\n\t\t\t\t\tSystem.err.println( subscribeErrorMessage + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" );\r\n\t\t\t\t\ti.printStackTrace();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} catch ( Exception e ) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\ttry { Thread.sleep( 50 ); } catch( Exception e1 ) { }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t_isSubscribed = true;\r\n\t}\r\n\r\n\tprivate static String unsubscribeErrorMessage = \"Error:  <%= hlaclassname %>:  could not unsubscribe:  \";\r\n\t/**\r\n\t* Unsubscribes a federate from the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic static void unsubscribe( RTIambassador rti ) {\r\n\t\tif ( !_isSubscribed ) return;\r\n\r\n\t\tinit( rti );\r\n\t\tsynchronized( rti ) {\r\n\t\t\tboolean isNotUnsubscribed = true;\r\n\t\t\twhile( isNotUnsubscribed ) {\r\n\t\t\t\ttry {\r\n\t\t\t\t\trti.unsubscribe<%=isinteraction?\"Interaction\":\"Object\"%>Class( get_handle() );\r\n\t\t\t\t\tisNotUnsubscribed = false;\r\n\t\t\t\t} catch ( FederateNotExecutionMember f ) {\r\n\t\t\t\t\tSystem.err.println( unsubscribeErrorMessage + \"Federate Not Execution Member\" );\r\n\t\t\t\t\tf.printStackTrace();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} catch ( <%=isinteraction?\"Interaction\":\"Object\"%>ClassNotDefined i ) {\r\n\t\t\t\t\tSystem.err.println( unsubscribeErrorMessage + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Defined\" );\r\n\t\t\t\t\ti.printStackTrace();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} catch ( <%=isinteraction?\"Interaction\":\"Object\"%>ClassNotSubscribed i ) {\r\n\t\t\t\t\tSystem.err.println( unsubscribeErrorMessage + \"<%=isinteraction?\"Interaction\":\"Object\"%> Class Not Subscribed\" );\r\n\t\t\t\t\ti.printStackTrace();\r\n\t\t\t\t\treturn;\r\n\t\t\t\t} catch ( Exception e ) {\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\ttry { Thread.sleep( 50 ); } catch( Exception e1 ) { }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t_isSubscribed = false;\r\n\t}\r\n\r\n\t/**\r\n\t* Return true if \"handle\" is equal to the handle (RTI assigned) of this class\r\n\t* (that is, the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class).\r\n\t*\r\n\t* @param handle handle to compare to the value of the handle (RTI assigned) of\r\n\t* this class (the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class).\r\n\t* @return \"true\" if \"handle\" matches the value of the handle of this class\r\n\t* (that is, the <%= classname %> <%=isinteraction?\"interaction\":\"object\"%> class).\r\n\t*/\r\n\tpublic static boolean match( int handle ) { return handle == get_handle(); }\r\n\r\n\t/**\r\n\t* Returns the handle (RTI assigned) of this instance's <%=isinteraction?\"interaction\":\"object\"%> class .\r\n\t* \r\n\t* @return the handle (RTI assigned) if this instance's <%=isinteraction?\"interaction\":\"object\"%> class\r\n\t*/\r\n\tpublic int getClassHandle() { return get_handle(); }\r\n\r\n\t/**\r\n\t* Returns the fully-qualified (dot-delimited) name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class.\r\n\t* \r\n\t* @return the fully-qualified (dot-delimited) name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class\r\n\t*/\r\n\tpublic String getClassName() { return get_class_name(); }\r\n\r\n\t/**\r\n\t* Returns the simple name (last name in its fully-qualified dot-delimited name)\r\n\t* of this instance's <%=isinteraction?\"interaction\":\"object\"%> class.\r\n\t* \r\n\t* @return the simple name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class \r\n\t*/\r\n\tpublic String getSimpleClassName() { return get_simple_class_name(); }\r\n\r\n\t/**\r\n\t* Returns a set containing the names of all of the non-hidden<%=isinteraction?\"parameter\":\"attribute\"%>s of an\r\n\t* <%=isinteraction?\"interaction\":\"object\"%> class instance.\r\n\t*\r\n\t* @return set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\r\n\t* <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n\t*/\r\n\tpublic Set< String > get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names() { return get_<%=isinteraction?\"parameter\":\"attribute\"%>_names(); }\r\n\r\n\t/**\r\n\t* Returns a set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\r\n\t* <%=isinteraction?\"interaction\":\"object\"%> class instance.\r\n\t*\r\n\t* @return set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\r\n\t* <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n\t*/\r\n\tpublic Set< String > getAll<%=isinteraction?\"Parameter\":\"Attribute\"%>Names() { return get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names(); }\r\n\r\n\t/**\r\n\t* Publishes the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of the class for a federate.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic void publish<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti ) { publish( rti ); }\r\n\r\n\t/**\r\n\t* Unpublishes the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class for a federate.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic void unpublish<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti ) { unpublish( rti ); }\r\n\r\n\t/**\r\n\t* Subscribes a federate to the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic void subscribe<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti ) { subscribe( rti ); }\r\n\r\n\t/**\r\n\t* Unsubscribes a federate from the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic void unsubscribe<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti ) { unsubscribe( rti ); }\r\n\r\n\t<% if(isinteraction){ %><% }else{ %>\r\n\t/**\r\n\t* Returns a data structure containing the handles of all attributes for this object\r\n\t* class that are currently marked for subscription.  To actually subscribe to these\r\n\t* attributes, a federate must call <objectclassname>.subscribe( RTIambassador rti ).\r\n\t*\r\n\t* @return data structure containing the handles of all attributes for this object\r\n\t* class that are currently marked for subscription\r\n\t*/\r\n\tpublic AttributeHandleSet getSubscribedAttributeHandleSet() { return _subscribedAttributeHandleSet; }\r\n\t<%}%>\r\n\r\n\tpublic String toString() {\r\n\t\treturn \"<%= classname %>(\"\r\n\t\t\t<%/*datamembers:stringValue(); separator=\"+ \\\",\\\"\"*/%>\r\n\t\t\t<%var separator = false; datamembers.forEach(function(datamember){%>\r\n\t\t\t<%if(separator){%>+ \",\" <%}else{separator=true;}%>+ \"<%=datamember.name%>:\" + get_<%=datamember.name%>()<%});%>\r\n\t\t\t+ \")\";\r\n\t}",
    "classroot.cpp.ejs": "<% /* THIS IS THE ROOT CLASS OF EITHER THE INTERACTION OR OBJECT-CLASS HEIRARCHY (I.E. \"InteractionRoot\" OR \"ObjectRoot\") */ %>\r\n<% /*classroot(isinteraction) ::= <<*/ %>\r\n// This code has been generated by the C2W code generator.\r\n// Do not edit manually!\r\n\r\n/*\r\n * Copyright (c) 2008, Institute for Software Integrated Systems, Vanderbilt University\r\n * All rights reserved.\r\n *\r\n * Permission to use, copy, modify, and distribute this software and its\r\n * documentation for any purpose, without fee, and without written agreement is\r\n * hereby granted, provided that the above copyright notice, the following\r\n * two paragraphs and the author appear in all copies of this software.\r\n *\r\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\r\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\r\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\r\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\r\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\r\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\r\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\r\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\r\n *\r\n * @author Himanshu Neema\r\n * @author Harmon Nine\r\n */\r\n\r\n#include <boost/lexical_cast.hpp>\r\n#include \"<%=isinteraction?\"Interaction\":\"Object\"%>Root.hpp\"\r\n\r\nC2WLogger* <%=isinteraction?\"Interaction\":\"Object\"%>Root::_logger = &C2W_RTI_LOGGER_CLS::get_singleton();\r\n\r\n<% /*classcommon(classname=apMap.classfirstupper+\"Root\",hlaclassname=apMap.classfirstupper+\"Root\",...)*/ %>\r\n<%- ejs.render(TEMPLATES[\"classcommon.cpp.ejs\"],\r\n\t{\tisinteraction: isinteraction,\r\n\t\tclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\r\n\t\tparentclassname: \"\",\r\n\t\thlaclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\r\n\t\tdatamembers: [],\r\n\t\talldatamembers: []\r\n}) %>\r\n\r\n<% if(!isinteraction){ %>\r\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::publish( const std::string &className, const std::string &attributeName ) {\r\n\tNameStringVectorPtrMap::iterator camItr = getClassNamePublishAttributeNameVectorPtrMap().find( className );\r\n\tif ( camItr == getClassNamePublishAttributeNameVectorPtrMap().end() ) {\r\n\t\tstd::cerr << \"ERROR:  ObjectRoot.publish:  could not publish class \\\"\" << className << \"\\\" \\\"\" << attributeName << \"\\\" attribute.\" << std::endl;\r\n\t\treturn;\r\n\t}\r\n\tNameStringVectorPtrMap::iterator dnsItr = getAllDatamemberClassNameVectorPtrMap().find( className );\r\n\tif ( dnsItr == getAllDatamemberClassNameVectorPtrMap().end() ) {\r\n\t\tstd::cerr << \"ERROR:  ObjectRoot.publish:  unexpected error:  no datamember vector for class \\\"\" << className << \"\\\"\" << std::endl;\r\n\t\treturn;\r\n\t}\r\n\tif (  std::find ( dnsItr->second->begin(), dnsItr->second->end(), attributeName ) == dnsItr->second->end()  ) {\r\n\t\tstd::cerr << \"ERROR:  ObjectRoot.publish:  no datamember named \\\"\" << attributeName << \"\\\" in class \\\"\" << className << \"\\\"\" << std::endl;\r\n\t\treturn;\r\n\t}\r\n\tcamItr->second->push_back( attributeName );\r\n}\r\n\r\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::subscribe( const std::string &className, const std::string &attributeName ) {\r\n\tNameStringVectorPtrMap::iterator camItr = getClassNameSubscribeAttributeNameVectorPtrMap().find( className );\r\n\tif ( camItr == getClassNameSubscribeAttributeNameVectorPtrMap().end() ) {\r\n\t\tstd::cerr << \"ERROR:  ObjectRoot.subscribe:  could not subscribe class \\\"\" << className << \"\\\" \\\"\" << attributeName << \"\\\" attribute.\" << std::endl;\r\n\t\treturn;\r\n\t}\r\n\tNameStringVectorPtrMap::iterator dnsItr = getAllDatamemberClassNameVectorPtrMap().find( className );\r\n\tif ( dnsItr == getAllDatamemberClassNameVectorPtrMap().end() ) {\r\n\t\tstd::cerr << \"ERROR:  ObjectRoot.subscribe:  unexpected error:  no datamember vector for class \\\"\" << className << \"\\\"\" << std::endl;\r\n\t\treturn;\r\n\t}\r\n\tif (  std::find ( dnsItr->second->begin(), dnsItr->second->end(), attributeName ) == dnsItr->second->end()  ) {\r\n\t\tstd::cerr << \"ERROR:  ObjectRoot.subscribe:  no datamember named \\\"\" << attributeName << \"\\\" in class \\\"\" << className << \"\\\"\" << std::endl;\r\n\t\treturn;\r\n\t}\r\n\tcamItr->second->push_back( attributeName );\r\n}\r\n\r\n<%}%>\r\n\t\r\n<%=isinteraction?\"Interaction\":\"Object\"%>Root::SP <%=isinteraction?\"Interaction\":\"Object\"%>Root::create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) {\r\n\tIntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\r\n\tif ( ismItr == getClassHandleNameMap().end() ) {\r\n\t\treturn SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 );\r\n\t}\r\n\t\r\n\tClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( ismItr->second );\r\n\tif ( cfmItr == getClassNameFactoryMap().end() ) {\r\n\t\treturn SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 );\r\n\t}\r\n\t\r\n\tSP sp = (*cfmItr->second)();\r\n\tsp->set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\r\n\r\n\treturn sp;\r\n}\r\n\r\n<%=isinteraction?\"Interaction\":\"Object\"%>Root::SP <%=isinteraction?\"Interaction\":\"Object\"%>Root::create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime ) {\r\n\tIntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\r\n\tif ( ismItr == getClassHandleNameMap().end() ) {\r\n\t\treturn SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 );\r\n\t}\r\n\t\r\n\tClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( ismItr->second );\r\n\tif ( cfmItr == getClassNameFactoryMap().end() ) {\r\n\t\treturn SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 );\r\n\t}\r\n\t\r\n\tSP sp = (*cfmItr->second)();\r\n\tsp->set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\r\n\tsp->setTime( dlc13FedTime.getTime() );\r\n\r\n\treturn sp;\r\n}\r\n\r\n\r\n<% if(!isinteraction){ %>\r\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::requestUpdate( RTI::RTIambassador *rti ) {\r\n\tbool requestNotSubmitted = true;\r\n\twhile( requestNotSubmitted ) {\r\n\t\ttry {\t\t\r\n\t\t\trti->requestObjectAttributeValueUpdate( getObjectHandle(), getSubscribedAttributeHandleSet_var() );\r\n\t\t\trequestNotSubmitted = false;\r\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\r\n\t\t\tstd::cerr << \"ERROR: \" << getClassName() << \"request for update failed:  Federate Not Execution Member\" << std::endl;\r\n\t\t\treturn;\t\t\t\t\r\n\t\t} catch ( RTI::ObjectNotKnown & ) {\r\n\t\t\tstd::cerr << \"ERROR: \" << getClassName() << \"request for update failed:  Object Not Known\" << std::endl;\r\n\t\t\treturn;\t\t\t\t\r\n\t\t} catch ( RTI::AttributeNotDefined & ) {\r\n\t\t\tstd::cerr << \"ERROR: \" << getClassName() << \"request for update failed:  Name Not Found\" << std::endl;\r\n\t\t\treturn;\t\t\t\t\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << \"ERROR: \" << getClassName() << \"request for update failed:  Unknown Exception\" << std::endl;\t\t\t}\r\n\t}\r\n}\r\n\r\n<%}%>\r\n\r\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) {\r\n\tint size = datamemberMap.size();\r\n\tfor( int ix = 0 ; ix < size ; ++ix ) {\r\n\t\ttry {\r\n\t\t\tstatic RTI::ULong valueLength;\r\n\t\t\tchar *value = datamemberMap.getValuePointer( ix, valueLength );\r\n\t\t\tset<%=isinteraction?\"Parameter\":\"Attribute\"%>(  datamemberMap.getHandle( ix ), std::string( value, valueLength )  );\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << \"set<%=isinteraction?\"Parameter\":\"Attribute\"%>s: Exception caught!\" << std::endl;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n<% if(isinteraction){ %>\r\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::sendInteraction( RTI::RTIambassador *rti, double time ) {\r\n\tbool interactionNotSent = true;\r\n\twhile( interactionNotSent ) {\r\n\t\ttry {\r\n\t\t\tParameterHandleValuePairSetSP datamembers = createDatamemberHandleValuePairSet( 0 );\r\n\t\t\trti->sendInteraction(  getClassHandle(), *datamembers, RTIfedTime( time ), 0  );\r\n\t\t\tcreateLog( time, true );\r\n\t\t\tinteractionNotSent = false;\r\n\t\t} catch ( RTI::InteractionClassNotDefined & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Class Not Defined\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::InteractionClassNotPublished & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Class Not Published\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::InteractionParameterNotDefined & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Parameter Not Defined\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::InvalidFederationTime & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Invalid Federation Time\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Federate Not Execution Member\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::ConcurrentAccessAttempted & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  ConcurrentAccessAttempted\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Exception caught ... retry\" << std::endl;\r\n#ifdef _WIN32\r\n\t\t\tSleep( 500 );\r\n#else\r\n\t\t\tusleep( 500000 );\r\n#endif\r\n\t\t}\r\n\t}\r\n}\r\n\r\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::sendInteraction( RTI::RTIambassador *rti ) {\r\n\tbool interactionNotSent = true;\r\n\twhile( interactionNotSent ) {\r\n\t\ttry {\r\n\t\t\tParameterHandleValuePairSetSP datamembers = createDatamemberHandleValuePairSet( 0 );\r\n\t\t\trti->sendInteraction(  getClassHandle(), *datamembers, 0  );\r\n\t\t\tcreateLog( 0, true );\r\n\t\t} catch ( RTI::InteractionClassNotDefined & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Class Not Defined\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::InteractionClassNotPublished & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Class Not Published\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::InteractionParameterNotDefined & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Interaction Parameter Not Defined\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::FederateNotExecutionMember & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Federate Not Execution Member\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( RTI::ConcurrentAccessAttempted & ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  ConcurrentAccessAttempted\" << std::endl;\r\n\t\t\treturn;\r\n\t\t} catch ( ... ) {\r\n\t\t\tstd::cerr << \"ERROR:  \" << getClassName() << \":  could not send interaction:  Exception caught ... retry\" << std::endl;\r\n#ifdef _WIN32\r\n\t\t\tSleep( 500 );\r\n#else\r\n\t\t\tusleep( 500000 );\r\n#endif\r\n\t\t}\r\n\t}\r\n}\r\n\r\nstd::string <%=isinteraction?\"Interaction\":\"Object\"%>Root::fedName = \"\";\r\nbool <%=isinteraction?\"Interaction\":\"Object\"%>Root::enablePubLog = false;\r\nbool <%=isinteraction?\"Interaction\":\"Object\"%>Root::enableSubLog = false;\r\nstd::string <%=isinteraction?\"Interaction\":\"Object\"%>Root::pubLogLevel = \"\";\r\nstd::string <%=isinteraction?\"Interaction\":\"Object\"%>Root::subLogLevel = \"\";\r\n\r\nvoid InteractionRoot::enablePublishLog( const std::string &interaction, const std::string &fed, const std::string &thislevel, const std::string &globallevel ) {\r\n\tif ( globallevel.empty() ) {\r\n\t\treturn;\r\n\t}\r\n\tif (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {\r\n\t\treturn;\r\n\t}\r\n\tfedName = fed;\r\n\tenablePubLog = true;\r\n\tpubLogLevel = thislevel;\r\n\t_logger->addLog(interaction, fedName, true);\r\n}\r\n\r\nvoid InteractionRoot::enableSubscribeLog( const std::string &interaction, const std::string &fed, const std::string &thislevel, const std::string &globallevel ) {\r\n\tif ( globallevel.empty() ) {\r\n\t\treturn;\r\n\t}\r\n\tif (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {\r\n\t\treturn;\r\n\t}\r\n\tfedName = fed;\r\n\tenableSubLog = true;\r\n\tsubLogLevel = thislevel;\r\n\t_logger->addLog( interaction, fedName, false );\r\n}\r\n\r\nvoid <%=isinteraction?\"Interaction\":\"Object\"%>Root::createLog( double time, bool isPub ) {\r\n\tif (  ( isPub && !enablePubLog ) || ( !isPub && !enableSubLog )  ) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tstd::string interactionId;\r\n\tif ( isPub ) {\r\n\t\tinteractionId = \"pub_\" + getClassName();\r\n\t\tif ( !fedName.empty() ) {\r\n\t\t\tinteractionId = fedName + \"_\" + interactionId;\r\n\t\t}\r\n\t} else {\r\n\t\tinteractionId = getClassName() + \"_sub\";\r\n\t\tif ( !fedName.empty() ) {\r\n\t\t\tinteractionId += \"_\" + fedName;\r\n\t\t}\r\n\t}\r\n\t\r\n\t_logger->addLog( interactionId, *this, time, pubLogLevel );\r\n}\r\n\r\n<%}else{%>\r\nvoid ObjectRoot::registerObject( RTI::RTIambassador *rti ) {\r\n    \r\n    while( !_isRegistered ) {\r\n        try {\r\n            _object_handle = rti->registerObjectInstance( getClassHandle() );\r\n            _isRegistered = true;\r\n        } catch ( RTI::ObjectClassNotDefined & ) {\r\n        \tstd::cerr << \"ERROR:  InteractionRoot::registerObject:  Object Class Not Defined\" << std::endl;\r\n            return;\r\n        } catch ( RTI::ObjectClassNotPublished & ) {\r\n        \tstd::cerr << \"ERROR:  InteractionRoot::registerObject:  Object Class Not Published\" << std::endl;\r\n            return;\r\n        } catch ( RTI::FederateNotExecutionMember & ) {\r\n        \tstd::cerr << \"ERROR:  InteractionRoot::registerObject:  Federate Not Execution Member\" << std::endl;\r\n            return;\r\n        } catch ( ... ) {\r\n        \tstd::cerr << \"InteractionRoot::registerObject:  Exception caught ... retry\" << std::endl;\r\n        }\r\n    }\r\n\r\n}\r\n\r\nvoid ObjectRoot::unregisterObject( RTI::RTIambassador *rti ) {\r\n    \r\n    while( _isRegistered ) {\r\n        try {\r\n            rti->deleteObjectInstance( getObjectHandle(), 0 );\r\n            _isRegistered = false;\r\n        } catch ( RTI::ObjectNotKnown & ) {\r\n        \tstd::cerr << \"ERROR:  InteractionRoot::unregisterObject:  Object Not Known\" << std::endl;\r\n            return;\r\n        } catch ( RTI::DeletePrivilegeNotHeld & ) {\r\n        \tstd::cerr << \"ERROR:  InteractionRoot::unregisterObject:  Delete Privilege Not Held\" << std::endl;\r\n            return;\r\n        } catch ( RTI::FederateNotExecutionMember & ) {\r\n        \tstd::cerr << \"ERROR:  InteractionRoot::unregisterObject:  Federate Not Execution Member\" << std::endl;\r\n            return;\r\n        } catch ( ... ) {\r\n        \tstd::cerr << \"InteractionRoot::unregisterObject:  Exception caught ... retry\" << std::endl;\r\n        }\r\n    }\r\n}\r\n\r\nvoid ObjectRoot::updateAttributeValues( RTI::RTIambassador *rti, double time, bool force ) {\r\n\r\n    AttributeHandleValuePairSetSP suppliedAttributesSP = createDatamemberHandleValuePairSet( force );\r\n    if ( suppliedAttributesSP->size() == 0 ) {\r\n    \treturn;\r\n    }\r\n\r\n    try {\r\n        rti->updateAttributeValues(  getObjectHandle(), *suppliedAttributesSP, RTIfedTime( time ), 0  );\r\n        createLog( time, true );\r\n    } catch ( RTI::ObjectNotKnown & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Object Not Known\" << std::endl;\r\n        return;\r\n    } catch ( RTI::FederateNotExecutionMember & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Federate Not Execution Member\" << std::endl;\r\n        return;\r\n    } catch ( RTI::AttributeNotDefined & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Attribute Not Defined\" << std::endl;\r\n        return;\r\n    } catch ( RTI::AttributeNotOwned & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Attribute Not Owned\" << std::endl;\r\n        return;\r\n    } catch ( RTI::ConcurrentAccessAttempted & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Concurrent Access Attempted\" << std::endl;\r\n        return;\r\n    } catch ( RTI::InvalidFederationTime & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Invalid Federation Time\" << std::endl;\r\n        return;\r\n    } catch ( ... ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  exception caught\" << std::endl;\r\n    }\r\n}\r\n\r\nvoid ObjectRoot::updateAttributeValues( RTI::RTIambassador *rti, bool force ) {\r\n\r\n    AttributeHandleValuePairSetSP suppliedAttributesSP = createDatamemberHandleValuePairSet( force );\r\n    if ( suppliedAttributesSP->size() == 0 ) {\r\n    \treturn;\r\n    }\r\n\r\n    try {\r\n        rti->updateAttributeValues( getObjectHandle(), *suppliedAttributesSP, 0 );\r\n        createLog( 0, true );\r\n    } catch ( RTI::ObjectNotKnown & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Object Not Known\" << std::endl;\r\n        return;\r\n    } catch ( RTI::FederateNotExecutionMember & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Federate Not Execution Member\" << std::endl;\r\n        return;\r\n    } catch ( RTI::AttributeNotDefined & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Attribute Not Defined\" << std::endl;\r\n        return;\r\n    } catch ( RTI::AttributeNotOwned & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Attribute Not Owned\" << std::endl;\r\n        return;\r\n    } catch ( RTI::ConcurrentAccessAttempted & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Concurrent Access Attempted\" << std::endl;\r\n        return;\r\n    } catch ( RTI::InvalidFederationTime & ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  Invalid Federation Time\" << std::endl;\r\n        return;\r\n    } catch ( ... ) {\r\n        std::cerr << \"ERROR:  \" << getClassName() << \":  could not update attributes:  exception caught\" << std::endl;\r\n    }\r\n}\r\n\r\nstd::string ObjectRoot::fedName = \"\";\r\n\r\nvoid ObjectRoot::enablePublishLog(const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel) {\r\n\r\n\tif ( globallevel.empty() ) {\r\n\t\treturn;\r\n\t}\r\n\tif (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {\r\n\t\treturn;\r\n\t}\r\n\tfedName = fed;\r\n\tgetPubAttributeLogMap().insert(  make_pair( attribute, thislevel )  );\r\n\t_logger->addLog( object, attribute, fed, true );\r\n}\r\n\r\nvoid ObjectRoot::enableSubscribeLog( const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel ) {\r\n\tif ( globallevel.empty() ) {\r\n\t\treturn;\r\n\t}\r\n\tif (  _logger->getLogLevel( thislevel ) > _logger->getLogLevel( globallevel )  ) {\r\n\t\treturn;\r\n\t}\r\n\tfedName = fed;\r\n\tgetSubAttributeLogMap().insert(  make_pair( attribute, thislevel )  );\r\n\t_logger->addLog( object, attribute, fed, false );\r\n}\r\n\r\nvoid ObjectRoot::createLog( double time, bool isPub ) {\r\n\r\n\tif ( getPubAttributeLogMap().empty() ) {\r\n\t\treturn;\r\n\t}\r\n\tstd::string id = isPub ? fedName + \"_pub_\" + getClassName() : getClassName() + \"_sub_\" + fedName;\r\n\t_logger->addLog( id, *this, time );\r\n}\r\n\r\n<%}%>\r\n",
    "classroot.hpp.ejs": "\r\n<% /* THIS IS THE ROOT CLASS OF EITHER THE INTERACTION OR OBJECT-CLASS HEIRARCHY (I.E. \"InteractionRoot\" OR \"ObjectRoot\") */\r\n/*classroot(isinteraction) ::= <<*/ %>\r\n/*\r\n * Copyright (c) 2008, Institute for Software Integrated Systems, Vanderbilt University\r\n * All rights reserved.\r\n *\r\n * Permission to use, copy, modify, and distribute this software and its\r\n * documentation for any purpose, without fee, and without written agreement is\r\n * hereby granted, provided that the above copyright notice, the following\r\n * two paragraphs and the author appear in all copies of this software.\r\n *\r\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\r\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\r\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\r\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\r\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\r\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\r\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\r\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\r\n *\r\n * @author Himanshu Neema\r\n * @author Harmon Nine\r\n */\r\n\r\n// This code has been generated by the C2W code generator.\r\n// Do not edit manually!\r\n\r\n/*\r\n * \tNOTE:  ALL \"if\" STATEMENTS IN THIS CODE THAT HAD THE FORM:\r\n *\r\n *  if (condition) statement;\r\n *\r\n *\tOR\r\n *\r\n *  if (condition) statement1;\r\n *  else           statement2;\r\n *\r\n *  HAVE BEEN CONVERTED TO THE FORMS:\r\n *\r\n *  if (condition) {\r\n *\t\tstatement;\r\n *\t}\r\n *\r\n *\tAND\r\n *\r\n *  if (condition) {\r\n *\t\tstatement1;\r\n *\t} else {\r\n *\t\tstatement2;\r\n *\t}\r\n *\r\n *\tRESPECTIVELY.  THIS IS BECAUSE THE OMNET DEBUGGER APPEARS TO HAVE A PROBLEM\r\n *  WITH THE NON-BRACED FORMS OF THE IF STATEMENT.  *PLEASE* DO NOT CHANGE IT BACK.\r\n *  -- H.S.N.\r\n *\r\n */\r\n\r\n<% if(isinteraction){ %>\r\n#ifndef _INTERACTION_ROOT\r\n#define _INTERACTION_ROOT\r\n<% }else{ %>\r\n#ifndef _OBJECT_ROOT\r\n#define _OBJECT_ROOT\r\n<%}%>\r\n\r\n#ifndef _CRT_SECURE_NO_DEPRECATE\r\n#define _CRT_SECURE_NO_DEPRECATE\r\n#endif\r\n\r\n#ifndef RTI_USES_STD_FSTREAM\r\n#define RTI_USES_STD_FSTREAM\r\n#endif\r\n\r\n#include <string>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <sstream>\r\n#include <iostream>\r\n#include <set>\r\n#include <map>\r\n#include <list>\r\n#include <ctype.h>\r\n#include <stdlib.h>\r\n\r\n#include <boost/shared_ptr.hpp>\r\n\r\n#include <TypeMedley.hpp>\r\n#include <StringCollections.hpp>\r\n\r\n#include \"RTI.hh\"\r\n#include \"fedtime.hh\"\r\n\r\n#ifdef _WIN32\r\n#include <windows.h>\r\n#else\r\n#include <unistd.h>\r\n#endif\r\n\r\n#include \"RTILogger.hpp\"\r\n\r\n#ifndef C2W_RTI_LOGGER_CLS\r\n#define C2W_RTI_LOGGER_CLS C2WConsoleLogger\r\n#endif \r\n\r\n#include \"<%=isinteraction?\"Interaction\":\"Object\"%>If.hpp\"\r\n\r\nclass <%=isinteraction?\"Interaction\":\"Object\"%>Root : public <%=isinteraction?\"Interaction\":\"Object\"%>If{\r\npublic:\r\n\ttypedef std::map< std::string, StringSet * > NameStringSetPtrMap;\r\n\ttypedef std::map< std::string, StringVector * > NameStringVectorPtrMap;\r\n\ttypedef std::map< std::string, int > StringIntegerMap;\r\n\ttypedef std::map< int, std::string > IntegerStringMap;\r\n\r\n\ttypedef boost::shared_ptr< <%=isinteraction?\"Interaction\":\"Object\"%>Root > SP;\r\n\ttypedef boost::shared_ptr< RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet > <%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP;\r\n\t\r\n\ttypedef SP (*FactoryFunctionPtr)( void );\r\n\ttypedef std::map< std::string, FactoryFunctionPtr > ClassNameFactoryMap;\r\n\r\n\ttypedef void (*PubsubFunctionPtr)( RTI::RTIambassador * );\r\n\ttypedef std::map< std::string, PubsubFunctionPtr > ClassNamePubSubMap;\r\n\ttypedef std::map< std::string, std::string> DatamemberTypeMap;\r\n\t\r\n\t\r\n<% if(!isinteraction){ %>\r\n\ttypedef std::map< std::string, RTI::AttributeHandleSet * > ClassNameAttributesPtrMap;\r\n\ttypedef std::map< int, SP > ObjectMap;\r\n<%}%>\r\n\r\n\tstatic DatamemberTypeMap &getDatamemberTypeMap( void ) {\r\n\t\tstatic DatamemberTypeMap datamemberTypeMap;\r\n\t\treturn datamemberTypeMap;\r\n\t}\r\n\r\nprotected:\r\n\tstatic StringSet &getClassNameSet( void ) {\r\n\t\tstatic StringSet classNameSet;\r\n\t\treturn classNameSet;\r\n\t}\r\n\r\n\tstatic ClassNameFactoryMap &getClassNameFactoryMap( void ) {\r\n\t\tstatic ClassNameFactoryMap classNameFactoryMap;\r\n\t\treturn classNameFactoryMap;\r\n\t}\r\n\t\r\n\tstatic ClassNamePubSubMap &getClassNamePublishMap( void ) {\r\n\t\tstatic ClassNamePubSubMap classNamePublishMap;\r\n\t\treturn classNamePublishMap;\r\n\t}\r\n\r\n\tstatic ClassNamePubSubMap &getClassNameUnpublishMap( void ) {\r\n\t\tstatic ClassNamePubSubMap classNameUnpublishMap;\r\n\t\treturn classNameUnpublishMap;\r\n\t}\r\n\r\n\tstatic ClassNamePubSubMap &getClassNameSubscribeMap( void ) {\r\n\t\tstatic ClassNamePubSubMap classNameSubscribeMap;\r\n\t\treturn classNameSubscribeMap;\r\n\t}\r\n\r\n\tstatic ClassNamePubSubMap &getClassNameUnsubscribeMap( void ) {\r\n\t\tstatic ClassNamePubSubMap classNameUnsubscribeMap;\r\n\t\treturn classNameUnsubscribeMap;\r\n\t}\r\n\r\n\tstatic NameStringVectorPtrMap &getDatamemberClassNameVectorPtrMap( void ) {\r\n\t\tstatic NameStringVectorPtrMap datamemberClassNameVectorPtrMap;\r\n\t\treturn datamemberClassNameVectorPtrMap;\r\n\t}\r\n\r\n\tstatic NameStringVectorPtrMap &getAllDatamemberClassNameVectorPtrMap( void ) {\r\n\t\tstatic NameStringVectorPtrMap allDatamemberClassNameVectorPtrMap;\r\n\t\treturn allDatamemberClassNameVectorPtrMap;\r\n\t}\r\n\r\n\tstatic StringIntegerMap &getClassNameHandleMap( void ) {\r\n\t\tstatic StringIntegerMap classNameHandleMap;\r\n\t\treturn classNameHandleMap;\r\n\t}\r\n\tstatic IntegerStringMap &getClassHandleNameMap( void ) {\r\n\t\tstatic IntegerStringMap classHandleNameMap;\r\n\t\treturn classHandleNameMap;\r\n\t}\r\n\r\n\tstatic StringIntegerMap &getDatamemberNameHandleMap( void ) {\r\n\t\tstatic StringIntegerMap datamemberNameHandleMap;\r\n\t\treturn datamemberNameHandleMap;\r\n\t}\r\n\tstatic IntegerStringMap &getDatamemberHandleNameMap( void ) {\r\n\t\tstatic IntegerStringMap datamemberHandleNameMap;\r\n\t\treturn datamemberHandleNameMap;\r\n\t}\r\n\r\n<% if(!isinteraction){ %>\r\n\tstatic NameStringVectorPtrMap &getClassNamePublishAttributeNameVectorPtrMap( void ) {\r\n\t\tstatic NameStringVectorPtrMap classNamePublishAttributeNameVectorPtrMap;\r\n\t\treturn classNamePublishAttributeNameVectorPtrMap;\r\n\t}\r\n\tstatic NameStringVectorPtrMap &getClassNameSubscribeAttributeNameVectorPtrMap( void ) {\r\n\t\tstatic NameStringVectorPtrMap classNameSubscribeAttributeNameVectorPtrMap;\r\n\t\treturn classNameSubscribeAttributeNameVectorPtrMap;\r\n\t}\r\n\t\r\n\tstatic ClassNameAttributesPtrMap &getClassNamePublishedAttributesPtrMap( void ) {\r\n\t\tstatic ClassNameAttributesPtrMap classNamePublishedAttributesPtrMap;\r\n\t\treturn classNamePublishedAttributesPtrMap;\r\n\t}\r\n\tstatic ClassNameAttributesPtrMap &getClassNameSubscribedAttributesPtrMap( void ) {\r\n\t\tstatic ClassNameAttributesPtrMap classNameSubscribedAttributesPtrMap;\r\n\t\treturn classNameSubscribedAttributesPtrMap;\r\n\t}\r\n\r\n\tstatic ObjectMap &getObjectMap( void ) {\r\n\t\tstatic ObjectMap objectMap;\r\n\t\treturn objectMap;\r\n\t}\r\n\r\n\ttemplate< typename S, typename T >\r\n\tclass Attribute {\r\n\tprivate:\r\n\t\tT _value;\r\n\t\tT _oldValue;\r\n\t\tbool _oldValueInit;\r\n\t\tdouble _time;\r\n\t\r\n\tpublic:\r\n\t\t\r\n\t\tAttribute( void ) : _value( 0 ), _oldValueInit( false ), _time( -1 ) { }\r\n\t\t\r\n\t\tT getValue( void ) const { return _value; }\r\n\t\tvoid setValue( T value ) { _value = value; }\r\n\t\t\r\n\t\tdouble getTime( void ) { return _time; }\r\n\t\tvoid setTime( double time ) { _time = time; }\r\n\t\t\r\n\t\tvoid setHasBeenUpdated( void ) {\r\n\t\t\t_oldValue = _value;\r\n\t\t\t_oldValueInit = true;\r\n\t\t}\r\n\t\t\r\n\t\tbool shouldBeUpdated( bool force ) { return force || !_oldValueInit || _oldValue != _value; }\r\n\t};\r\n\r\n\ttemplate< typename S >\r\n\tclass Attribute< S, std::string > {\r\n\tprivate:\r\n\t\tstd::string _value;\r\n\t\tstd::string _oldValue;\r\n\t\tbool _oldValueInit;\r\n\t\tdouble _time;\r\n\t\r\n\tpublic:\r\n\t\t\r\n\t\tAttribute( void ) : _oldValueInit( false ), _time( -1 ) { }\r\n\t\t\r\n\t\tconst std::string &getValue( void ) const { return _value; }\r\n\t\tvoid setValue( const std::string &value ) { _value = value; }\r\n\t\t\r\n\t\tdouble getTime( void ) { return _time; }\r\n\t\tvoid setTime( double time ) { _time = time; }\r\n\t\t\r\n\t\tvoid setHasBeenUpdated( void ) {\r\n\t\t\t_oldValue = _value;\r\n\t\t\t_oldValueInit = true;\r\n\t\t}\r\n\t\t\r\n\t\tbool shouldBeUpdated( bool force ) { return force || !_oldValueInit || _oldValue != _value; }\r\n\t};\r\n\t\r\n<%}%>\r\n\t\r\n<% /*classcommon(classname=apMap.classfirstupper+\"Root\",hlaclassname=apMap.classfirstupper+\"Root\",...)*/ -%>\r\n<%- ejs.render(\r\n\tTEMPLATES[\"classcommon.hpp.ejs\"],{\r\n\t\tisinteraction: isinteraction,\r\n\t\tclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\r\n\t\tparentclassname: \"\",\r\n\t\thlaclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\r\n\t\tdatamembers: [],\r\n\t\talldatamembers: []\r\n}) %>\r\npublic:\r\n\tstatic StringSet get_<%=isinteraction?\"interaction\":\"object\"%>_names( void ) { return getClassNameSet(); }\r\n\tstatic StringVector get_<%=isinteraction?\"parameter\":\"attribute\"%>_names( const std::string &className ) {\r\n\t\tNameStringVectorPtrMap::iterator nssItr = getDatamemberClassNameVectorPtrMap().find( className );\r\n\t\treturn nssItr == getDatamemberClassNameVectorPtrMap().end() ? StringVector() : *nssItr->second;\r\n\t}\r\n\t\r\n\tstatic StringVector get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names( const std::string &className ) {\r\n\t\tNameStringVectorPtrMap::iterator nssItr = getAllDatamemberClassNameVectorPtrMap().find( className );\r\n\t\treturn nssItr == getAllDatamemberClassNameVectorPtrMap().end() ? StringVector() : *nssItr->second;\r\n\t}\r\n\t\r\n\tstatic std::string get_class_name( int classHandle ) {\r\n\t\tIntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\r\n\t\treturn ismItr == getClassHandleNameMap().end() ? std::string() : ismItr->second;\r\n\t}\r\n\t\r\n\tstatic int get_handle( const std::string &className ) {\r\n\t\r\n\t\tStringIntegerMap::iterator simItr = getClassNameHandleMap().find( className );\r\n\t\tif ( simItr == getClassNameHandleMap().end() ) {\r\n\t\t\tstd::cerr << \"Bad class name \\\"\" << className << \"\\\" on get_handle.\" << std::endl;\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\t\r\n\t\treturn simItr->second;\r\n\t}\r\n\t\r\n\tstatic std::string get_<%=isinteraction?\"parameter\":\"attribute\"%>_name( int datamemberHandle ) {\r\n\t\tIntegerStringMap::iterator ismItr = getDatamemberHandleNameMap().find( datamemberHandle );\r\n\t\treturn ismItr == getDatamemberHandleNameMap().end() ? std::string() : ismItr->second;\r\n\t}\r\n\t\r\n\tstatic int get_<%=isinteraction?\"parameter\":\"attribute\"%>_handle( const std::string &className, const std::string &datamemberName ) {\r\n\t\r\n\t\tStringIntegerMap::iterator simItr = getDatamemberNameHandleMap().find( className + \",\" + datamemberName );\r\n\t\tif ( simItr == getDatamemberNameHandleMap().end() ) {\r\n\t\t\tstd::cerr << \"Bad <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" << datamemberName << \"\\\" for class \\\"\" << className << \"\\\" on get_<%=isinteraction?\"parameter\":\"attribute\"%>_handle.\" << std::endl;\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\t\r\n\t\treturn simItr->second;\r\n\t}\r\n\t\r\n\tstatic void publish( const std::string &className, RTI::RTIambassador *rti ) {\r\n\t\tClassNamePubSubMap::iterator cpmItr = getClassNamePublishMap().find( className );\r\n\t\tif ( cpmItr == getClassNamePublishMap().end() ) {\r\n\t\t\tstd::cerr << \"Bad class name \\\"\" << className << \"\\\" on publish.\" << std::endl;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t(*cpmItr->second)( rti );\r\n\t}\r\n\t\r\n\tstatic void unpublish( const std::string &className, RTI::RTIambassador *rti ) {\r\n\t\tClassNamePubSubMap::iterator cpmItr = getClassNameUnpublishMap().find( className );\r\n\t\tif ( cpmItr == getClassNameUnpublishMap().end() ) {\r\n\t\t\tstd::cerr << \"Bad class name \\\"\" << className << \"\\\" on unpublish.\" << std::endl;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t(*cpmItr->second)( rti );\r\n\t}\r\n\t\r\n\tstatic void subscribe( const std::string &className, RTI::RTIambassador *rti ) {\r\n\t\tClassNamePubSubMap::iterator cpmItr = getClassNameSubscribeMap().find( className );\r\n\t\tif ( cpmItr == getClassNameSubscribeMap().end() ) {\r\n\t\t\tstd::cerr << \"Bad class name \\\"\" << className << \"\\\" on subscribe.\" << std::endl;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t(*cpmItr->second)( rti );\r\n\t}\r\n\t\r\n\tstatic void unsubscribe( const std::string &className, RTI::RTIambassador *rti ) {\r\n\t\tClassNamePubSubMap::iterator cpmItr = getClassNameUnsubscribeMap().find( className );\r\n\t\tif ( cpmItr == getClassNameSubscribeMap().end() ) {\r\n\t\t\tstd::cerr << \"Bad class name \\\"\" << className << \"\\\" on unsubscribe.\" << std::endl;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t\r\n\t\t(*cpmItr->second)( rti );\r\n\t}\r\n\r\n<% if(!isinteraction){ %>\r\n\tstatic void publish( const std::string &className, const std::string &attributeName );\r\n\t\r\n\tstatic void unpublish( const std::string &className, const std::string &attributeName ) {\r\n\t\tNameStringVectorPtrMap::iterator camItr = getClassNamePublishAttributeNameVectorPtrMap().find( className );\r\n\t\tif ( camItr == getClassNamePublishAttributeNameVectorPtrMap().end() ) {\r\n\t\t\tstd::cerr << \"ERROR:  ObjectRoot.unpublish:  could not unpublish class \\\"\" << className << \"\\\" \\\"\" << attributeName << \"\\\" attribute.\" << std::endl;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tcamItr->second->erase( std::remove( camItr->second->begin(), camItr->second->end(), attributeName ), camItr->second->end() );\r\n\t}\r\n\tstatic void subscribe( const std::string &className, const std::string &attributeName );\r\n\t\r\n\tstatic void unsubscribe( const std::string &className, const std::string &attributeName ) {\r\n\t\tNameStringVectorPtrMap::iterator camItr = getClassNameSubscribeAttributeNameVectorPtrMap().find( className );\r\n\t\tif ( camItr == getClassNameSubscribeAttributeNameVectorPtrMap().end() ) {\r\n\t\t\tstd::cerr << \"ERROR:  ObjectRoot.unsubscribe:  could not unsubscribe class \\\"\" << className << \"\\\" \\\"\" << attributeName << \"\\\" attribute.\" << std::endl;\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tcamItr->second->erase( std::remove( camItr->second->begin(), camItr->second->end(), attributeName ), camItr->second->end() );\r\n\t}\r\n<%}%>\r\n\t\r\npublic:\r\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( const std::string &className ) {\r\n\t\tClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( className );\r\n\t\treturn cfmItr == getClassNameFactoryMap().end() ? SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 ) : (*cfmItr->second)();\r\n\t}\r\n\r\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( const std::string &className, const RTIfedTime &dlc13FedTime ) {\r\n\t\tClassNameFactoryMap::iterator cfmItr = getClassNameFactoryMap().find( className );\r\n\t\tif ( cfmItr == getClassNameFactoryMap().end() ) {\r\n\t\t\treturn SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 );\r\n\t\t}\r\n\t\t\r\n\t\tSP sp = (*cfmItr->second)();\r\n\t\tsp->setTime( dlc13FedTime.getTime() );\r\n\t\treturn sp;\r\n\t}\r\n\r\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle ) {\r\n\t\tIntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\r\n\t\treturn ismItr == getClassHandleNameMap().end() ? SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 ) : create_<%=isinteraction?\"interaction\":\"object\"%>( ismItr->second );\r\n\t}\r\n\r\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, const RTIfedTime &dlc13FedTime ) {\r\n\t\tIntegerStringMap::iterator ismItr = getClassHandleNameMap().find( classHandle );\r\n\t\treturn ismItr == getClassHandleNameMap().end() ? SP( (<%=isinteraction?\"Interaction\":\"Object\"%>Root *)0 ) : create_<%=isinteraction?\"interaction\":\"object\"%>( ismItr->second, dlc13FedTime );\r\n\t}\r\n\r\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap );\r\n\tstatic SP create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime );\r\n\r\n\tstatic StringVector get_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\r\n\t\treturn StringVector();\r\n\t}\r\n\r\n\tstatic StringVector get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names() {\r\n\t\treturn StringVector();\r\n\t}\r\n\r\n<% if(!isinteraction){ %>\r\n    static SP discover( int class_handle, int object_handle ) {\r\n    \r\n    \tSP sp = create_object( class_handle );\r\n    \tif ( sp != 0 ) {\r\n    \t\tgetObjectMap().insert(  std::make_pair( object_handle, sp )  );\r\n    \t}\r\n    \treturn sp;\r\n    }\r\n    \r\n    static SP reflect( int object_handle, const RTI::AttributeHandleValuePairSet &datamemberMap ) {\r\n    \tObjectMap::iterator obmItr = getObjectMap().find( object_handle );\r\n    \tif ( obmItr == getObjectMap().end() ) {\r\n    \t\treturn SP( (ObjectRoot *)0 );\r\n    \t}\r\n    \t\r\n    \tSP sp = obmItr->second;\r\n    \tsp->setTime( -1 );\r\n\t\tsp->setAttributes( datamemberMap );\r\n    \treturn sp;\r\n    }\r\n\r\n    static SP reflect(\r\n     int object_handle,\r\n     const RTI::AttributeHandleValuePairSet &datamemberMap,\r\n     double theTime\r\n    ) {\r\n    \tObjectMap::iterator obmItr = getObjectMap().find( object_handle );\r\n    \tif ( obmItr == getObjectMap().end() ) {\r\n    \t\treturn SP( (ObjectRoot *)0 );\r\n    \t}\r\n    \t\r\n    \tSP sp = obmItr->second;\r\n    \tsp->setTime( theTime );\r\n\t\tsp->setAttributes( datamemberMap );\r\n    \treturn sp;\r\n    }\r\n\r\n\tvoid requestUpdate( RTI::RTIambassador *rti );\r\n\r\n\tstatic SP getObject( int object_handle ) {\r\n\t\tObjectMap::iterator obmItr = getObjectMap().find( object_handle );\r\n\t\treturn obmItr == getObjectMap().end() ? SP( (ObjectRoot *)0 ) : obmItr->second;\r\n\t}\r\n\t\t    \r\n    static SP removeObject( int object_handle ) {\r\n\t\tObjectMap::iterator obmItr = getObjectMap().find( object_handle );\r\n\t\tif ( obmItr == getObjectMap().end() ) {\r\n\t\t\treturn SP( (ObjectRoot *)0 );\r\n\t\t}\r\n\t\t\r\n\t\tSP sp = obmItr->second;\r\n        getObjectMap().erase( obmItr );\r\n        return sp;\r\n    }\r\n    \r\n\r\nprivate:\r\n    int _object_handle;\r\n\r\n    void setObjectHandle( int object_handle ) {\r\n        getObjectMap().erase( object_handle );\r\n        _object_handle = object_handle;\r\n        getObjectMap().insert(  std::make_pair( object_handle, this )  );\r\n    }\r\n\r\npublic:\r\n    int getObjectHandle( void ) const { return _object_handle; }\r\n\t\r\n<%}%>\r\n\r\nprivate:\r\n\tdouble _time;\r\n\tstatic C2WLogger* _logger;\r\n\r\npublic:\t\r\n\tdouble getTime( void ) { return _time; }\r\n\t\r\n\tvoid setTime( double time ) { _time = time; }\r\n\tvoid setTime( const RTIfedTime &dlc13FedTime ) {\r\n\t\tsetTime( dlc13FedTime.getTime() );\r\n\t}\r\n\r\n\t<%=isinteraction?\"Interaction\":\"Object\"%>Root( void ) : _time( -1 )<% if(!isinteraction){%>, _isRegistered( false )<%}%> { }\r\n\t\r\n\t<%=isinteraction?\"Interaction\":\"Object\"%>Root( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) : _time( -1 )<% if(!isinteraction){%>, _isRegistered( false )<%}%> {\r\n\t\tset<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\r\n\t}\r\n\r\n\r\n\t<%=isinteraction?\"Interaction\":\"Object\"%>Root( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime ) : _time( dlc13FedTime.getTime() )<% if(!isinteraction){%>, _isRegistered( false )<%}%> {\r\n\t\tset<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\r\n\t}\r\n\r\n\tstatic SP create( void ) { return SP( new <%=isinteraction?\"Interaction\":\"Object\"%>Root ); }\r\n\tstatic SP create( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap ) { return SP(  new <%=isinteraction?\"Interaction\":\"Object\"%>Root( datamemberMap )  ); }\r\n\tstatic SP create( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap, const RTIfedTime &dlc13FedTime ) {\r\n\t\treturn SP(  new <%=isinteraction?\"Interaction\":\"Object\"%>Root( datamemberMap, dlc13FedTime )  );\r\n\t}\r\n\t\r\n\r\n\tvirtual TypeMedley get<%=isinteraction?\"Parameter\":\"Attribute\"%>( const std::string &datamemberName ) const {\r\n\t\tthrow std::invalid_argument( getClassName() + \" class has no <%=isinteraction?\"parameter\":\"attribute\"%> named \\\"\" + datamemberName + \"\\\"\" );\r\n\t}\r\n\t\t\r\n\tvirtual TypeMedley get<%=isinteraction?\"Parameter\":\"Attribute\"%>( int datamemberHandle ) const {\r\n\t\tthrow std::invalid_argument(\r\n\t\t getClassName() + \" class has no <%=isinteraction?\"parameter\":\"attribute\"%> with handle (\" + boost::lexical_cast< std::string >( datamemberHandle ) + \")\"\r\n\t\t);\r\n\t}\r\n\t\t\r\n\tvoid set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( const RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSet &datamemberMap );\r\n\r\nprivate:\r\n\tvoid set<%=isinteraction?\"Parameter\":\"Attribute\"%>( RTI::Handle handle, const std::string &val ) {\r\n\t\tif (  !set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( handle, val )  ) {\r\n\t\t\tstd::cerr << \"set:  bad <%=isinteraction?\"parameter\":\"attribute\"%> handle in class \\\"\" + getClassName() + \"\\\"\" << std::endl;\r\n\t\t}\r\n\t}\r\n\r\npublic:\r\n\tvoid set<%=isinteraction?\"Parameter\":\"Attribute\"%>( const std::string &datamemberName, TypeMedley value ) {\r\n\t\tif (  !set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, value )  ) {\r\n\t\t\tstd::cerr << \"Error:  class \\\"\" << getClassName() << \"\\\":  invalid <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" + datamemberName + \"\\\"\" << std::endl;\r\n\t\t}\r\n\t}\r\n\r\nprotected:\r\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( int param_handle, const std::string &val ) {\r\n\t\treturn false;\r\n\t}\r\n\t\r\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( const std::string &datamemberName, const std::string &value ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvirtual bool set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( const std::string &datamemberName, TypeMedley value ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tvirtual <%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP createDatamemberHandleValuePairSet( RTI::ULong count<% if(!isinteraction){%>, bool force<%}%> ) {\r\n\t\treturn <%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP(  RTI::<%=isinteraction?\"Parameter\":\"Attribute\"%>SetFactory::create( count )  );\r\n\t}\r\n\t\r\n\tvirtual <%=isinteraction?\"Parameter\":\"Attribute\"%>HandleValuePairSetSP createDatamemberHandleValuePairSet( <% if(!isinteraction){%>bool force<%}%> ) {\r\n\t\treturn createDatamemberHandleValuePairSet( <% if(!isinteraction){%>force<%}%> );\r\n\t}\r\n\t\r\n<% if(isinteraction){ %>\r\npublic:\r\n\tvoid sendInteraction( RTI::RTIambassador *rti, double time );\r\n\tvoid sendInteraction( RTI::RTIambassador *rti );\r\n\r\nprivate:\r\n\tstatic std::string fedName;\r\n\t\r\npublic:\r\n\tstatic bool enablePubLog;\r\n\tstatic bool enableSubLog;\r\n\tstatic std::string pubLogLevel;\r\n\tstatic std::string subLogLevel;\t\r\n\r\npublic:\r\n\tstatic void enablePublishLog(const std::string &interaction, const std::string &fed, const std::string &thislevel, const std::string &globallevel);\r\n\tstatic void enableSubscribeLog(const std::string &interaction, const std::string &fed, const std::string &thislevel, const std::string &globallevel);\r\n\r\n\tvoid createLog( double time, bool isPub = true );\r\n\t\r\n<% }else{ %>\r\nprivate:\r\n    bool _isRegistered;\r\n\r\npublic:\r\n    void registerObject( RTI::RTIambassador *rti );\r\n\tvoid unregisterObject( RTI::RTIambassador *rti );\r\n\r\n    void updateAttributeValues( RTI::RTIambassador *rti, double time, bool force );\r\n\r\n    void updateAttributeValues( RTI::RTIambassador *rti, double time ) {\r\n    \tupdateAttributeValues( rti, time, false );\r\n    }\r\n\r\n    void updateAttributeValues( RTI::RTIambassador *rti, bool force );\r\n\r\n\tvoid updateAttributeValues( RTI::RTIambassador *rti ) {\r\n\t\tupdateAttributeValues( rti, false );\r\n\t}\r\n\r\nprivate:\r\n\tstatic std::string fedName;\r\n\t\r\npublic:\r\n\tstatic void enablePublishLog(const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel);\r\n\tstatic void enableSubscribeLog(const std::string &object, const std::string &attribute, const std::string &fed, const std::string &thislevel, const std::string &globallevel);\r\n\r\n\tstatic std::map<std::string, std::string> &getPubAttributeLogMap( void) {\r\n\t\tstatic std::map<std::string, std::string> pubAttributeLogMap;\r\n\t\treturn pubAttributeLogMap;\r\n\t}\r\n\r\n\tstatic std::map<std::string, std::string> &getSubAttributeLogMap( void) {\r\n\t\tstatic std::map<std::string, std::string> subAttributeLogMap;\r\n\t\treturn subAttributeLogMap;\r\n\t}\r\n\r\n\tvoid createLog( double time, bool isPub = true );\r\n\t\r\n<%}%>\r\n\r\n};\r\n\r\ntypedef <%=isinteraction?\"Interaction\":\"Object\"%>Root::SP <%=isinteraction?\"Interaction\":\"Object\"%>RootSP;\r\n\r\nstatic bool call_<%=isinteraction?\"Interaction\":\"Object\"%>Root_static_init = <%=isinteraction?\"Interaction\":\"Object\"%>Root::static_init();\r\n\r\nstd::ostream &operator<<( std::ostream &os, <%=isinteraction?\"Interaction\":\"Object\"%>Root::SP entitySP );\r\nstd::ostream &operator<<( std::ostream &os, const <%=isinteraction?\"Interaction\":\"Object\"%>Root &entity );\r\n#endif\r\n",
    "classroot.java.ejs": "<%/* THIS IS THE ROOT CLASS OF EITHER THE INTERACTION OR OBJECT-CLASS HEIRARCHY (I.E. \"InteractionRoot\" OR \"ObjectRoot\") */%>\r\n<%/*classroot(isinteraction)*/%>\r\n// This code has been generated by the C2W code generator.\r\n// Do not edit manually!\r\n\r\n/*\r\n * Copyright (c) 2016, Institute for Software Integrated Systems, Vanderbilt University\r\n * All rights reserved.\r\n *\r\n * Permission to use, copy, modify, and distribute this software and its\r\n * documentation for any purpose, without fee, and without written agreement is\r\n * hereby granted, provided that the above copyright notice, the following\r\n * two paragraphs and the author appear in all copies of this software.\r\n *\r\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\r\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\r\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\r\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\r\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\r\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\r\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\r\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\r\n *\r\n * @author Himanshu Neema\r\n * @author Harmon Nine\r\n */\r\n\r\npackage c2w.hla;\r\n\r\nimport hla.rti.*;\r\nimport hla.rti.jlc.RtiFactory;\r\nimport hla.rti.jlc.RtiFactoryFactory;\r\n\r\nimport java.lang.reflect.Method;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\n<% if(isinteraction){%>import java.util.concurrent.LinkedBlockingQueue;<%}%>\r\n\r\nimport org.portico.impl.hla13.types.DoubleTime;\r\n\r\n/**\r\n * <%=isinteraction?\"Interaction\":\"Object\"%>Root is the base class for all <%=isinteraction?\"interaction\":\"object\"%>s\r\n * defined in a given federation.  As such, an <%=isinteraction?\"Interaction\":\"Object\"%>Root\r\n * variable may refer to any type of interaction defined in the\r\n * federation.\r\n * <p/>\r\n * This <%=isinteraction?\"Interaction\":\"Object\"%>Root class provides the following:\r\n * - methods for constructing any <%=isinteraction?\"interaction\":\"object\"%> in the federation, either from\r\n * data provided by the RTI (for example, see\r\n * {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle )} or from a string argument\r\n * specifying the name of <%=isinteraction?\"interaction\":\"object\"%> to construct (see\r\n * {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( String className )}.\r\n * - methods for sending <% if(isinteraction){ %>an interaction<%}else{%>object updates<%}%> to the RTI (see\r\n * {@link <% if(isinteraction){ %>#sendInteraction( RTIambassador rti )<%}else{%>#updateAttributeValues( RTIambassador rti )<%}%>} for an example).\r\n * - methods for publishing/subscribing to any <% if(isinteraction){ %>interaction<%}else{%>object/object attribute<%}%> \r\n * defined in the federation (see\r\n * {@link #publish( String className, RTIambassador rti )} for example).\r\n * - methods for getting/setting any <%=isinteraction?\"parameter\":\"attribute\"%> in the <%=isinteraction?\"interaction\":\"object\"%> to\r\n * which a given <%=isinteraction?\"Interaction\":\"Object\"%>Root variable is referring\r\n * (see {@link #get<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName )} and\r\n * {@link #set<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName, Object value )}\r\n */\r\npublic class <%=isinteraction?\"Interaction\":\"Object\"%>Root implements <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface {\r\n\r\n\tprivate static int logId = 0;\r\n\tprivate static int _globalUniqueID = 0;\r\n\t\r\n\tprivate static int generateUniqueID() {\r\n\t\treturn _globalUniqueID++;\r\n\t}\r\n\t\r\n\tprivate int _uniqueID;\r\n\t\r\n\tpublic int getUniqueID() { return _uniqueID; }\r\n\t\r\n\tprotected static RtiFactory _factory;\r\n\tstatic {\r\n\t\tboolean factoryNotAcquired = true;\r\n\t\twhile( factoryNotAcquired ) {\r\n\t\t\ttry {\r\n\t\t\t\t_factory = RtiFactoryFactory.getRtiFactory( \"org.portico.dlc.HLA13RTIFactory\" );\r\n\t\t\t\tfactoryNotAcquired = false;\r\n\t\t\t} catch ( Exception e ) {\r\n\t\t\t\tSystem.err.println( \"ERROR: acquiring factory\" );\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t\ttry { Thread.sleep( 100 ); } catch ( Exception e1 ) { }\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprotected static Set< String > _classNameSet = new HashSet< String >();\r\n\tprotected static Map< String, Class<?> > _classNameClassMap = new HashMap< String, Class<?> >();\r\n\tprotected static Map<  String, Set< String >  > _datamemberClassNameSetMap = new HashMap<  String, Set< String >  >();\r\n\tprotected static Map<  String, Set< String >  > _allDatamemberClassNameSetMap = new HashMap<  String, Set< String >  >();\r\n\r\n\tprotected static Map< String, Integer > _classNameHandleMap = new HashMap< String, Integer >();\r\n\tprotected static Map< Integer, String > _classHandleNameMap = new HashMap< Integer, String >();\r\n\tprotected static Map< Integer, String > _classHandleSimpleNameMap = new HashMap< Integer, String >();\r\n\t\r\n\tprotected static Map< String, Integer > _datamemberNameHandleMap = new HashMap< String, Integer >();\r\n\tprotected static Map< Integer, String > _datamemberHandleNameMap = new HashMap< Integer, String >();\r\n\tprotected static Map< String, String > _datamemberTypeMap = new HashMap< String, String >();\r\n\r\n<% if(isinteraction){ %><%}else{%>\r\n\tprotected static Map<  String, Set< String >  > _classNamePublishAttributeNameMap = new HashMap<  String, Set< String >  >();\r\n\tprotected static Map<  String, Set< String >  > _classNameSubscribeAttributeNameMap = new HashMap<  String, Set< String >  >();\r\n\r\n\tprotected static Map< String, AttributeHandleSet > _classNamePublishedAttributeMap = new HashMap< String, AttributeHandleSet >();\r\n\tprotected static Map< String, AttributeHandleSet > _classNameSubscribedAttributeMap = new HashMap< String, AttributeHandleSet >();\r\n\t\r\n    private static Map< Integer, ObjectRoot > _objectMap = new HashMap< Integer, ObjectRoot >();\r\n\r\n\tprotected static class Attribute<T> {                                                                                 // NOMELD\r\n\t\tprivate T _value = null;                                                                                           // NOMELD\r\n\t\tprivate T _oldValue = null;                                                                                        // NOMELD\r\n\t\tprivate boolean _oldValueInit = false;                                                                             // NOMELD\r\n\t\tprivate double _time = 0;                                                                                          // NOMELD\r\n                                                                                                                           // NOMELD\r\n\t\tpublic Attribute( T init ) {                                                                                       // NOMELD\r\n\t\t\t_value = init;                                                                                                 // NOMELD\r\n\t\t}                                                                                                                  // NOMELD\r\n\t\t                                                                                                                   // NOMELD\r\n\t\tpublic T getValue() { return _value; }                                                                             // NOMELD\r\n\t\tpublic void setValue( T value ) {                                                                                  // NOMELD\r\n\t\t\tif ( value == null ) return;                                                                                   // NOMELD\r\n\t\t\t_value = value;                                                                                                // NOMELD\r\n\t\t}                                                                                                                  // NOMELD\r\n\t\t                                                                                                                   // NOMELD\r\n\t\tpublic double getTime() { return _time; }                                                                          // NOMELD\r\n\t\tpublic void setTime( double time ) { _time = time; }                                                               // NOMELD\r\n\t\t                                                                                                                   // NOMELD\r\n\t\tpublic void setHasBeenUpdated() {                                                                                  // NOMELD\r\n\t\t\t_oldValue = _value;                                                                                            // NOMELD\r\n\t\t\t_oldValueInit = true;                                                                                          // NOMELD\r\n\t\t}                                                                                                                  // NOMELD\r\n\t\t                                                                                                                   // NOMELD\r\n\t\tpublic boolean shouldBeUpdated( boolean force ) { return force || !_oldValueInit || !_oldValue.equals( _value ); } // NOMELD\t\t\r\n\t}                                                                                                                      // NOMELD\r\n<%}%>\t\r\n\t\r\n\t<% /*classcommon(classname=%=isinteraction?\"Interaction\":\"Object\"%+\"Root\",hlaclassname=%=isinteraction?\"Interaction\":\"Object\"%+\"Root\",...)*/ %>\r\n\t<%- ejs.render(TEMPLATES[\"classcommon.java.ejs\"],\r\n\t\t{\r\n\t\t\tisinteraction: isinteraction,\r\n\t\t\tclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\r\n\t\t\tparentclassname: \"\",\r\n\t\t\thlaclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\r\n\t\t\tdatamembers: [],\r\n\t\t\talldatamembers: []\r\n\t}) %>\r\n\t/**\r\n\t* Returns a set of strings containing the names of all of the <%=isinteraction?\"interaction\":\"object\"%>\r\n\t* classes in the current federation.\r\n\t*\r\n\t* @return Set< String > containing the names of all <%=isinteraction?\"interaction\":\"object\"%> classes\r\n\t* in the current federation\r\n\t*/\r\n\tpublic static Set< String > get_<%=isinteraction?\"interaction\":\"object\"%>_names() { return new HashSet< String >( _classNameSet ); }\r\n\r\n\t/**\r\n\t* Returns a set of strings containing the names of all of the non-hidden <%=isinteraction?\"parameter\":\"attribute\"%>s\r\n\t* in the <%=isinteraction?\"interaction\":\"object\"%> class specified by className.\r\n\t*\r\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class for which to retrieve the\r\n\t* names of all of its <%=isinteraction?\"parameter\":\"attribute\"%>s\r\n\t* @return Set< String > containing the names of all <%=isinteraction?\"parameter\":\"attribute\"%>s in the\r\n\t* className <%=isinteraction?\"interaction\":\"object\"%> class\r\n\t*/\r\n\tpublic static Set< String > get_<%=isinteraction?\"parameter\":\"attribute\"%>_names( String className ) {\r\n\t\treturn new HashSet< String >(  _datamemberClassNameSetMap.get( className )  );\r\n\t}\r\n\t\r\n\t/**\r\n\t* Returns a set of strings containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s\r\n\t* in the <%=isinteraction?\"interaction\":\"object\"%> class specified by className.\r\n\t*\r\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class for which to retrieve the\r\n\t* names of all of its <%=isinteraction?\"parameter\":\"attribute\"%>s\r\n\t* @return Set< String > containing the names of all <%=isinteraction?\"parameter\":\"attribute\"%>s in the\r\n\t* className <%=isinteraction?\"interaction\":\"object\"%> class\r\n\t*/\r\n\tpublic static Set< String > get_all_<%=isinteraction?\"parameter\":\"attribute\"%>_names( String className ) {\r\n\t\treturn new HashSet< String >(  _allDatamemberClassNameSetMap.get( className )  );\r\n\t}\r\n\t\r\n\t/**\r\n\t* Returns the fully-qualified name of the <%=isinteraction?\"interaction\":\"object\"%> class corresponding\r\n\t* to the RTI-defined classHandle.\r\n\t*\r\n\t* @param classHandle handle (defined by RTI) of <%=isinteraction?\"interaction\":\"object\"%> class for\r\n\t* which to retrieve the fully-qualified name\r\n\t* @return the fully-qualified name of the <%=isinteraction?\"interaction\":\"object\"%> class that\r\n\t* corresponds to the RTI-defined classHandle\r\n\t*/\r\n\tpublic static String get_class_name( int classHandle ) {\r\n\t\treturn _classHandleNameMap.get( classHandle );\r\n\t}\r\n\r\n\t/**\r\n\t* Returns the simple name of the <%=isinteraction?\"interaction\":\"object\"%> class corresponding to the\r\n\t* RTI-defined classHandle.  The simple name of an <%=isinteraction?\"interaction\":\"object\"%> class is\r\n\t* the last name in its (dot-delimited) fully-qualified name.\r\n\t*\r\n\t* @param classHandle handle (defined by RTI) of <%=isinteraction?\"interaction\":\"object\"%> class for which\r\n\t* to retrieve the simple name\r\n\t* @return the simple name of the <%=isinteraction?\"interaction\":\"object\"%> class that corresponds to\r\n\t* the RTI-defined classHandle\r\n\t*/\r\n\tpublic static String get_simple_class_name( int classHandle ) {\r\n\t\treturn _classHandleSimpleNameMap.get( classHandle );\r\n\t}\r\n\t\r\n\t/**\r\n\t* Returns the integer handle (RTI defined) of the <%=isinteraction?\"interaction\":\"object\"%> class\r\n\t* corresponding to the fully-qualified <%=isinteraction?\"interaction\":\"object\"%> class name in className.\r\n\t*\r\n\t* @param className fully-qualified name of <%=isinteraction?\"interaction\":\"object\"%> class for which to\r\n\t* retrieve the RTI-defined integer handle\r\n\t* @return the RTI-defined handle of the <%=isinteraction?\"interaction\":\"object\"%> class\r\n\t*/\r\n\tpublic static int get_handle( String className ) {\r\n\t\r\n\t\tInteger classHandle = _classNameHandleMap.get( className );\r\n\t\tif ( classHandle == null ) {\r\n\t\t\tSystem.err.println( \"Bad class name \\\"\" + className + \"\\\" on get_handle.\" );\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\t\r\n\t\treturn classHandle;\t\t\r\n\t}\r\n\t\r\n\t/**\r\n\t* Returns the name of <% if(isinteraction){ %>a parameter<%}else{%>an attribute<%}%> corresponding to\r\n\t* its handle (RTI assigned) in datamemberHandle.\r\n\t*\r\n\t* @param datamemberHandle handle of <% if(isinteraction){ %>parameter<%}else{%>attribute<%}%> (RTI assigned)\r\n\t* for which to return the name\r\n\t* @return the name of the <% if(isinteraction){ %>parameter<%}else{%>attribute<%}%> corresponding to datamemberHandle\r\n\t*/\r\n\tpublic static String get_<%=isinteraction?\"parameter\":\"attribute\"%>_name( int datamemberHandle ) {\r\n\t\treturn _datamemberHandleNameMap.get( datamemberHandle );\r\n\t}\r\n\t\r\n\t/**\r\n\t* Returns the handle of <% if(isinteraction){ %>a parameter<%}else{%>an attribute<%}%> (RTI assigned) given\r\n\t* its <%=isinteraction?\"interaction\":\"object\"%> class name and <%=isinteraction?\"parameter\":\"attribute\"%> name\r\n\t*\r\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class\r\n\t* @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%>\r\n\t* @return the handle (RTI assigned) of the <%=isinteraction?\"parameter\":\"attribute\"%> \"datamemberName\" of <%=isinteraction?\"interaction\":\"object\"%> class \"className\"\r\n\t*/\r\n\tpublic static int get_<%=isinteraction?\"parameter\":\"attribute\"%>_handle( String className, String datamemberName ) {\r\n\t\r\n\t\tInteger datamemberHandle = _datamemberNameHandleMap.get( className + \",\" + datamemberName );\r\n\t\tif ( datamemberHandle == null ) {\r\n\t\t\tSystem.err.println( \"Bad <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" + datamemberName + \"\\\" for class \\\"\" + className + \"\\\" on get_<%=isinteraction?\"parameter\":\"attribute\"%>_handle.\" );\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t\t\r\n\t\treturn datamemberHandle;\t\t\r\n\t}\r\n\t\r\n\tprivate static Class<?>[] pubsubArguments = new Class<?>[] { RTIambassador.class };\r\n\t\r\n\t\r\n\t/**\r\n\t* Publishes the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" for a federate.\r\n\t* This can also be performed by calling the publish( RTIambassador rti )\r\n\t* method directly on the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" (for\r\n\t* example, to publish the <%=isinteraction?\"Interaction\":\"Object\"%>Root class in particular,\r\n\t* see {@link <%=isinteraction?\"Interaction\":\"Object\"%>Root#publish( RTIambassador rti )}).\r\n\t*\r\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class to be published for the federate\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic static void publish( String className, RTIambassador rti ) {\r\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\r\n\t\tif ( rtiClass == null ) {\r\n\t\t\tSystem.err.println( \"Bad class name \\\"\" + className + \"\\\" on publish.\" );\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tMethod method = rtiClass.getMethod( \"publish\", pubsubArguments );\r\n\t\t\tmethod.invoke( null, new Object[]{ rti } );\r\n\t\t} catch ( Exception e ) {\r\n\t\t\tSystem.err.println( \"Exception caught on publish!\" );\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* Unpublishes the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" for a federate.\r\n\t* This can also be performed by calling the unpublish( RTIambassador rti )\r\n\t* method directly on the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" (for\r\n\t* example, to unpublish the <%=isinteraction?\"Interaction\":\"Object\"%>Root class in particular,\r\n\t* see {@link <%=isinteraction?\"Interaction\":\"Object\"%>Root#unpublish( RTIambassador rti )}).\r\n\t*\r\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class to be unpublished for the federate\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic static void unpublish( String className, RTIambassador rti ) {\r\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\r\n\t\tif ( rtiClass == null ) {\r\n\t\t\tSystem.err.println( \"Bad class name \\\"\" + className + \"\\\" on unpublish.\" );\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tMethod method = rtiClass.getMethod( \"unpublish\", pubsubArguments );\r\n\t\t\tmethod.invoke( null, new Object[]{ rti } );\r\n\t\t} catch ( Exception e ) {\r\n\t\t\tSystem.err.println( \"Exception caught on unpublish!\" );\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t* Subscribes federate to the <%=isinteraction?\"interaction\":\"object\"%> class names by \"className\"\r\n\t* This can also be performed by calling the subscribe( RTIambassador rti )\r\n\t* method directly on the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" (for\r\n\t* example, to subscribe a federate to the <%=isinteraction?\"Interaction\":\"Object\"%>Root class\r\n\t* in particular, see {@link <%=isinteraction?\"Interaction\":\"Object\"%>Root#subscribe( RTIambassador rti )}).\r\n\t*\r\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class to which to subscribe the federate\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic static void subscribe( String className, RTIambassador rti ) {\r\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\r\n\t\tif ( rtiClass == null ) {\r\n\t\t\tSystem.err.println( \"Bad class name \\\"\" + className + \"\\\" on subscribe.\" );\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tMethod method = rtiClass.getMethod( \"subscribe\", pubsubArguments );\r\n\t\t\tmethod.invoke( null, new Object[]{ rti } );\r\n\t\t} catch ( Exception e ) {\r\n\t\t\tSystem.err.println( \"Exception caught on subscribe!\" );\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t* Unsubscribes federate from the <%=isinteraction?\"interaction\":\"object\"%> class names by \"className\"\r\n\t* This can also be performed by calling the unsubscribe( RTIambassador rti )\r\n\t* method directly on the <%=isinteraction?\"interaction\":\"object\"%> class named by \"className\" (for\r\n\t* example, to unsubscribe a federate to the <%=isinteraction?\"Interaction\":\"Object\"%>Root class\r\n\t* in particular, see {@link <%=isinteraction?\"Interaction\":\"Object\"%>Root#unsubscribe( RTIambassador rti )}).\r\n\t*\r\n\t* @param className name of <%=isinteraction?\"interaction\":\"object\"%> class to which to unsubscribe the federate\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic static void unsubscribe( String className, RTIambassador rti ) {\r\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\r\n\t\ttry {\r\n\t\t\tMethod method = rtiClass.getMethod( \"unsubscribe\", pubsubArguments );\r\n\t\t\tmethod.invoke( null, new Object[]{ rti } );\r\n\t\t} catch ( Exception e ) {\r\n\t\t\tSystem.err.println( \"Exception caught on unsubscribe!\" );\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\r\n<% if(isinteraction){ %><%}else{%>\r\n\t/**\r\n\t* Publishes the attribute named by \"attributeName\" of the object class named\r\n\t* by \"className\" for a federate.  This can also be performed by calling the\r\n\t* publish_<attributeName>() method directly on the object class named by\r\n\t* \"className\".\r\n\t*\r\n\t* Note:  This method only marks the attribute named by \"attributeName\" for\r\n\t* publication.  The attribute doesn't actually get published until the\r\n\t* \"className\" object class, of which it is a member, is (re)published.  See\r\n\t* {@link ObjectRoot#publish( String className, RTIambassador RTI )} and\r\n\t* {@link ObjectRoot#publish( RTIambassador RTI )} for examples of how to\r\n\t* publish the object class.\r\n\t* \r\n\t* @param className name of object class for which the attribute named by\r\n\t* \"attributeName\" is to be published\r\n\t* @param attributeName name of the attribute to be published\r\n\t*/\r\n\tpublic static void publish( String className, String attributeName ) {\r\n\t\ttry {\r\n\t\t\t_classNamePublishAttributeNameMap.get( className ).add( attributeName );\r\n\t\t} catch ( Exception e ) {\r\n\t\t\tSystem.err.println( \"ERROR:  ObjectRoot.publish:  could not publish class \\\"\" + className + \"\\\" \\\"\" + attributeName + \"\\\" attribute.\" );\r\n\t\t\te.printStackTrace();\r\n\t\t}\t\t\r\n\t}\r\n\r\n\t/**\r\n\t* Unpublishes the attribute named by \"attributeName\" of the object class named\r\n\t* by \"className\" for a federate.  This can also be performed by calling the\r\n\t* unpublish_<attributeName>() method directly on the object class named by\r\n\t* \"className\".\r\n\t*\r\n\t* Note:  This method only marks the attribute named by \"attributeName\" for\r\n\t* un-publication. The attribute doesn't actually get unpublished until the\r\n\t* \"className\" object class, of which it is a member, is (re)published.  See\r\n\t* {@link ObjectRoot#publish( String className, RTIambassador RTI )} and\r\n\t* {@link ObjectRoot#publish( RTIambassador RTI )} for examples of how to\r\n\t* publish the object class.\r\n\t* \r\n\t* @param className name of object class for which the attribute named by\r\n\t* \"attributeName\" is to be unpublished (by a federate)\r\n\t* @param attributeName name of the attribute to be unpublished\r\n\t*/\r\n\tpublic static void unpublish( String className, String attributeName ) {\r\n\t\ttry {\r\n\t\t\t_classNamePublishAttributeNameMap.get( className ).remove( attributeName );\r\n\t\t} catch ( Exception e ) {\r\n\t\t\tSystem.err.println( \"ERROR:  ObjectRoot.unpublish:  could not unpublish class \\\"\" + className + \"\\\" \\\"\" + attributeName + \"\\\" attribute.\" );\r\n\t\t\te.printStackTrace();\r\n\t\t}\t\t\r\n\t}\r\n\r\n\t/**\r\n\t* Subscribe a federate to the attribute named by \"attributeName\" of the\r\n\t* object class named by \"className\".  This can also be performed by calling\r\n\t* the subscribe_<attributeName>() method directly on the object class named\r\n\t* by \"className\".\r\n\t*\r\n\t* Note:  This method only marks the attribute named by \"attributeName\" for\r\n\t* subscription.  The attribute doesn't actually get subscribed to until the\r\n\t* \"className\" object class, of which it is a member, is (re)subscribed to.\r\n\t* See {@link ObjectRoot#subscribe( String className, RTIambassador RTI )} and\r\n\t* {@link ObjectRoot#subscribe( RTIambassador RTI )} for examples of how to\r\n\t* subscribe to the object class.\r\n\t* \r\n\t* @param className name of object class for which the attribute named by\r\n\t* \"attributeName\" is to be subcribed\r\n\t* @param attributeName name of the attribute to be published\r\n\t*/\r\n\tpublic static void subscribe( String className, String attributeName ) {\r\n\t\ttry {\r\n\t\t\t_classNameSubscribeAttributeNameMap.get( className ).add( attributeName );\r\n\t\t} catch ( Exception e ) {\r\n\t\t\tSystem.err.println( \"ERROR:  ObjectRoot.subscribe:  could not subscribe to class \\\"\" + className + \"\\\" \\\"\" + attributeName + \"\\\" attribute.\" );\r\n\t\t\te.printStackTrace();\r\n\t\t}\t\t\r\n\t}\r\n\r\n\t/**\r\n\t* Unsubscribe a federate from the attribute named by \"attributeName\" of the\r\n\t* object class named by \"className\".  This can also be performed by calling\r\n\t* the unsubscribe_<attributeName>() method directly on the object class named\r\n\t* by \"className\".\r\n\t*\r\n\t* Note:  This method only marks the attribute named by \"attributeName\" for\r\n\t* unsubscription.  The attribute doesn't actually get unsubscribed from until the\r\n\t* \"className\" object class, of which it is a member, is (re)subscribed to.\r\n\t* See {@link ObjectRoot#subscribe( String className, RTIambassador RTI )} and\r\n\t* {@link ObjectRoot#subscribe( RTIambassador RTI )} for examples of how to\r\n\t* subscribe to the object class.\r\n\t* \r\n\t* @param className name of object class for which the attribute named by\r\n\t* \"attributeName\" is to be subcribed\r\n\t* @param attributeName name of the attribute to be published\r\n\t*/\r\n\tpublic static void unsubscribe( String className, String attributeName ) {\r\n\t\ttry {\r\n\t\t\t_classNameSubscribeAttributeNameMap.get( className ).remove( attributeName );\r\n\t\t} catch ( Exception e ) {\r\n\t\t\tSystem.err.println( \"ERROR:  ObjectRoot.unsubscribe:  could not unsubscribe class \\\"\" + className + \"\\\" \\\"\" + attributeName + \"\\\" attribute.\" );\r\n\t\t\te.printStackTrace();\r\n\t\t}\t\t\r\n\t}\r\n<%}%>\r\n\t\r\n\tprivate static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( Class<?> rtiClass ) {\r\n\t\t<%=isinteraction?\"Interaction\":\"Object\"%>Root classRoot = null;\r\n\t\ttry {\r\n\t\t\tclassRoot = (<%=isinteraction?\"Interaction\":\"Object\"%>Root)rtiClass.newInstance();\r\n\t\t} catch( Exception e ) {\r\n\t\t\tSystem.err.println( \"ERROR:  <%=isinteraction?\"Interaction\":\"Object\"%>Root:  create_<%=isinteraction?\"interaction\":\"object\"%>:  could not create/cast new <%=isinteraction?\"Interaction\":\"Object\"%>\" );\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\t\r\n\t\treturn classRoot;\r\n\t}\r\n\r\n\tprivate static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( Class<?> rtiClass, LogicalTime logicalTime ) {\t\r\n\t\t<%=isinteraction?\"Interaction\":\"Object\"%>Root classRoot = create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass );\r\n\t\tif ( classRoot != null ) classRoot.setTime( logicalTime );\r\n\t\treturn classRoot;\r\n\t}\r\n\r\n\tprivate static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( Class<?> rtiClass, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\r\n\t\t<%=isinteraction?\"Interaction\":\"Object\"%>Root classRoot = create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass );\r\n\t\tclassRoot.set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\r\n\t\treturn classRoot;\r\n\t}\r\n\t\r\n\tprivate static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( Class<?> rtiClass, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime ) {\r\n\t\t<%=isinteraction?\"Interaction\":\"Object\"%>Root classRoot = create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass );\r\n\t\tclassRoot.set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\r\n\t\tclassRoot.setTime( logicalTime );\r\n\t\treturn classRoot;\r\n\t}\r\n\t\r\n\t/**\r\n\t* Create an <%=isinteraction?\"interaction\":\"object\"%> that is in instance of <%=isinteraction?\"interaction\":\"object\"%> class\r\n\t* \"className\". An <%=isinteraction?\"Interaction\":\"Object\"%>Root reference is returned,\r\n\t* so to refer to the instance using a reference to a \"className\" interaction,\r\n\t* the returned reference must be cast down the <%=isinteraction?\"interaction\":\"object\"%> inheritance\r\n\t* hierarchy.\r\n\t* An instance of the \"className\" <%=isinteraction?\"interaction\":\"object\"%> class may also be created\r\n\t* by using the \"new\" operator directory on the \"className\" <%=isinteraction?\"interaction\":\"object\"%>\r\n\t* class.  For instance, two ways to create an <%=isinteraction?\"Interaction\":\"Object\"%>Root\r\n\t* instance are\r\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>.create_<%=isinteraction?\"interaction\":\"object\"%>( \"<%=isinteraction?\"Interaction\":\"Object\"%>Root\" ),\r\n\t* and\r\n\t* new <%=isinteraction?\"Interaction\":\"Object\"%>Root()\r\n\t*\r\n\t* @param className fully-qualified (dot-delimited) name of the <%=isinteraction?\"interaction\":\"object\"%>\r\n\t* class for which to create an instance\r\n\t* @return instance of \"className\" <%=isinteraction?\"interaction\":\"object\"%> class\r\n\t*/\r\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( String className ) {\r\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\r\n\t\tif ( rtiClass == null ) return null;\r\n\r\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass );\r\n\t}\r\n\r\n\t/**\r\n\t* Like {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( String className )}, but <%=isinteraction?\"interaction\":\"object\"%>\r\n\t* is created with a timestamp based on \"logicalTime\".\r\n\t*\r\n\t* @param className fully-qualified (dot-delimited) name of the <%=isinteraction?\"interaction\":\"object\"%>\r\n\t* class for which to create an instance\r\n\t* @param logicalTime timestamp to place on the new <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n\t* @return instance of \"className\" <%=isinteraction?\"interaction\":\"object\"%> class with \"logicalTime\" time stamp.\r\n\t*/\r\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( String className, LogicalTime logicalTime ) {\r\n\t\tClass<?> rtiClass = _classNameClassMap.get( className );\r\n\t\tif ( rtiClass == null ) return null;\r\n\r\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass, logicalTime );\r\n\t}\r\n\r\n\t/**\r\n\t* Create an <%=isinteraction?\"interaction\":\"object\"%> that is in instance of <%=isinteraction?\"interaction\":\"object\"%> class\r\n\t* that corresponds to the \"classHandle\" handle (RTI assigned). An\r\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>Root reference is returned, so to refer to the\r\n\t* instance using a reference to a \"className\" interaction, the returned\r\n\t* reference must be cast down the <%=isinteraction?\"interaction\":\"object\"%> inheritance hierarchy.\r\n\t*\r\n\t* @param classHandle handle of <%=isinteraction?\"interaction\":\"object\"%> class (RTI assigned) class for\r\n\t* which to create an instance\r\n\t* @return instance of <%=isinteraction?\"interaction\":\"object\"%> class corresponding to \"classHandle\"\r\n\t*/\r\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle ) {\r\n\t\tClass<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );\r\n\t\tif ( rtiClass == null ) return null;\r\n\r\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass );\r\n\t}\r\n\r\n\t/**\r\n\t* Like {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle )}, but the <%=isinteraction?\"interaction\":\"object\"%>\r\n\t* is created with a timestamp based on \"logicalTime\".\r\n\t*\r\n\t* @param classHandle handle of <%=isinteraction?\"interaction\":\"object\"%> class (RTI assigned) class for\r\n\t* which to create an instance\r\n\t* @param logicalTime timestamp to place on the new <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n\t* @return instance of <%=isinteraction?\"interaction\":\"object\"%> class corresponding to \"classHandle\" with\r\n\t* \"logicalTime\" time stamp\r\n\t*/\r\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, LogicalTime logicalTime ) {\r\n\t\tClass<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );\r\n\t\tif ( rtiClass == null ) return null;\r\n\r\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass, logicalTime );\r\n\t}\r\n\r\n\t/**\r\n\t* Like {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle )}, but the <%=isinteraction?\"interaction\":\"object\"%>'s\r\n\t* <%=isinteraction?\"parameter\":\"attribute\"%>s are initialized using \"datamemberMap\".  The \"datamemberMap\"\r\n\t* is usually acquired as an argument to an RTI callback method of a federate.\r\n\t*\r\n\t* @param classHandle handle of <%=isinteraction?\"interaction\":\"object\"%> class (RTI assigned) class for\r\n\t* which to create an instance\r\n\t* @param datamemberMap contains initializing values for the <%=isinteraction?\"parameter\":\"attribute\"%>s\r\n\t* of the <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n\t* @return instance of <%=isinteraction?\"interaction\":\"object\"%> class corresponding to \"classHandle\" with\r\n\t* its <%=isinteraction?\"parameter\":\"attribute\"%>s initialized with the \"datamemberMap\"\r\n\t*/\r\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\r\n\t\tClass<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );\r\n\t\tif ( rtiClass == null ) return null;\r\n\r\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass, datamemberMap );\r\n\t}\r\n\r\n\t/**\r\n\t* Like {@link #create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap )},\r\n\t* but the <%=isinteraction?\"interaction\":\"object\"%> is given a timestamp based on \"logicalTime\".\r\n\t*\r\n\t* @param classHandle handle of <%=isinteraction?\"interaction\":\"object\"%> class (RTI assigned) class for\r\n\t* which to create an instance\r\n\t* @param datamemberMap initializing values for the <%=isinteraction?\"parameter\":\"attribute\"%>s of the\r\n\t* <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n\t* @param logicalTime timestamp to place on the new <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n\t* @return instance of <%=isinteraction?\"interaction\":\"object\"%> class corresponding to \"classHandle\" with\r\n\t* its <%=isinteraction?\"parameter\":\"attribute\"%>s initialized with the \"datamemberMap\" and with\r\n\t* \"logicalTime\" timestamp\r\n\t*/\r\n\tpublic static <%=isinteraction?\"Interaction\":\"Object\"%>Root create_<%=isinteraction?\"interaction\":\"object\"%>( int classHandle, <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime ) {\r\n\t\tClass<?> rtiClass = _classNameClassMap.get(  _classHandleNameMap.get( classHandle )  );\r\n\t\tif ( rtiClass == null ) return null;\r\n\r\n\t\treturn create_<%=isinteraction?\"interaction\":\"object\"%>( rtiClass, datamemberMap, logicalTime );\r\n\t}\r\n\r\n<% if(isinteraction){ %><%}else{%>\r\n\t/**\r\n\t* Creates a new instance of the object class corresponding to \"class_handle\",\r\n\t* registers it in an map internal to the ObjectRoot class using \"object_handle\"\r\n\t* as a key, and returns a reference to the instance.  Though the created\r\n\t* instance is of the object class corresponding to \"class_handle\" (which is\r\n\t* a handle assigned by the RTI), it is referred to, via the return value, by\r\n\t* an ObjectRoot reference.  Thus, to refer to it as an instance of the object\r\n\t* class corresponding to \"class_handle\", the ObjectRoot reference needs to be\r\n\t* cast down through the inheritance hierarchy.\r\n\t* <p/>\r\n\t* class_handle and object_handle are usually acquired as arguments of the\r\n\t* \"discoverObjectInstance\" RTI callback method of a federate.\r\n\t*\r\n\t* @param class_handle handle of object class (RTI assigned) for which to create\r\n\t* an instance\r\n\t* @param object_handle handle (also RTI assigned) of this instance as it is\r\n\t* known to the RTI.  Any updates to the instance attributes provided by the\r\n\t* RTI (via a \"reflectAttributeValues\" federate callback) will be identified\r\n\t* with this object_handle.\r\n\t* @return new instance of the object class corresponding to class_handle\r\n\t*/\r\n    public static ObjectRoot discover( int class_handle, int object_handle ) {\r\n        Class<?> hlaObjectClass = _classNameClassMap.get(  _classHandleNameMap.get( class_handle )  );\r\n        ObjectRoot objectRoot = null;\r\n        try {\r\n            objectRoot = (ObjectRoot)hlaObjectClass.newInstance();\r\n            objectRoot.setObjectHandle( object_handle );\r\n            _objectMap.put( object_handle, objectRoot );\r\n        } catch( Exception e ) {\r\n            System.err.println( \"ERROR:  ObjectRoot:  discover:  could not discover object\" );\r\n            e.printStackTrace();\r\n        }\r\n        return objectRoot;\r\n    }\r\n    \r\n    /**\r\n    * Retrieves the object instance corresponding to \"object_handle\" from an\r\n    * internal table in the ObjectRoot class, updates its attribute values using\r\n    * \"reflectedAttributes\", and returns the instance.  Both \"object_handle\" and\r\n    * \"reflectedAttributes\" are usually acquired as arguments of the\r\n    * \"reflectAttributeValues\" RTI callback of a federate.\r\n    * The return value is an ObjectRoot reference to the instance.  So, to refer\r\n    * to the instance as an instance of its actual class, this reference will\r\n    * have to be cast down the inheritance hierarchy.\r\n    *\r\n    * @param object_handle handle (RTI assigned) of object instance for which the\r\n    * attributes are to be updated.\r\n    * @param reflectedAttributes set of updated values for the attributes of the\r\n    * object instance corresponding to object_handle.\r\n    * @return the object instance with updated attribute values\r\n    */\r\n    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes ) {\r\n    \tObjectRoot objectRoot = _objectMap.get( object_handle );\r\n    \tif ( objectRoot == null ) return null;\r\n    \tobjectRoot.setTime( -1 );\r\n    \tobjectRoot.setAttributes( reflectedAttributes );\r\n    \treturn objectRoot;\r\n    }\r\n\r\n\t/**\r\n\t* Like {@link #reflect( int object_handle, ReflectedAttributes reflectedAttributes )},\r\n\t* except the updated attributes of the object instance have their timestamps\r\n\t* updated to \"logicalTime\".\r\n\t*\r\n    * @param object_handle handle (RTI assigned) of object instance for which the\r\n    * attributes are to be updated.\r\n    * @param reflectedAttributes set of updated values for the attributes of the\r\n    * object instance corresponding to object_handle.\r\n    * @param logicalTime new time stamp for attributes that are updated\r\n    * @return the object instance with updated attribute values\r\n    */\r\n    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes, LogicalTime logicalTime ) {\r\n    \tObjectRoot objectRoot = _objectMap.get( object_handle );\r\n    \tif ( objectRoot == null ) return null;\r\n    \tobjectRoot.setTime( logicalTime );\r\n    \tobjectRoot.setAttributes( reflectedAttributes );\r\n    \treturn objectRoot;\r\n    }\r\n\r\n\t/**\r\n\t* Like {@link #reflect( int object_handle, ReflectedAttributes reflectedAttributes )},\r\n\t* except the updated attributes of the object instance have their timestamps\r\n\t* updated to \"time\".\r\n\t*\r\n    * @param object_handle handle (RTI assigned) of object instance for which the\r\n    * attributes are to be updated.\r\n    * @param reflectedAttributes set of updated values for the attributes of the\r\n    * object instance corresponding to object_handle.\r\n    * @param time new time stamp for attributes that are updated\r\n    * @return the object instance with updated attribute values\r\n    */\r\n    public static ObjectRoot reflect( int object_handle, ReflectedAttributes reflectedAttributes, double time ) {\r\n    \tObjectRoot objectRoot = _objectMap.get( object_handle );\r\n    \tif ( objectRoot == null ) return null;\r\n    \tobjectRoot.setTime( time );\r\n    \tobjectRoot.setAttributes( reflectedAttributes );\r\n    \treturn objectRoot;\r\n    }\r\n\r\n\t/**\r\n\t* Requests an attribute update for this object instance from the federate that\r\n\t* has modification rights on these attributes.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic void requestUpdate( RTIambassador rti ) {\r\n\t\tboolean requestNotSubmitted = true;\r\n\t\twhile( requestNotSubmitted ) {\r\n\t\t\ttry {\t\t\r\n\t\t\t\trti.requestObjectAttributeValueUpdate( getObjectHandle(), getSubscribedAttributeHandleSet() );\r\n\t\t\t\trequestNotSubmitted = false;\r\n\t\t\t} catch ( FederateNotExecutionMember f ) {\r\n\t\t\t\tSystem.err.println( \"ERROR: \" + getClassName() + \"request for update failed:  Federate Not Execution Member\" );\r\n\t\t\t\tf.printStackTrace();\r\n\t\t\t\treturn;\t\t\t\t\r\n\t\t\t} catch ( ObjectNotKnown o ) {\r\n\t\t\t\tSystem.err.println( \"ERROR: \" + getClassName() + \"request for update failed:  Object Not Known\" );\r\n\t\t\t\to.printStackTrace();\r\n\t\t\t\treturn;\t\t\t\t\r\n\t\t\t} catch ( AttributeNotDefined a ) {\r\n\t\t\t\tSystem.err.println( \"ERROR: \" + getClassName() + \"request for update failed:  Name Not Found\" );\r\n\t\t\t\ta.printStackTrace();\r\n\t\t\t\treturn;\t\t\t\t\r\n\t\t\t} catch ( Exception e ) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t\ttry { Thread.sleep( 50 ); } catch( Exception e1 ) { }\t\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* Returns the object instance corresponding to the \"object_handle\" (RTI\r\n\t* assigned) from a map internal to the ObjectRoot class.\r\n\t* The object instance is referred to, via the return value, using an\r\n\t* an ObjectRoot reference.  To reference to it using a reference of its\r\n\t* actual class, the returned reference must be cast down through the\r\n\t* inhertance hierarchy.\r\n\t*\r\n\t* @param object_handle handle (RTI assigned) of object instance to retrieve\r\n\t* from the map internal to the ObjectRoot class.\r\n\t* @return object instance corresponding to the object_handle (RTI assigned)\r\n\t* in the map that is internal to the ObjectRoot class.\r\n\t*/\r\n\tpublic static ObjectRoot getObject( int object_handle ) {\r\n\t\treturn _objectMap.get( object_handle );\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t* Returns the object instance corresponding to the \"object_handle\" (RTI\r\n\t* assigned) from a map internal to the ObjectRoot class AND REMOVES IT\r\n\t* FROM THIS MAP.\r\n\t* The object instance is referred to, via the return value, using an\r\n\t* an ObjectRoot reference.  To reference to it using a reference of its\r\n\t* actual class, the returned reference must be cast down through the\r\n\t* inhertance hierarchy.\r\n\t*\r\n\t* @param object_handle handle (RTI assigned) of object instance to retrieve\r\n\t* from the map internal to the ObjectRoot class.\r\n\t* @return object instance corresponding to the object_handle (RTI assigned)\r\n\t* in the map that is internal to the ObjectRoot class.\r\n\t*/\r\n    public static ObjectRoot removeObject( int object_handle ) {\r\n        return _objectMap.remove( object_handle );\r\n    }\r\n    \r\n\r\n    private int _object_handle;\r\n\r\n    private void setObjectHandle( int object_handle ) {\r\n        _objectMap.remove( object_handle );\r\n        _object_handle = object_handle;\r\n        _objectMap.put( object_handle, this );\r\n    }\r\n\r\n\t/**\r\n\t* Returns the handle (RTI assigned) the corresponds to this object class\r\n\t* instance.  This handle is the instance's unique identifier to the RTI.\r\n\t*\r\n\t* @return the handle (RTI assigned) of this object class instance.\r\n\t*/\r\n    public int getObjectHandle() { return _object_handle; }\r\n\t\r\n<%}%>\r\n\r\n\tprivate double _time = -1;\r\n\t\r\n\t/**\r\n\t* Returns the timestamp for this <%=isinteraction?\"interaction\":\"object\"%>.  \"receive order\" <%=isinteraction?\"interaction\":\"object\"%>s\r\n\t* should have a timestamp of -1.\r\n\t*\r\n\t* @return timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\r\n\t*/\r\n\tpublic double getTime() { return _time; }\r\n\t\r\n\t/**\r\n\t* Sets the timestamp of this <%=isinteraction?\"interaction\":\"object\"%> to \"time\".\r\n\t*\r\n\t* @param time new timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\r\n\t*/\r\n\tpublic void setTime( double time ) { _time = time; }\r\n\r\n\t/**\r\n\t* Sets the timestamp of this <%=isinteraction?\"interaction\":\"object\"%> to \"logicalTime\".\r\n\t*\r\n\t* @param logicalTime new timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\r\n\t*/\r\n\tpublic void setTime( LogicalTime logicalTime ) {\r\n\t\tDoubleTime doubleTime = new DoubleTime();\r\n\t\tdoubleTime.setTo( logicalTime );\r\n\t\tsetTime( doubleTime.getTime() );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* Creates a new <%=isinteraction?\"Interaction\":\"Object\"%>Root instance.\r\n\t*/\r\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>Root() {\r\n\t\t_uniqueID = generateUniqueID();\r\n\t}\r\n\t\r\n\t/**\r\n\t* Creates a copy of an <%=isinteraction?\"Interaction\":\"Object\"%>Root instance.  As an\r\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>Root instance contains no <%=isinteraction?\"parameter\":\"attribute\"%>s,\r\n\t* this has the same effect as the default constructor.\r\n\t*/\r\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"Interaction\":\"Object\"%>Root <%=isinteraction?\"interaction\":\"object\"%>Root ) {\r\n\t\tthis();\r\n\t}\r\n\r\n\tprotected <%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, boolean initFlag ) {\r\n\t\tthis();\r\n\t\tif ( initFlag ) set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\r\n\t}\r\n\t\r\n\tprotected <%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime, boolean initFlag ) {\r\n\t\tthis();\r\n\t\tsetTime( logicalTime );\r\n\t\tif ( initFlag ) set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( datamemberMap );\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* Creates a new <%=isinteraction?\"interaction\":\"object\"%> instance and initializes its <%=isinteraction?\"parameter\":\"attribute\"%>s\r\n\t* using the \"datamemberMap\" -- this constructor is usually called as a\r\n\t* super-class constructor to create and initialize an instance of an\r\n\t* <%=isinteraction?\"interaction\":\"object\"%> further down in the inheritance hierarchy.  \"datamemberMap\"\r\n\t* is usually acquired as an argument to an RTI federate callback method, such\r\n\t* as \"receiveInteraction\".\r\n\t*\r\n\t* @param datamemberMap contains <%=isinteraction?\"parameter\":\"attribute\"%> values for the newly created\r\n\t* <%=isinteraction?\"interaction\":\"object\"%>\r\n\t*/\r\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\r\n\t\tthis( datamemberMap, true );\r\n\t}\r\n\r\n\t/**\r\n\t* Like {@link #<%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap )},\r\n\t* except the new instance has an initial timestamp of \"logicalTime\".\r\n\t*\r\n\t* @param datamemberMap contains <%=isinteraction?\"parameter\":\"attribute\"%> values for the newly created\r\n\t* <%=isinteraction?\"interaction\":\"object\"%>\r\n\t* @param logicalTime initial timestamp for newly created <%=isinteraction?\"interaction\":\"object\"%> instance\r\n\t*/\t\r\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>Root( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap, LogicalTime logicalTime ) {\r\n\t\tthis( datamemberMap, logicalTime, true );\r\n\t}\r\n\r\n\t/**\r\n\t* Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" for this\r\n\t* <%=isinteraction?\"interaction\":\"object\"%>.\r\n\t*\r\n\t* @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value to retrieve\r\n\t* @return the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose name is \"datamemberName\"\r\n\t*/\r\n\tpublic Object get<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName ) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\t/**\r\n\t* Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose handle is \"datamemberHandle\"\r\n\t* (RTI assigned) for this <%=isinteraction?\"interaction\":\"object\"%>.\r\n\t*\r\n\t* @param datamemberHandle handle (RTI assigned) of <%=isinteraction?\"parameter\":\"attribute\"%> whose\r\n\t* value to retrieve\r\n\t* @return the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose handle is \"datamemberHandle\"\r\n\t*/\r\n\tpublic Object get<%=isinteraction?\"Parameter\":\"Attribute\"%>( int datamemberHandle ) {\r\n\t\treturn null;\r\n\t}\r\n\t\t\r\n\t/**\r\n\t* Set the values of the <%=isinteraction?\"parameter\":\"attribute\"%>s in this <%=isinteraction?\"interaction\":\"object\"%> using\r\n\t* \"datamemberMap\".  \"datamemberMap\" is usually acquired as an argument to\r\n\t* an RTI federate callback method such as \"receiveInteraction\".\r\n\t*\r\n\t* @param datamemberMap  contains new values for the <%=isinteraction?\"parameter\":\"attribute\"%>s of\r\n\t* this <%=isinteraction?\"interaction\":\"object\"%>\r\n\t*/\r\n\tpublic void set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap ) {\r\n\t\tint size = datamemberMap.size();\r\n\t\tfor( int ix = 0 ; ix < size ; ++ix ) {\r\n\t\t\ttry {\r\n\t\t\t\tset<%=isinteraction?\"Parameter\":\"Attribute\"%>(  datamemberMap.get<%=isinteraction?\"Parameter\":\"Attribute\"%>Handle( ix ), datamemberMap.getValue( ix )  );\r\n\t\t\t} catch ( Exception e ) {\r\n\t\t\t\tSystem.err.println( \"set<%=isinteraction?\"Parameter\":\"Attribute\"%>s: Exception caught!\" );\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprivate void set<%=isinteraction?\"Parameter\":\"Attribute\"%>( int handle, byte[] val ) {\r\n\t\tif ( val == null ) {\r\n\t\t\tSystem.err.println( \"set:  Attempt to set null value in class \\\"\" + getClass().getName() + \"\\\"\" );\r\n\t\t}\r\n\t\tif (   !set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux(  handle, new String( val )  )   ) {\r\n\t\t\tSystem.err.println( \"set:  bad <%=isinteraction?\"parameter\":\"attribute\"%> handle in class \\\"\" + getClass().getName() + \"\\\"\" );\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t* Sets the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" to \"value\"\r\n\t* in this <%=isinteraction?\"interaction\":\"object\"%>.  \"value\" is converted to data type of \"datamemberName\"\r\n\t* if needed.\r\n\t* This action can also be affected by calling the set_<datamemberName>( value )\r\n\t* method on the <%=isinteraction?\"interaction\":\"object\"%> using a reference to the <%=isinteraction?\"interaction\":\"object\"%>'s actual\r\n\t* class.\r\n\t*\r\n\t* @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be set\r\n\t* to \"value\"\r\n\t* @param value new value of <%=isinteraction?\"parameter\":\"attribute\"%> called \"datamemberName\"\r\n\t*/\r\n\tpublic void set<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName, String value ) {\r\n\t\tif (  !set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, value )  ) {\r\n\t\t\tSystem.err.println( \"Error:  <%=isinteraction?\"interaction\":\"object\"%>Root:  invalid <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" + datamemberName + \"\\\"\" );\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* Sets the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" to \"value\"\r\n\t* in this <%=isinteraction?\"interaction\":\"object\"%>.  \"value\" should have the same data type as that of\r\n\t* the \"datamemberName\" <%=isinteraction?\"parameter\":\"attribute\"%>.\r\n\t* This action can also be affected by calling the set_<datamemberName>( value )\r\n\t* method on the <%=isinteraction?\"interaction\":\"object\"%> using a reference to the <%=isinteraction?\"interaction\":\"object\"%>'s actual\r\n\t* class.\r\n\t*\r\n\t* @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be set\r\n\t* to \"value\"\r\n\t* @param value new value of <%=isinteraction?\"parameter\":\"attribute\"%> called \"datamemberName\"\r\n\t*/\r\n\tpublic void set<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName, Object value ) {\r\n\t\tif (  !set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( datamemberName, value )  ) {\r\n\t\t\tSystem.err.println( \"Error:  <%=isinteraction?\"interaction\":\"object\"%>Root:  invalid <%=isinteraction?\"parameter\":\"attribute\"%> \\\"\" + datamemberName + \"\\\"\" );\r\n\t\t}\r\n\t}\r\n\r\n\tprotected boolean set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( int param_handle, String val ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprotected boolean set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( String datamemberName, String value ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprotected boolean set<%=isinteraction?\"Parameter\":\"Attribute\"%>Aux( String datamemberName, Object value ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprotected Supplied<%=isinteraction?\"Parameter\":\"Attribute\"%>s createSuppliedDatamembers(<% if(isinteraction){ %><%}else{%>boolean force<%}%>) {\r\n\t\treturn _factory.createSupplied<%=isinteraction?\"Parameter\":\"Attribute\"%>s();\r\n\t}\r\n\t\r\n<% if(isinteraction){ %>\r\n\t/**\r\n\t* Sends this interaction to the RTI, with the specified timestamp \"time\".\r\n\t* This method should be used to send interactions that have \"timestamp\"\r\n\t* ordering.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t* @param time timestamp for this interaction.  The timestamp should be no\r\n\t* less than the current federation time + the LOOKAHEAD value of the federate\r\n\t* sending this interaction.\r\n\t*/\r\n\tpublic void sendInteraction( RTIambassador rti, double time ) throws Exception {\r\n\t\tsynchronized( rti ) {\r\n\t\t\ttry {\r\n\t\t\t\tSuppliedParameters datamembers = createSuppliedDatamembers();\r\n\t\t\t\trti.sendInteraction(  getClassHandle(), datamembers, null, new DoubleTime( time )  );\r\n\t\t\t\tcreateLog(datamembers,time);\r\n\t\t\t} catch ( Exception e ) {\r\n\t\t\t\tSystem.err.println( \"ERROR:  \" + getClass().getName() + \":  could not send interaction\" );\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* Sends this interaction to the RTI (without a timestamp).\r\n\t* This method should be used to send interactions that have \"receive\"\r\n\t* ordering.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic void sendInteraction( RTIambassador rti ) throws Exception {\r\n\t\tsynchronized( rti ) {\r\n\t\t\ttry {\r\n\t\t\t\tSuppliedParameters datamembers = createSuppliedDatamembers();\r\n\t\t\t\trti.sendInteraction( getClassHandle(), datamembers, null );\r\n\t\t\t\tcreateLog(datamembers,0);\r\n\t\t\t} catch ( Exception e ) {\r\n\t\t\t\tSystem.err.println( \"ERROR:  \" + getClass().getName() + \":  could not send interaction\" );\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tprotected static String fedName = null;\r\n\tpublic static Boolean enablePubLog = false;\r\n\tpublic static Boolean enableSubLog = false;\r\n\tpublic static String pubLogLevel = null;\r\n\tpublic static String subLogLevel = null;\r\n\t\r\n\tpublic static void enablePublishLog(String interaction, String fed, String thislevel, String globallevel){\r\n\t\tif(globallevel == null || \"\".equals(globallevel)) return;\r\n\t\tif(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;\r\n\t\tfedName = fed;\r\n\t\tenablePubLog = true;\r\n\t\tpubLogLevel = thislevel;\r\n\t\tC2WLogger.addLog(interaction, fedName, true);\r\n\t}\r\n\t\r\n\tpublic static void enableSubscribeLog(String interaction, String fed, String thislevel, String globallevel){\r\n\t\tif(globallevel == null || \"\".equals(globallevel)) return;\r\n\t\tif(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;\r\n\t\tfedName = fed;\r\n\t\tenableSubLog = true;\r\n\t\tsubLogLevel = thislevel;\r\n\t\tC2WLogger.addLog(interaction, fedName, false);\r\n\t}\r\n\t\r\n\tprotected void createLog(final SuppliedParameters datamembers, final double time) {\r\n\t\tif(!enablePubLog) return;\r\n        Thread t = new Thread(new Runnable() {                                                                                 // NOMELD\r\n            public void run() {                                                                                                // NOMELD\r\n\t\t\t\ttry {\r\n\t\t\t\t\tString interactionId = fedName != null ? fedName + \"_pub_\"+ getSimpleClassName() :getSimpleClassName() + \"_pub\";\r\n\r\n\t\t\t\t\t// First just record the interaction event as a log\r\n\t\t\t\t\tC2WLogger.addEventLog(time, interactionId);\r\n\r\n\t\t\t\t\t// Now, log detailed simulation data of the interaction\r\n\t\t\t\t\tString logIdLocal = null;\r\n\t\t\t\t\tsynchronized( <%=isinteraction?\"Interaction\":\"Object\"%>Root.class ) {\r\n\t\t\t\t\t\tlogIdLocal = Integer.toString( logId++ );\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tint noDatamembers = datamembers.size();\r\n\t\t\t\t\tif ( noDatamembers == 0 ) {\r\n\t\t\t\t\t\tC2WLogger.addLog( interactionId, time, null, null, null, pubLogLevel, logIdLocal );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tfor(int ix =0; ix < datamembers.size();ix++){\r\n\t\t\t\t\t\t\tString parameter = get_parameter_name(datamembers.getHandle( ix ) );\r\n\t\t\t\t\t\t\tString value = new String(datamembers.getValue(ix));\t\r\n\t\t\t\t\t\t\tString type = new String(_datamemberTypeMap.get(parameter));\r\n\t\t\t\t\t\t\tC2WLogger.addLog( interactionId, time, parameter, value, type, pubLogLevel, logIdLocal );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch ( Exception e ) {\r\n\t\t\t\t\tSystem.err.println( \"ERROR:  \" + getClass().getName() + \":  could not send interaction\" );\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n            }\r\n        });\r\n        t.start();\r\n\t}\r\n\r\n<%}else{%>\r\n    private boolean _isRegistered = false;\r\n\r\n\t/**\r\n\t* Registers this object with the RTI.  This method is usually called by a\r\n\t* federate who \"owns\" this object, i.e. the federate that created it and\r\n\t* has write-privileges to its attributes (so, it is responsible for updating\r\n\t* these attribute and conveying their updated values to the RTI).\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/ \r\n    public void registerObject( RTIambassador rti ) {\r\n        \r\n        while( !_isRegistered ) {\r\n            try {\r\n                synchronized( rti ) {\r\n                    _object_handle = rti.registerObjectInstance( getClassHandle() );\r\n                }\r\n                _isRegistered = true;\r\n                _objectMap.put( getObjectHandle(), this );\r\n                \r\n            } catch ( ObjectClassNotDefined o ) {\r\n                o.printStackTrace();\r\n                return;\r\n            } catch ( ObjectClassNotPublished o ) {\r\n                o.printStackTrace();\r\n                return;\r\n            } catch ( FederateNotExecutionMember f ) {\r\n                f.printStackTrace();\r\n                return;\r\n            } catch ( Exception e ) {\r\n                try {\r\n                    Thread.sleep( 500 );\r\n                } catch ( InterruptedException e1 ) {\r\n                    e1.printStackTrace();\r\n                } \r\n            }\r\n        }\r\n\r\n    }\r\n    \r\n\t/**\r\n\t* Unregisters this object with the RTI.  The RTI will destroy all information\r\n\t* it contains regarding this object as a result.  This method is usually\r\n\t* called by a federate who \"owns\" this object, i.e. the federate that created\r\n\t* it and has write-privileges to its attributes.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/ \r\n    public void unregisterObject( RTIambassador rti ) {\r\n        \r\n        while( _isRegistered ) {\r\n            try {\r\n                synchronized( rti ) {\r\n                    rti.deleteObjectInstance( _object_handle, null );\r\n                }\r\n                _isRegistered = false;\r\n                _objectMap.remove( getObjectHandle() );\r\n                \r\n            } catch ( ObjectNotKnown o ) {\r\n                o.printStackTrace();\r\n                return;\r\n            } catch ( DeletePrivilegeNotHeld d ) {\r\n                d.printStackTrace();\r\n                return;\r\n            } catch ( FederateNotExecutionMember f ) {\r\n                f.printStackTrace();\r\n                return;\r\n            } catch ( Exception e ) {\r\n                try {\r\n                    Thread.sleep( 500 );\r\n                } catch ( InterruptedException e1 ) {\r\n                    e1.printStackTrace();\r\n                } \r\n            }\r\n        }\r\n    }\r\n\r\n\t/**\r\n\t* Broadcasts the attributes of this object and their values to the RTI, where\r\n\t* the values have \"time\" as their timestamp.  This call should be used for\r\n\t* objects whose attributes have \"timestamp\" ordering.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t* @param time timestamp on attribute values of this object\r\n\t* @param force if \"false\", only the attributes whose values have changed since\r\n\t* the last call to \"updateAttributeValues\" will be broadcast to the RTI.  If\r\n\t* \"true\", all attributes and their values are broadcast to the RTI.\r\n\t*/\r\n    public void updateAttributeValues( RTIambassador rti, double time, boolean force ) {\r\n\r\n        SuppliedAttributes suppliedAttributes = createSuppliedDatamembers( force );\r\n        if ( suppliedAttributes.size() == 0 ) return;\r\n\r\n        synchronized( rti ) {\r\n            try {\r\n                rti.updateAttributeValues(  getObjectHandle(), suppliedAttributes, null, new DoubleTime( time )  );\r\n                createLog(suppliedAttributes, time);\r\n            } catch ( ObjectNotKnown o ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Object Not Known\" );\r\n                o.printStackTrace();\r\n                return;\r\n            } catch ( FederateNotExecutionMember f ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Federate Not Execution Member\" );\r\n                f.printStackTrace();\r\n                return;\r\n            } catch ( AttributeNotDefined a ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Attribute Not Defined\" );\r\n                a.printStackTrace();\r\n                return;\r\n            } catch ( AttributeNotOwned a ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Attribute Not Owned\" );\r\n                a.printStackTrace();\r\n                return;\r\n            } catch ( ConcurrentAccessAttempted c ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Concurrent Access Attempted\" );\r\n                c.printStackTrace();\r\n                return;\r\n            } catch ( InvalidFederationTime i ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Invalid Federation Time\" );\r\n                i.printStackTrace();\r\n                return;\r\n            } catch ( Exception e ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes\" );\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n\t/**\r\n    * Like {@link #updateAttributeValues( RTIambassador rti, double time, boolean force )},\r\n    * except \"force\" is always false.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t* @param time timestamp on attribute values of this object\r\n\t*/\r\n    public void updateAttributeValues( RTIambassador rti, double time ) {\r\n    \tupdateAttributeValues( rti, time, false );\r\n    }\r\n\r\n\t/**\r\n\t* Broadcasts the attributes of this object and their values to the RTI (with\r\n\t* no timestamp).  This call should be used for objects whose attributes have\r\n\t* \"receive\" ordering.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t* @param force if \"false\", only the attributes whose values have changed since\r\n\t* the last call to \"updateAttributeValues\" will be broadcast to the RTI.  If\r\n\t* \"true\", all attributes and their values are broadcast to the RTI.\r\n\t*/\r\n    public void updateAttributeValues( RTIambassador rti, boolean force ) {\r\n\r\n        SuppliedAttributes suppliedAttributes = createSuppliedDatamembers( force );\r\n        if ( suppliedAttributes.size() == 0 ) return;\r\n\r\n        synchronized( rti ) {\r\n            try {\r\n                rti.updateAttributeValues( getObjectHandle(), suppliedAttributes, null );\r\n                createLog(suppliedAttributes, 0);\r\n            } catch ( ObjectNotKnown o ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Object Not Known\" );\r\n                o.printStackTrace();\r\n                return;\r\n            } catch ( FederateNotExecutionMember f ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Federate Not Execution Member\" );\r\n                f.printStackTrace();\r\n                return;\r\n            } catch ( AttributeNotDefined a ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Attribute Not Defined\" );\r\n                a.printStackTrace();\r\n                return;\r\n            } catch ( AttributeNotOwned a ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Attribute Not Owned\" );\r\n                a.printStackTrace();\r\n                return;\r\n            } catch ( ConcurrentAccessAttempted c ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes:  Concurrent Access Attempted\" );\r\n                c.printStackTrace();\r\n                return;\r\n            } catch ( Exception e ) {\r\n                System.err.println( \"ERROR:  \" + getClass().getName() + \":  could not update attributes\" );\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n\t/**\r\n    * Like {@link #updateAttributeValues( RTIambassador rti, boolean force )},\r\n    * except \"force\" is always false.\r\n\t*\r\n\t* @param rti handle to the RTI, usu. obtained through the\r\n\t* {@link SynchronizedFederate#getRTI()} call\r\n\t*/\r\n\tpublic void updateAttributeValues( RTIambassador rti ) {\r\n\t\tupdateAttributeValues( rti, false );\r\n\t}\r\n\r\n\tprotected static String _fedName = null;\r\n\tprotected static Map< String, String > _pubAttributeLogMap = new HashMap< String, String >();\r\n\tprotected static Map< String, String > _subAttributeLogMap = new HashMap< String, String >();\r\n\t\r\n\tpublic static void enablePublishLog(String object, String attribute, String fed, String thislevel, String globallevel){\r\n\t\tif(globallevel == null || \"\".equals(globallevel)) return;\r\n\t\tif(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;\r\n\t\t_fedName = fed;\r\n\t\t_pubAttributeLogMap.put(attribute, thislevel);\r\n\t\tC2WLogger.addLog(object, attribute, fed, true);\r\n\t}\r\n\t\r\n\tpublic static void enableSubscribeLog(String object, String attribute, String fed, String thislevel, String globallevel){\r\n\t\tif(globallevel == null || \"\".equals(globallevel)) return;\r\n\t\tif(C2WLogger.getLogLevel(thislevel)> C2WLogger.getLogLevel(globallevel)) return;\r\n\t\t_fedName = fed;\r\n\t\t_subAttributeLogMap.put(attribute, thislevel);\r\n\t\tC2WLogger.addLog(object, attribute, fed, true);\r\n\t}\r\n\t\r\n\tprotected void createLog(final SuppliedAttributes suppliedAttributes, final double time) {\r\n\t\tif(_pubAttributeLogMap.isEmpty()) return;\r\n        Thread t = new Thread(new Runnable() {                                                       // NOMELD\r\n            public void run() {                                                                      // NOMELD\r\n\t\t\t\ttry {\r\n\t\t\t\t\tString eventName = _fedName+\"_pub_\"+getSimpleClassName();\r\n\r\n\t\t\t\t\t// First just record the interaction event as a log\r\n\t\t\t\t\tC2WLogger.addEventLog(time, eventName);\r\n\r\n\t\t\t\t\t// Now, log detailed simulation data of the object update\r\n\t\t\t\t\tString logIdLocal = null;\r\n\t\t\t\t\tsynchronized( <%=isinteraction?\"Interaction\":\"Object\"%>Root.class ) {\r\n\t\t\t\t\t\tlogIdLocal = Integer.toString( logId++ );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor(int ix =0; ix < suppliedAttributes.size();ix++){\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tString attribute = get_attribute_name(suppliedAttributes.getHandle( ix ) );\t\t\t\r\n\t\t\t\t\t\tif(!_pubAttributeLogMap.containsKey(attribute)) continue;\r\n\t\t\t\t\t\tString id = _fedName+\"_pub_\"+getSimpleClassName()+\"_\"+attribute;\r\n\t\t\t\t\t\tString value = new String(suppliedAttributes.getValue(ix));\t\r\n\t\t\t\t\t\tString type = new String(_datamemberTypeMap.get(attribute));\r\n\t\t\t\t\t\tString loglevel = _pubAttributeLogMap.get(attribute);\r\n\t\t\t\t\t\tC2WLogger.addLog( id, time, attribute, value, type, loglevel, logIdLocal );\t\t\t\t\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch ( Exception e ) {\r\n\t\t\t\t\tSystem.err.println( \"ERROR:  \" + getClass().getName() + \":  could not send interaction\" );\r\n\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t}\r\n            }\r\n        });\r\n        t.start();\r\n\t}\r\n\t\r\n<%}%>\r\n\r\n\t/**\r\n\t* For use with the melding API -- this method is used to cast\r\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>Root instance reference into the\r\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface interface.\r\n\t*\r\n\t* @param rootInstance <%=isinteraction?\"Interaction\":\"Object\"%>Root instance reference to be\r\n\t* cast into the <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface interface\r\n\t* @return <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface reference to the instance\r\n\t*/\r\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface cast( <%=isinteraction?\"Interaction\":\"Object\"%>Root rootInstance ) {\r\n\t\treturn rootInstance;\r\n\t}\t\t\r\n\r\n\t/**\r\n\t* For use with the melding API -- this method creates a new\r\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>Root instance and returns a\r\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface reference to it.\r\n\t*\r\n\t* @return <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface reference to a newly created\r\n\t* <%=isinteraction?\"Interaction\":\"Object\"%>Root instance\r\n\t*/\r\n\tpublic <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface create() {\r\n\t\treturn new <%=isinteraction?\"Interaction\":\"Object\"%>Root();\r\n\t}\t\t\r\n\r\n\tpublic void copyFrom( Object object ) { }\r\n}\r\n",
    "cppfedbase_pom.xml.ejs": "<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n  <modelVersion>4.0.0</modelVersion>\r\n<% if (parent){ %>\r\n  <parent>\r\n    <groupId><%=parent.groupId%></groupId>\r\n    <artifactId><%=parent.artifactId%></artifactId>\r\n    <version><%=parent.version%></version>\r\n  </parent>\r\n<%} -%>\r\n  <groupId><%=groupId%></groupId>\r\n  <artifactId><%=artifactId%></artifactId>\r\n  <version><%=version%></version>\r\n  <packaging><%=packaging%></packaging>\r\n  <name><%=name%></name>\r\n  <description><%=description%></description>\r\n\r\n<% if(projects && projects.length > 0){ %> \r\n    <modules>\r\n      <% projects.forEach(function(project){ %>\r\n      <module><%= project.directory ? project.directory : project.artifactId %></module><%}); %> \r\n    </modules>  \r\n<%}%>\r\n    <properties>\r\n        <boost.version>1.57.0+nar.10</boost.version>\r\n        <nar-plugin.version>3.3.0</nar-plugin.version>\r\n        <compiler-name>g++</compiler-name>\r\n        <linker-name>g++</linker-name>\r\n    </properties>\r\n\r\n    <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>com.github.maven-nar</groupId>\r\n                <artifactId>nar-maven-plugin</artifactId>\r\n                <version>${nar-plugin.version}</version>\r\n                <extensions>true</extensions>\r\n                <configuration>\r\n                    <libraries>\r\n                        <library> \r\n                            <type>static</type>\r\n                        </library>\r\n                    </libraries>\r\n                    <cpp>\r\n                        <name>${compiler-name}</name>\r\n                        <debug>false</debug>\r\n                        <includes>\r\n                            <include>**/*.hpp</include>\r\n                            <include>**/*.h</include>\r\n                            <include>**/*.cpp</include>\r\n                            <include>**/*.c</include>\r\n                        </includes>\r\n                        <options combine.children=\"append\">\r\n                            <!--option>-std=c++11</option-->\r\n                            <option>-ftemplate-depth-128</option>\r\n                            <option>-fno-inline</option>\r\n                            <option>-Wall</option>\r\n                            <option>-pedantic</option>\r\n                            <option>-Wno-long-long</option>\r\n                            <option>-Wno-variadic-macros</option>\r\n                        </options>\r\n                        <defines>\r\n                          <!--define>USE_MYSQL_LOGGING</define-->\r\n                          <define>RTI_USES_STD_FSTREAM</define>\r\n                        </defines>\r\n                        <systemIncludePaths>\r\n                          <systemIncludePath>${build.BOOST_INC_DIR}</systemIncludePath>\r\n                          <systemIncludePath>${build.RTI_INC_DIR}</systemIncludePath>\r\n                        </systemIncludePaths>\r\n                    </cpp>\r\n                    <linker>\r\n                        <name>${linker-name}</name>\r\n                        <incremental>false</incremental>\r\n                        <libs>\r\n                          <lib>\r\n                            <name>RTI-NG_64d</name>\r\n                            <type>shared</type>\r\n                            <directory>${build.RTI_LIB_DIR}</directory>\r\n                          </lib>\r\n                          <lib>\r\n                            <name>FedTime_64d</name>\r\n                            <type>shared</type>\r\n                            <directory>${build.RTI_LIB_DIR}</directory>\r\n                          </lib>\r\n                          <lib>\r\n                            <name>boost_thread</name>\r\n                            <type>shared</type>\r\n                            <directory>${build.BOOST_LIB_DIR}</directory>\r\n                          </lib>\r\n                          <lib>\r\n                            <name>boost_system</name>\r\n                            <type>shared</type>\r\n                            <directory>${build.BOOST_LIB_DIR}</directory>\r\n                          </lib>\r\n                          <lib>\r\n                            <name>mysqlcppconn</name>\r\n                            <type>shared</type>\r\n                            <directory>${build.MYSQL_LIB_DIR}</directory>\r\n                          </lib>\r\n                          <lib>\r\n                                <name>jvm</name>\r\n                                <type>shared</type>\r\n                                <directory>${build.RTI_LIB_JVM_DIR}</directory>\r\n                            </lib>\r\n                        </libs>\r\n                        \r\n                    </linker>\r\n                </configuration>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n\r\n\r\n    <profiles>\r\n        <profile>\r\n          <id>include-generated</id>\r\n          <activation>\r\n                <activeByDefault>false</activeByDefault>\r\n            </activation>\r\n          <modules>\r\n              <module>HelloWorld_base-cpp</module>   \r\n          </modules>  \r\n        </profile>\r\n\r\n        <profile>\r\n            <id>windows-common</id>\r\n            <activation>\r\n                <os>\r\n                    <family>windows</family>\r\n                </os>\r\n            </activation>\r\n            <properties>\r\n              <build.RTI_LIB_DIR>${env.RTI_LIB_DIR}</build.RTI_LIB_DIR>\r\n              <build.RTI_INC_DIR>${env.RTI_HOME}/include/hla13</build.RTI_INC_DIR>\r\n              <build.BOOST_INC_DIR>${env.BOOST_INC_DIR}</build.BOOST_INC_DIR>\r\n              <build.BOOST_LIB_DIR>${env.BOOST_LIB_DIR}</build.BOOST_LIB_DIR>\r\n              <build.MYSQL_LIB_DIR>${env.MYSQL_LIB_DIR}</build.MYSQL_LIB_DIR>\r\n            </properties>\r\n            <build>\r\n                <plugins>\r\n                    <plugin>\r\n                        <groupId>com.github.maven-nar</groupId>\r\n                        <artifactId>nar-maven-plugin</artifactId>\r\n                        <extensions>true</extensions>\r\n                        <configuration>\r\n                            <cpp>\r\n                                <options combine.children=\"append\">\r\n                                    <option>-mthreads</option>\r\n                                </options>\r\n                            </cpp>\r\n                        </configuration>\r\n                    </plugin>\r\n                </plugins>\r\n            </build>\r\n        </profile>\r\n\r\n        <profile>\r\n            <id>linux-common</id>\r\n            <activation>\r\n                <os>\r\n                    <family>linux</family>\r\n                </os>\r\n            </activation>\r\n            <properties>\r\n              <build.RTI_LIB_JVM_DIR>${env.RTI_HOME}/jre/lib/amd64/server</build.RTI_LIB_JVM_DIR>\r\n              <build.RTI_LIB_DIR>${env.RTI_HOME}/lib/gcc4</build.RTI_LIB_DIR>\r\n              <build.RTI_INC_DIR>${env.RTI_HOME}/include/hla13</build.RTI_INC_DIR>\r\n              <build.BOOST_INC_DIR>/usr/include/boost</build.BOOST_INC_DIR>\r\n              <build.BOOST_LIB_DIR>/usr/lib/x86_64-linux-gnu</build.BOOST_LIB_DIR>\r\n              <build.MYSQL_LIB_DIR>/usr/lib/</build.MYSQL_LIB_DIR>\r\n            </properties>\r\n            <build>\r\n                <plugins>\r\n                    <plugin>\r\n                        <groupId>com.github.maven-nar</groupId>\r\n                        <artifactId>nar-maven-plugin</artifactId>\r\n                        <extensions>true</extensions>\r\n                        <configuration>\r\n                            <cpp>\r\n                                <options combine.children=\"append\">\r\n                                    <option>-pthread</option>\r\n                                </options>\r\n                            </cpp>\r\n                        </configuration>\r\n                    </plugin>\r\n                </plugins>\r\n            </build>\r\n        </profile>\r\n\r\n        <profile>\r\n            <id>mac-common</id>\r\n            <activation>\r\n                <os>\r\n                    <family>mac</family>\r\n                </os>\r\n            </activation>\r\n            <properties>\r\n              <build.RTI_LIB_DIR>${env.RTI_LIB_DIR}</build.RTI_LIB_DIR>\r\n              <build.RTI_INC_DIR>${env.RTI_HOME}/include/hla13</build.RTI_INC_DIR>\r\n              <build.BOOST_INC_DIR>${env.BOOST_INC_DIR}</build.BOOST_INC_DIR>\r\n              <build.BOOST_LIB_DIR>${env.BOOST_LIB_DIR}</build.BOOST_LIB_DIR>\r\n              <build.MYSQL_LIB_DIR>${env.MYSQL_LIB_DIR}</build.MYSQL_LIB_DIR>\r\n            </properties>\r\n            <build>\r\n                <plugins>\r\n                    <plugin>\r\n                        <groupId>com.github.maven-nar</groupId>\r\n                        <artifactId>nar-maven-plugin</artifactId>\r\n                        <extensions>true</extensions>\r\n                        <configuration>\r\n                            <cpp>\r\n                                <options combine.children=\"append\">\r\n                                    <option>-pthread</option>\r\n                                </options>\r\n                            </cpp>\r\n                        </configuration>\r\n                    </plugin>\r\n                </plugins>\r\n            </build>\r\n        </profile>\r\n    </profiles>\r\n  \r\n</project>",
    "federate.hpp.ejs": "<%/* group cppfederate;\r\n\r\nfederate(\r\n\tsimname,\r\n\tclassname,\r\n\tisnonmapperfed,\r\n\ttimeconstrained,\r\n\ttimeregulating,\r\n\tlookahead,\r\n\tasynchronousdelivery,\r\n\tallinteractiondata,\r\n\tpublishedinteractiondata,\r\n\tsubscribedinteractiondata,\r\n\tallobjectdata,\r\n\tpublishedobjectdata,\r\n\tsubscribedobjectdata\r\n) ::= <<\r\n*/ -%>\r\n#ifndef _<%=classname%>Base_\r\n#define _<%=classname%>Base_\r\n\r\n// This code has been generated by the C2W code generator.\r\n// Do not edit manually!\r\n\r\n#include <vector>\r\n\r\n#include \"SynchronizedFederate.hpp\"\r\n#include \"SubscribedInteractionFilter.hpp\"\r\n\r\n<% allinteractiondata.forEach(function(interactiondata){ %>\r\n#include \"<%=interactiondata.name%>.hpp\"<%});%>\r\n<% allobjectdata.forEach(function(interactiondata){ %>\r\n#include \"<%=interactiondata.name%>.hpp\"<%});%>\r\n#include \"C2WLogger.hpp\"\r\n\r\nclass <%=classname%>Base : public SynchronizedFederate {\r\n\r\npublic:\r\n\ttypedef SynchronizedFederate Super;\r\n\t\r\n\r\n\ttypedef std::vector< std::string > ArgVector;\r\n\t\r\n\tstatic double getLookAhead( void ) {\r\n\t\tstatic double lookAhead = <%=lookahead%>;\r\n\t\treturn lookAhead;\r\n\t}\r\n\r\n\tvirtual ~<%=classname%>Base( void )\r\n\t throw (RTI::FederateInternalError) { }\r\n\r\nprivate:\r\n\tSubscribedInteractionFilter _subscribedInteractionFilter;\r\n\r\nprotected:\r\n\tvoid init( ArgVector argVector ) {\r\n\r\n\t\tcreateRTI();\r\n\t\tjoinFederation( argVector[ 0 ], argVector[ 1 ] );\r\n\t\t\r\n\t\tstd::string loglevel=\"\";\r\n\t\tArgVector loggerArgVector;\r\n\t\tif ( argVector.size() == 3 ) {\r\n\t\t\tloggerArgVector.push_back( argVector[ 2 ] );\r\n\t\t} else if ( argVector.size() > 3 ) {\r\n\t\t\tloggerArgVector.push_back( argVector[ 3 ] );\r\n\t\t}\r\n\t\t_logger->init(loggerArgVector);\r\n\t\t\r\n\t\tif ( argVector.size() == 5 ) {\r\n\t\t\tloglevel = argVector[ 4 ];\r\n\t\t}\r\n\t\t\t\r\n<% if(timeconstrained){ %>\r\n\t\tenableTimeConstrained();\r\n<%}%>\r\n\r\n<% if(timeregulating){ %>\r\n\t\tenableTimeRegulation( getLookAhead() );\r\n<%}%>\r\n\r\n<% if(asynchronousdelivery){ %>\r\n\t\tenableAsynchronousDelivery();\r\n<%}%>\r\n\r\n\r\n        // interaction pubsub\r\n        <% /*publishedinteractiondata:pubinter()*/ %>\r\n        <% publishedinteractiondata.forEach(function(interactiondata){ %>\r\n        <%=interactiondata.name%>::publish( getRTI() );<%});%>\r\n        <% /*subscribedinteractiondata:subinter()*/ %>  \r\n        <% subscribedinteractiondata.forEach(function(interactiondata){ %>  \r\n        <%=interactiondata.name%>::subscribe( getRTI() );\r\n\t\t_subscribedInteractionFilter.setFedFilters( <%=interactiondata.name%>::get_handle(), SubscribedInteractionFilter::<%=interactiondata.originFedFilter()%>, SubscribedInteractionFilter::<%=interactiondata.srcFedFilter()%> );<%});%>  \r\n\t\t\r\n\t\t// object pubsub\r\n        <% /*publishedobjectdata:pubobjectdata()*/ %>\r\n        <% publishedobjectdata.forEach(function(objectdata){ %>\r\n        <% objectdata.publishedAttributeData.forEach(function(attributedata){ %>\r\n        <%=objectdata.name%>::publish_<%=attributedata.name%>();<%});%>  \r\n        <%=objectdata.name%>::publish( getRTI() );<%});%>  \r\n\r\n        <% /*subscribedobjectdata:subobjectdata()*/ %> \r\n        <% subscribedobjectdata.forEach(function(objectdata){ %>\r\n        <% objectdata.subscribedAttributeData.forEach(function(attributedata){ %>\r\n        <%=objectdata.name%>::subscribe_<%=attributedata.name%>();<%});%> \r\n        <%=objectdata.name%>::subscribe( getRTI() );<%});%>  \r\n   \r\n        \r\n         // enable pubsub log\r\n         if( argVector.size() > 2 ){\r\n\t\t\t<% /*publishedinteractiondata:publoginter()*/ %>\r\n\t\t\t<% publishedinteractiondata.forEach(function(interactiondata){ %>\r\n\t\t\t<%=interactiondata.name%>::enablePublishLog(\"<%=interactiondata.name%>\", \"<%=classname%>\", \"<%=interactiondata.publishedLoglevel%>\", loglevel);<%});%>  \r\n\t\t\t<% /*subscribedinteractiondata:subloginter()*/ %>\r\n\t\t\t<% subscribedinteractiondata.forEach(function(interactiondata){ %>\r\n\t\t\t<%=interactiondata.name%>::enableSubscribeLog(\"<%=interactiondata.name%>\", \"<%=classname%>\", \"<%=interactiondata.subscribedLoglevel%>\", loglevel);<%});%>  \r\n\t\t\t<% /*publishedobjectdata:publogobject()*/ %>\r\n\t\t\t<% publishedobjectdata.forEach(function(objectdata){ %>\r\n\t\t\t<% objectdata.logPublishedAttributeData.forEach(function(attributedata){ %>\r\n\t\t\t<%=objectdata.name%>::enablePublishLog(\"<%=objectdata.name%>\", \"<%=attributedata.name%>\", \"<%= classname %>\", \"<%= objectdata.publishedLoglevel %>\", loglevel);<%});%><%});%>  \r\n\t\t\t<% /*subscribedobjectdata:sublogobject()*/ %>\r\n\t\t\t<% subscribedobjectdata.forEach(function(objectdata){ %>\r\n\t\t\t<% objectdata.logSubscribedAttributeData.forEach(function(attributedata){ %>\r\n\t\t\t<%=objectdata.name%>::enableSubscribeLog(\"<%=objectdata.name%>\", \"<%=attributedata.name%>\", \"<%= classname %>\", \"<%= objectdata.subscribedLoglevel %>\", loglevel);<%});%> <%});%>  \r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvoid init( int argc, char *argv[] ) {\r\n\t\tArgVector argVector;\r\n\t\tfor( int ix = 1 ; ix < argc ; ++ix ) argVector.push_back( argv[ ix ] );\r\n\t\tinit( argVector );\r\n\t}\r\n\t\r\n\tvoid init( const std::string &federation_id, const std::string &federate_id ) {\r\n\t\tArgVector argVector;\r\n\t\targVector.push_back( federation_id );\r\n\t\targVector.push_back( federate_id );\r\n\t\tinit( argVector );\r\n\t}\r\n\t\r\npublic:\t\r\n\t// default constructor\r\n\t<%=classname%>Base( void ) { }\r\n\t\r\n\t// constructor\r\n\t<%=classname%>Base( const std::string &federation_id, const std::string &federate_id ) { init( federation_id, federate_id ); }\r\n\r\n\t// constructor\t\r\n\t<%=classname%>Base( int argc, char *argv[] ) { init( argc, argv ); }\r\n\r\n\t<% /*publishedinteractiondata:create_interaction()*/ %>\r\n\t<% publishedinteractiondata.forEach(function(interactiondata){ %>\r\n\t<%=interactiondata.name%>SP create_<%=interactiondata.name%>( void ) {\r\n\t   <%=interactiondata.name%>SP interactionSP = <%=interactiondata.name%>::create();\r\n\t   interactionSP->set_sourceFed( getFederateId() );\r\n\t   interactionSP->set_originFed( getFederateId() );\r\n\t   return interactionSP;\r\n\t}<%});%>  \r\n\r\n    <% /*filter_interaction()*/ %>\r\n    virtual void receiveInteraction(\r\n\t RTI::InteractionClassHandle theInteraction,\r\n\t const RTI::ParameterHandleValuePairSet& theParameters,\r\n\t const RTI::FedTime& theTime,\r\n\t const char *theTag,\r\n\t RTI::EventRetractionHandle theHandle\r\n\t)\r\n\t throw ( RTI::InteractionClassNotKnown, RTI::InteractionParameterNotKnown, RTI::InvalidFederationTime, RTI::FederateInternalError) {\r\n\r\n\t\tif ( getMoreATRs() ) {\r\n\t\t\tInteractionRoot::SP interactionRootSP = InteractionRoot::create_interaction( theInteraction, theParameters, theTime );\r\n\t\t\tC2WInteractionRootSP c2wInteractionRootSP = boost::dynamic_pointer_cast< C2WInteractionRoot >( interactionRootSP );\r\n\t\t\tif ( c2wInteractionRootSP != 0 ) {\r\n\r\n\t            // Filter interaction if src/origin fed requirements (if any) are not met\r\n\t            if (  _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRootSP )  ) {\r\n\t            \treturn;\r\n\t            }\r\n\t        }\r\n\r\n\t        Super::receiveInteraction( theInteraction, theParameters, theTime, theTag, theHandle );\r\n\t    }\r\n\t}\r\n\r\n\tvirtual void receiveInteraction(\r\n\t RTI::InteractionClassHandle theInteraction,\r\n\t const RTI::ParameterHandleValuePairSet& theParameters,\r\n\t const char *theTag\r\n\t)\r\n\t throw ( RTI::InteractionClassNotKnown, RTI::InteractionParameterNotKnown, RTI::FederateInternalError) {\r\n\t\tif ( getMoreATRs() ) {\r\n\t\t\tInteractionRoot::SP interactionRootSP = InteractionRoot::create_interaction( theInteraction, theParameters );\r\n\t\t\tC2WInteractionRootSP c2wInteractionRootSP = boost::dynamic_pointer_cast< C2WInteractionRoot >( interactionRootSP );\r\n\t\t\tif ( c2wInteractionRootSP != 0 ) {\r\n\r\n\t            // Filter interaction if src/origin fed requirements (if any) are not met\r\n\t            if (  _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRootSP )  ) {\r\n\t            \treturn;\r\n\t            }\r\n\t        }\r\n\r\n\t\t\tSuper::receiveInteraction( theInteraction, theParameters, theTag );\r\n\t\t}\r\n\t}\r\n};\r\n\r\n#endif\r\n\r\n",
    "federate.java.ejs": "<%/* group federate;\r\n\r\nfederate(\r\n\tsimname,\r\n\tmelderpackagename,\r\n\tclassname,\r\n\tisnonmapperfed,\r\n\ttimeconstrained,\r\n\ttimeregulating,\r\n\tlookahead,\r\n\tasynchronousdelivery,\r\n\tpublishedinteractiondata,\r\n\tsubscribedinteractiondata,\r\n\tallinteractiondata,\r\n\tpublishedobjectdata,\r\n\tsubscribedobjectdata,\r\n\tallobjectdata\r\n) ::= <<\r\n*/ -%>\r\n// This code has been generated by the C2W code generator.\r\n// Do not edit manually!\r\n\r\npackage <%= simname %>;\r\n\r\nimport hla.rti.EventRetractionHandle;\r\nimport hla.rti.LogicalTime;\r\nimport hla.rti.ReceivedInteraction;\r\n\r\nimport c2w.hla.C2WInteractionRoot;\r\nimport c2w.hla.C2WLogger;\r\nimport c2w.hla.InteractionRoot;\r\nimport c2w.hla.SubscribedInteractionFilter;\r\nimport c2w.hla.SynchronizedFederate;\r\n\r\n\r\nimport c2w.hla.*;\r\n<% if(melderpackagename){ -%>\r\nimport <%= melderpackagename %>.<%= classname %>;\r\nimport <%= melderpackagename %>.<%= classname %>RTIFactory;\r\n<% } -%>\r\n\r\npublic class <%= classname %>Base extends <% if(melderpackagename) { %><%= classname %><% }else{ %>SynchronizedFederate<% } %> {\r\n\r\n<% if(melderpackagename){ -%>\r\n\tstatic {\r\n\t\t<%= classname %>RTIFactory rtiFactory = new <%= classname %>RTIFactory();\r\n<% /*allinteractiondata:setfactoryvar()*/ -%>\r\n\t\t<% allinteractiondata.forEach(function(rticlass){ %>\r\n\t\trtiFactory.set_<%= rticlass.name %>Interface( new <%= rticlass.name %>Melder() );<%});%>\r\n<% /*allobjectdata:setfactoryvar()*/ -%>\r\n\t\t<% allobjectdata.forEach(function(rticlass){ %>\r\n\t\trtiFactory.set_<%= rticlass.name %>Interface( new <%= rticlass.name %>Melder() );<%});%>\t\r\n\r\n\t\t<%= classname %>.set<%= classname %>RTIFactory( rtiFactory );\r\n\t}\r\n<% } -%>\r\n\tprivate SubscribedInteractionFilter _subscribedInteractionFilter = new SubscribedInteractionFilter();\r\n\t\r\n\t// constructor\r\n\tpublic <%= classname %>Base( String federation_id, String federate_id ) throws Exception {\r\n\t\r\n<% if(isnonmapperfed){ -%>\r\n\t\tsetLookahead( <%= lookahead %> );\r\n<% } -%>\r\n\t\tcreateRTI();\r\n\t\tjoinFederation( federation_id, federate_id );\r\n\r\n<% if(timeconstrained){ -%>\r\n\t\tenableTimeConstrained();\r\n<% } %>\r\n<% if(timeregulating){ -%>\r\n\t\tenableTimeRegulation( getLookahead() );\r\n<% } -%>\r\n<% if(asynchronousdelivery){ -%>\r\n\t\tenableAsynchronousDelivery();\r\n<% } -%>\r\n        // interaction pubsub\r\n<% /* publishedinteractiondata:pubinter() */ -%>\r\n        <% publishedinteractiondata.forEach(function(interactiondata){ %>\r\n        <%= interactiondata.name %>.publish( getRTI() );<%});%>\r\n<% /* subscribedinteractiondata:subinter() */ -%>\r\n        <% subscribedinteractiondata.forEach(function(interactiondata){ %>\r\n        <%= interactiondata.name %>.subscribe( getRTI() );\r\n        _subscribedInteractionFilter.setFedFilters( \r\n\t\t\t<%= interactiondata.name %>.get_handle(), \r\n\t\t\tSubscribedInteractionFilter.OriginFedFilter.<%= interactiondata.originFedFilter() %>, \r\n\t\t\tSubscribedInteractionFilter.SourceFedFilter.<%= interactiondata.srcFedFilter() %> \r\n\t\t);<%}); -%>\r\n\t\t\r\n\t\t// object pubsub\r\n<%/* publishedobjectdata:pubobjectdata() */ -%>\r\n        <% publishedobjectdata.forEach(function(objectdata){ %>\r\n        \t<% objectdata.publishedAttributeData.forEach(function(a){ %>\r\n        <%= objectdata.name %>.publish_<%= a.name %>();<%});%>\r\n        <%= objectdata.name %>.publish( getRTI() );\r\n        <%}); -%>\r\n<%/* subscribedobjectdata:subobjectdata() */ -%>\r\n        <% subscribedobjectdata.forEach(function(objectdata){ %>\r\n        \t<% objectdata.subscribedAttributeData.forEach(function(a){ %>\r\n        <%= objectdata.name %>.subscribe_<%= a.name %>();<%});%>\r\n        <%= objectdata.name %>.subscribe( getRTI() );\r\n        <%}); -%>\r\n        }\r\n        \r\n       // constructor\r\n\tpublic <%= classname %>Base(  String[] federationInfo ) throws Exception {\r\n\r\n<% if(isnonmapperfed){ -%>\r\n\t\tsetLookahead( <%= lookahead %> );\r\n<% } -%>\r\n\t\tcreateRTI();\r\n\t\tjoinFederation( federationInfo[ 0 ], federationInfo[ 1 ] );\r\n\r\n\t\tString loglevel = null;\r\n\t\tif(federationInfo.length == 3)\r\n\t\t\tC2WLogger.init( federationInfo[ 2 ] );\r\n\t\telse if(federationInfo.length > 3)\r\n\t\t\tC2WLogger.init( federationInfo[ 2 ], federationInfo[ 3 ] );\t\t\r\n\t\t\r\n\t\tif(federationInfo.length == 5)\r\n\t\t\tloglevel = federationInfo[ 4 ];\r\n\r\n<% if(timeconstrained){ -%>\r\n\t\tenableTimeConstrained();\r\n<% } -%>\r\n<% if(timeregulating){ -%>\r\n\t\tenableTimeRegulation( getLookahead() );\r\n<% } -%>\r\n<% if(asynchronousdelivery){ -%>\r\n\t\tenableAsynchronousDelivery();\r\n<% } -%>\r\n\r\n        // interaction pubsub\r\n<%/* publishedinteractiondata:pubinter() */ -%>\r\n<%publishedinteractiondata.forEach(function(interactiondata){ %>\r\n        <%= interactiondata.name %>.publish( getRTI() );<%}); %>\r\n<%/* subscribedinteractiondata:subinter() */ -%>\r\n<%subscribedinteractiondata.forEach(function(interactiondata){ %>\r\n        <%= interactiondata.name %>.subscribe( getRTI() );\r\n        _subscribedInteractionFilter.setFedFilters( \r\n\t\t\t<%= interactiondata.name %>.get_handle(), \r\n\t\t\tSubscribedInteractionFilter.OriginFedFilter.<%= interactiondata.originFedFilter() %>, \r\n\t\t\tSubscribedInteractionFilter.SourceFedFilter.<%= interactiondata.srcFedFilter() %> \r\n\t\t);<%}); -%>\r\n\t\t// object pubsub\r\n<%/* publishedobjectdata:pubobjectdata() */ -%>\r\n        <%publishedobjectdata.forEach(function(objectdata){ %>\r\n        \t<%objectdata.publishedAttributeData.forEach(function(a){%>\r\n        <%= objectdata.name %>.publish_<%= a.name %>();<% }); %>\r\n        <%= objectdata.name %>.publish( getRTI() );\r\n        <%}); -%>\r\n<%/* subscribedobjectdata:subobjectdata() */ -%>\r\n        <%subscribedobjectdata.forEach(function(objectdata){%>\r\n        \t<%objectdata.subscribedAttributeData.forEach(function(a){%>\r\n        <%= objectdata.name %>.subscribe_<%= a.name %>();<% }); %>\r\n        <%= objectdata.name %>.subscribe( getRTI() );\r\n        <%}); -%>\r\n\t\t// enable pubsub log\r\n\t\tif(federationInfo.length  > 2) {\r\n<%/* publishedinteractiondata:publoginter() */ -%>\r\n\t\t\t<%publishedinteractiondata.forEach(function(interactiondata){%>\r\n\t\t\t<%= interactiondata.name %>.enablePublishLog(\r\n\t\t\t\t\"<%= interactiondata.name %>\",\r\n\t\t\t\t\"<%= classname %>\",\r\n\t\t\t\t\"<%= interactiondata.publishedLoglevel %>\",\r\n\t\t\t\tloglevel);<%}); %>\r\n<%/* subscribedinteractiondata:subloginter() */ -%>\r\n\t\t\t<%subscribedinteractiondata.forEach(function(interactiondata){%>\r\n\t\t\t<%= interactiondata.name %>.enableSubscribeLog(\r\n\t\t\t\t\"<%= interactiondata.name %>\",\r\n\t\t\t\t\"<%= classname %>\", \r\n\t\t\t\t\"<%= interactiondata.subscribedLoglevel %>\", \r\n\t\t\t\tloglevel);<%}); %>\t\r\n<%/* publishedobjectdata:pubobjectinter() */ -%>\r\n\t\t\t<%publishedobjectdata.forEach(function(objectdata){%>\r\n\t        \t<%objectdata.logPublishedAttributeData.forEach(function(a){%>\r\n\t        <%= objectdata.name %>.enablePublishLog(\r\n\t        \t\"<%= objectdata.name %>\",\t\r\n\t        \t\"<%= a.name %>\",\r\n\t        \t\"<%= classname %>\",\r\n\t        \t\"<%= objectdata.publishedLoglevel %>\",\r\n\t        \tloglevel);<% }); %><%}); %>\r\n<%/* subscribedobjectdata:subobjectinter() */ -%>\r\n\t\t\t<%subscribedobjectdata.forEach(function(objectdata){%>\r\n        \t\t<%objectdata.logSubscribedAttributeData.forEach(function(a){%>\r\n\t        \t<%= objectdata.name %>.enableSubscribeLog(\r\n\t        \t\"<%= objectdata.name %>\",\t\r\n\t        \t\"<%= a.name %>\",\r\n\t        \t\"<%= classname %>\",\r\n\t        \t\"<%= objectdata.subscribedLoglevel %>\",\r\n\t        \tloglevel);<% }); %><%}); %>\r\n\t\t}\r\n\t\t\r\n\t}\r\n<%/* publishedinteractiondata:create_interaction() */ -%>\r\n\t<%publishedinteractiondata.forEach(function(interaction_data){%>\r\n\tpublic <%= interaction_data.name %> create_<%= interaction_data.name %>() {\r\n\t   <%= interaction_data.name%> interaction = new <%= interaction_data.name %>();\r\n\t   interaction.set_sourceFed( getFederateId() );\r\n\t   interaction.set_originFed( getFederateId() );\r\n\t   return interaction;\r\n\t}<%}); %>\r\n<%/* filter_interaction() */ -%>\r\n\t@Override\r\n\tpublic void receiveInteraction(\r\n\t int interactionClass, ReceivedInteraction theInteraction, byte[] userSuppliedTag\r\n\t) {\r\n\t\tInteractionRoot interactionRoot = InteractionRoot.create_interaction( interactionClass, theInteraction );\r\n\t\tif ( interactionRoot instanceof C2WInteractionRoot ) {\r\n\t\t\t\r\n\t\t\tC2WInteractionRoot c2wInteractionRoot = (C2WInteractionRoot)interactionRoot;\r\n\r\n\t        // Filter interaction if src/origin fed requirements (if any) are not met\r\n\t        if (  _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRoot )  ) {\r\n\t        \treturn;\r\n\t        } \r\n\t\t}\r\n\t\t\r\n\t\tsuper.receiveInteraction( interactionClass, theInteraction, userSuppliedTag );\t\t\t\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void receiveInteraction(\r\n\t int interactionClass,\r\n\t ReceivedInteraction theInteraction,\r\n\t byte[] userSuppliedTag,\r\n\t LogicalTime theTime,\r\n\t EventRetractionHandle retractionHandle\r\n\t) {\r\n\t\tInteractionRoot interactionRoot = InteractionRoot.create_interaction( interactionClass, theInteraction, theTime );\r\n\t\tif ( interactionRoot instanceof C2WInteractionRoot ) {\r\n\r\n\t\t\tC2WInteractionRoot c2wInteractionRoot = (C2WInteractionRoot)interactionRoot;\r\n\r\n\t        // Filter interaction if src/origin fed requirements (if any) are not met\r\n\t        if (  _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRoot )  ) {\r\n\t        \treturn;\r\n\t        } \r\n\t\t}\r\n\r\n\t\tsuper.receiveInteraction( interactionClass, theInteraction, userSuppliedTag, theTime, retractionHandle );\t\t\t\r\n\t}\r\n}\r\n",
    "federatebase.java.ejs": "<%/* group federate;\r\n\r\nfederate(\r\n    simname,\r\n    melderpackagename,\r\n    classname,\r\n    isnonmapperfed,\r\n    timeconstrained,\r\n    timeregulating,\r\n    lookahead,\r\n    asynchronousdelivery,\r\n    publishedinteractiondata,\r\n    subscribedinteractiondata,\r\n    allinteractiondata,\r\n    publishedobjectdata,\r\n    subscribedobjectdata,\r\n    allobjectdata\r\n) ::= <<\r\n*/ -%>\r\n// This code has been generated by the C2W code generator.\r\n// Do not edit manually!\r\n\r\npackage <%= simname %>;\r\n\r\nimport hla.rti.EventRetractionHandle;\r\nimport hla.rti.LogicalTime;\r\nimport hla.rti.ReceivedInteraction;\r\n\r\nimport c2w.hla.C2WInteractionRoot;\r\nimport c2w.hla.C2WLogger;\r\nimport c2w.hla.InteractionRoot;\r\nimport c2w.hla.SubscribedInteractionFilter;\r\nimport c2w.hla.SynchronizedFederate;\r\n\r\nimport c2w.hla.*;\r\n\r\n<% if(melderpackagename){ -%>\r\nimport <%= melderpackagename %>.<%= classname %>;\r\nimport <%= melderpackagename %>.<%= classname %>RTIFactory;\r\n<% } -%>\r\n\r\npublic class <%= classname %>Base extends <% if(melderpackagename) { %><%= classname %><% }else{ %>SynchronizedFederate<% } %> {\r\n\r\n<% if(melderpackagename){ -%>\r\n    static {\r\n        <%= classname %>RTIFactory rtiFactory = new <%= classname %>RTIFactory();\r\n<% /*allinteractiondata:setfactoryvar()*/ -%>\r\n        <% allinteractiondata.forEach(function(rticlass){ %>\r\n        rtiFactory.set_<%= rticlass.name %>Interface( new <%= rticlass.name %>Melder() );<%});%>\r\n<% /*allobjectdata:setfactoryvar()*/ -%>\r\n        <% allobjectdata.forEach(function(rticlass){ %>\r\n        rtiFactory.set_<%= rticlass.name %>Interface( new <%= rticlass.name %>Melder() );<%});%>    \r\n\r\n        <%= classname %>.set<%= classname %>RTIFactory( rtiFactory );\r\n    }\r\n<% } -%>\r\n    private SubscribedInteractionFilter _subscribedInteractionFilter = new SubscribedInteractionFilter();\r\n    \r\n    // constructor\r\n    public <%= classname %>Base( String federation_id, String federate_id ) throws Exception {\r\n    \r\n<% if(isnonmapperfed){ -%>\r\n        setLookahead( <%= lookahead %> );\r\n<% } -%>\r\n        createRTI();\r\n        joinFederation( federation_id, federate_id );\r\n\r\n<% if(timeconstrained){ -%>\r\n        enableTimeConstrained();\r\n<% } %>\r\n<% if(timeregulating){ -%>\r\n        enableTimeRegulation( getLookahead() );\r\n<% } -%>\r\n<% if(asynchronousdelivery){ -%>\r\n        enableAsynchronousDelivery();\r\n<% } -%>\r\n        // interaction pubsub\r\n<% /* publishedinteractiondata:pubinter() */ -%>\r\n        <% publishedinteractiondata.forEach(function(interactiondata){ %>\r\n        <%= interactiondata.name %>.publish( getRTI() );<%});%>\r\n<% /* subscribedinteractiondata:subinter() */ -%>\r\n        <% subscribedinteractiondata.forEach(function(interactiondata){ %>\r\n        <%= interactiondata.name %>.subscribe( getRTI() );\r\n        _subscribedInteractionFilter.setFedFilters( \r\n            <%= interactiondata.name %>.get_handle(), \r\n            SubscribedInteractionFilter.OriginFedFilter.<%= interactiondata.originFedFilter() %>, \r\n            SubscribedInteractionFilter.SourceFedFilter.<%= interactiondata.srcFedFilter() %> \r\n        );<%}); -%>\r\n        \r\n        // object pubsub\r\n<%/* publishedobjectdata:pubobjectdata() */ -%>\r\n        <% publishedobjectdata.forEach(function(objectdata){ %>\r\n            <% objectdata.publishedAttributeData.forEach(function(a){ %>\r\n        <%= objectdata.name %>.publish_<%= a.name %>();<%});%>\r\n        <%= objectdata.name %>.publish( getRTI() );\r\n        <%}); -%>\r\n<%/* subscribedobjectdata:subobjectdata() */ -%>\r\n        <% subscribedobjectdata.forEach(function(objectdata){ %>\r\n            <% objectdata.subscribedAttributeData.forEach(function(a){ %>\r\n        <%= objectdata.name %>.subscribe_<%= a.name %>();<%});%>\r\n        <%= objectdata.name %>.subscribe( getRTI() );\r\n        <%}); -%>\r\n        }\r\n        \r\n       // constructor\r\n    public <%= classname %>Base(  String[] federationInfo ) throws Exception {\r\n\r\n<% if(isnonmapperfed){ -%>\r\n        setLookahead( <%= lookahead %> );\r\n<% } -%>\r\n        createRTI();\r\n        joinFederation( federationInfo[ 0 ], federationInfo[ 1 ] );\r\n\r\n        String loglevel = null;\r\n        if(federationInfo.length == 3)\r\n            C2WLogger.init( federationInfo[ 2 ] );\r\n        else if(federationInfo.length > 3)\r\n            C2WLogger.init( federationInfo[ 2 ], federationInfo[ 3 ] );        \r\n        \r\n        if(federationInfo.length == 5)\r\n            loglevel = federationInfo[ 4 ];\r\n\r\n<% if(timeconstrained){ -%>\r\n        enableTimeConstrained();\r\n<% } -%>\r\n<% if(timeregulating){ -%>\r\n        enableTimeRegulation( getLookahead() );\r\n<% } -%>\r\n<% if(asynchronousdelivery){ -%>\r\n        enableAsynchronousDelivery();\r\n<% } -%>\r\n\r\n        // interaction pubsub\r\n<%/* publishedinteractiondata:pubinter() */ -%>\r\n<%publishedinteractiondata.forEach(function(interactiondata){ %>\r\n        <%= interactiondata.name %>.publish( getRTI() );<%}); %>\r\n<%/* subscribedinteractiondata:subinter() */ -%>\r\n<%subscribedinteractiondata.forEach(function(interactiondata){ %>\r\n        <%= interactiondata.name %>.subscribe( getRTI() );\r\n        _subscribedInteractionFilter.setFedFilters( \r\n            <%= interactiondata.name %>.get_handle(), \r\n            SubscribedInteractionFilter.OriginFedFilter.<%= interactiondata.originFedFilter() %>, \r\n            SubscribedInteractionFilter.SourceFedFilter.<%= interactiondata.srcFedFilter() %> \r\n        );<%}); -%>\r\n        // object pubsub\r\n<%/* publishedobjectdata:pubobjectdata() */ -%>\r\n        <%publishedobjectdata.forEach(function(objectdata){ %>\r\n            <%objectdata.publishedAttributeData.forEach(function(a){%>\r\n        <%= objectdata.name %>.publish_<%= a.name %>();<% }); %>\r\n        <%= objectdata.name %>.publish( getRTI() );\r\n        <%}); -%>\r\n<%/* subscribedobjectdata:subobjectdata() */ -%>\r\n        <%subscribedobjectdata.forEach(function(objectdata){%>\r\n            <%objectdata.subscribedAttributeData.forEach(function(a){%>\r\n        <%= objectdata.name %>.subscribe_<%= a.name %>();<% }); %>\r\n        <%= objectdata.name %>.subscribe( getRTI() );\r\n        <%}); -%>\r\n        // enable pubsub log\r\n        if(federationInfo.length  > 2) {\r\n<%/* publishedinteractiondata:publoginter() */ -%>\r\n            <%publishedinteractiondata.forEach(function(interactiondata){%>\r\n            <%= interactiondata.name %>.enablePublishLog(\r\n                \"<%= interactiondata.name %>\",\r\n                \"<%= classname %>\",\r\n                \"<%= interactiondata.publishedLoglevel %>\",\r\n                loglevel);<%}); %>\r\n<%/* subscribedinteractiondata:subloginter() */ -%>\r\n            <%subscribedinteractiondata.forEach(function(interactiondata){%>\r\n            <%= interactiondata.name %>.enableSubscribeLog(\r\n                \"<%= interactiondata.name %>\",\r\n                \"<%= classname %>\", \r\n                \"<%= interactiondata.subscribedLoglevel %>\", \r\n                loglevel);<%}); %>    \r\n<%/* publishedobjectdata:pubobjectinter() */ -%>\r\n            <%publishedobjectdata.forEach(function(objectdata){%>\r\n                <%objectdata.logPublishedAttributeData.forEach(function(a){%>\r\n            <%= objectdata.name %>.enablePublishLog(\r\n                \"<%= objectdata.name %>\",    \r\n                \"<%= a.name %>\",\r\n                \"<%= classname %>\",\r\n                \"<%= objectdata.publishedLoglevel %>\",\r\n                loglevel);<% }); %><%}); %>\r\n<%/* subscribedobjectdata:subobjectinter() */ -%>\r\n            <%subscribedobjectdata.forEach(function(objectdata){%>\r\n                <%objectdata.logSubscribedAttributeData.forEach(function(a){%>\r\n                <%= objectdata.name %>.enableSubscribeLog(\r\n                \"<%= objectdata.name %>\",    \r\n                \"<%= a.name %>\",\r\n                \"<%= classname %>\",\r\n                \"<%= objectdata.subscribedLoglevel %>\",\r\n                loglevel);<% }); %><%}); %>\r\n        }\r\n        \r\n    }\r\n<%/* publishedinteractiondata:createInteraction() */ -%>\r\n    <%publishedinteractiondata.forEach(function(interaction_data){%>\r\n    public <%= interaction_data.name %> create_<%= interaction_data.name %>() {\r\n       <%= interaction_data.name%> interaction = new <%= interaction_data.name %>();\r\n       interaction.set_sourceFed( getFederateId() );\r\n       interaction.set_originFed( getFederateId() );\r\n       return interaction;\r\n    }<%}); %>\r\n\r\n<%/* filter_interaction() */ -%>\r\n    @Override\r\n    public void receiveInteraction(\r\n     int interactionClass, ReceivedInteraction theInteraction, byte[] userSuppliedTag\r\n    ) {\r\n        InteractionRoot interactionRoot = InteractionRoot.create_interaction( interactionClass, theInteraction );\r\n        if ( interactionRoot instanceof C2WInteractionRoot ) {\r\n            \r\n            C2WInteractionRoot c2wInteractionRoot = (C2WInteractionRoot)interactionRoot;\r\n\r\n            // Filter interaction if src/origin fed requirements (if any) are not met\r\n            if (  _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRoot )  ) {\r\n                return;\r\n            } \r\n        }\r\n        \r\n        super.receiveInteraction( interactionClass, theInteraction, userSuppliedTag );            \r\n    }\r\n\r\n    @Override\r\n    public void receiveInteraction(\r\n     int interactionClass,\r\n     ReceivedInteraction theInteraction,\r\n     byte[] userSuppliedTag,\r\n     LogicalTime theTime,\r\n     EventRetractionHandle retractionHandle\r\n    ) {\r\n        InteractionRoot interactionRoot = InteractionRoot.create_interaction( interactionClass, theInteraction, theTime );\r\n        if ( interactionRoot instanceof C2WInteractionRoot ) {\r\n\r\n            C2WInteractionRoot c2wInteractionRoot = (C2WInteractionRoot)interactionRoot;\r\n\r\n            // Filter interaction if src/origin fed requirements (if any) are not met\r\n            if (  _subscribedInteractionFilter.filterC2WInteraction( getFederateId(), c2wInteractionRoot )  ) {\r\n                return;\r\n            } \r\n        }\r\n\r\n        super.receiveInteraction( interactionClass, theInteraction, userSuppliedTag, theTime, retractionHandle );            \r\n    }\r\n}\r\n",
    "federateimpl.java.ejs": "package <%= simname %>;\r\n\r\nimport c2w.hla.InteractionRoot;\r\nimport c2w.hla.base.ObjectReflector;\r\nimport c2w.hla.ObjectRoot;\r\nimport c2w.hla.base.AdvanceTimeRequest;\r\n\r\nimport org.apache.logging.log4j.LogManager;\r\nimport org.apache.logging.log4j.Logger;\r\n/**\r\n * The federate federate for the federation federation designed in WebGME.\r\n *\r\n * This federate MUST join the federation before the federation manager starts the experiment.\r\n * This means that, when the federate joins, the federation logical time must be 0 and both\r\n * the readyToPopulate and the readyToRun synchronization points must be defined.\r\n */\r\npublic class <%= classname %> extends <%= classname %>Base {\r\n\r\n    private final static Logger log = LogManager.getLogger(<%= classname %>.class);\r\n    \r\n    public <%= classname %>(String[] args) throws Exception {\r\n        super(args);\r\n    }\r\n\r\n    private void execute() throws Exception {\r\n        double logicalTime = 0;\r\n        InteractionRoot interaction = null;\r\n        ObjectReflector reflector = null;\r\n        \r\n        /////////////////////////////////////////////\r\n        // TODO perform basic initialization below //\r\n        /////////////////////////////////////////////\r\n\r\n        AdvanceTimeRequest atr = new AdvanceTimeRequest(logicalTime);\r\n        putAdvanceTimeRequest(atr);\r\n\r\n        readyToPopulate();\r\n        ///////////////////////////////////////////////////////////////////////\r\n        // TODO perform initialization that depends on other federates below //\r\n        ///////////////////////////////////////////////////////////////////////\r\n        readyToRun();\r\n\r\n        startAdvanceTimeThread();\r\n    \r\n        while (true) {\r\n            //////////////////////////////////////////////////////////////\r\n            // TODO update step size for logical time progression below //\r\n            //////////////////////////////////////////////////////////////\r\n            logicalTime += 1.0;\r\n\r\n            atr.requestSyncStart();\r\n            <% if (publishedinteractiondata.length + publishedobjectdata.length > 0) { %>\r\n           ////////////////////////////////////////////////////////////////////////////////////////\r\n           // TODO send interactions and objects that must be sent every logical time step below //\r\n           ////////////////////////////////////////////////////////////////////////////////////////\r\n            <% } %>\r\n\r\n           <% if (subscribedinteractiondata.length > 0) { %>\r\n            <% var conditional = \"if\"; %>\r\n            while ((interaction = getNextInteractionNoWait()) != null) {\r\n                <% subscribedinteractiondata.forEach(function(interaction_data){ %>\r\n                <%= conditional %> (interaction instanceof <%= interaction_data.name %>) {\r\n                        handleInteractionClass((<%= interaction_data.name %>) interaction);\r\n                }\r\n            <% conditional = \"else if\"; %>\r\n            <% }) %>        \r\n            }\r\n           <% } %>\r\n           <%if (subscribedobjectdata.length > 0) { %>\r\n            <% conditional = \"if\"; %>\r\n            while ((reflector = getNextObjectReflectorNoWait()) != null) {\r\n                reflector.reflect();\r\n                ObjectRoot object = reflector.getObjectRoot();\r\n                <%subscribedobjectdata.forEach(function(object_data){ %>\r\n                <%= conditional %> (object instanceof <%= object_data.name %>) {\r\n                    handleObjectClass((<%= object_data.name %>) object);\r\n                }\r\n             <% conditional = \"else if\"; %>\r\n             <%}) %>\r\n            }\r\n           <% } %>\r\n            // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n            // DO NOT MODIFY FILE BEYOND THIS LINE\r\n            // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n            AdvanceTimeRequest newATR = new AdvanceTimeRequest(logicalTime);\r\n            putAdvanceTimeRequest(newATR);\r\n            atr.requestSyncEnd();\r\n            atr = newATR;\r\n        }\r\n    }\r\n    <%/* allinteractiondata:createInteraction() */ -%>\r\n        <%subscribedinteractiondata.forEach(function(interaction_data){ %>\r\n\r\n        private void handleInteractionClass(<%= interaction_data.name %> interaction) {\r\n            //////////////////////////////////////////////////////////////////////////\r\n            // TODO implement how to handle reception of the interaction            //\r\n            //////////////////////////////////////////////////////////////////////////\r\n        } <%}); %>\r\n\r\n    <%/* allobjectdata:createObject() */ -%>\r\n        <%subscribedobjectdata.forEach(function(object_data){ %>\r\n\r\n        private void handleObjectClass(<%= object_data.name %> object) {\r\n            //////////////////////////////////////////////////////////////////////////\r\n            // TODO implement how to handle reception of the object                 //\r\n            //////////////////////////////////////////////////////////////////////////\r\n        } <%}); %>\r\n\r\n    public static void main(String[] args) {\r\n        try {\r\n            <%= classname %> instance = new <%= classname %>(args);\r\n            instance.execute();\r\n        } catch (Exception e) {\r\n            System.err.println(\"Exception caught: \" + e.getMessage());\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}",
    "federateimpl_pom.xml.ejs": "<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\r\n\r\n    <modelVersion>4.0.0</modelVersion>\r\n    <parent>\r\n        <groupId><%= groupId %></groupId>\r\n        <artifactId><%= projectName %>-java</artifactId>\r\n        <version><%= projectVersion %></version>\r\n    </parent>\r\n    <artifactId><%= projectName %></artifactId>\r\n    <packaging>jar</packaging>\r\n\r\n    <properties>\r\n        <federation.name><%= projectName %></federation.name>\r\n        <package.name><%= projectName %></package.name>\r\n         <federate.name><%= classname %></federate.name>\r\n       <federation.version><%= projectVersion %></federation.version>\r\n        <c2w.version><%= c2wVersion %></c2w.version>\r\n        <nar.version>3.3.0</nar.version>\r\n    </properties>\r\n\r\n    <dependencies>\r\n        <dependency>\r\n            <groupId><%= groupId %></groupId>\r\n            <artifactId><%= projectName %>-base-java</artifactId>\r\n            <version><%= projectVersion %></version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId><%= groupId %></groupId>\r\n            <artifactId><%= projectName %>-rti-java</artifactId>\r\n            <version><%= projectVersion %></version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId><%= porticoPOM.groupId %></groupId>\r\n            <artifactId><%= porticoPOM.artifactId %></artifactId>\r\n            <version><%= porticoPOM.version %></version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.apache.logging.log4j</groupId>\r\n            <artifactId>log4j-api</artifactId>\r\n            <version>2.8.1</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>org.apache.logging.log4j</groupId>\r\n            <artifactId>log4j-core</artifactId>\r\n            <version>2.8.1</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>com.lmax</groupId>\r\n            <artifactId>disruptor</artifactId>\r\n            <version>3.3.6</version>\r\n        </dependency>\r\n        <dependency>\r\n            <groupId>junit</groupId>\r\n            <artifactId>junit</artifactId>\r\n            <version>4.7</version>\r\n            <scope>test</scope>\r\n        </dependency>\r\n    </dependencies>\r\n    \r\n    <build>\r\n        <plugins>\r\n            <plugin>\r\n                <groupId>org.apache.maven.plugins</groupId>\r\n                <artifactId>maven-shade-plugin</artifactId>\r\n                <version>2.4.3</version>\r\n                <executions>\r\n                    <execution>\r\n                        <phase>package</phase>\r\n                        <goals>\r\n                            <goal>shade</goal>\r\n                        </goals>\r\n                        <configuration>\r\n                            <transformers>\r\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\r\n                                <mainClass>${federation.name}.${federate.name}</mainClass>\r\n                                </transformer>\r\n                            </transformers>                            \r\n                              <filters>\r\n                                <filter>\r\n                                    <artifact>*:*</artifact>\r\n                                    <excludes>\r\n                                        <exclude>META-INF/*.SF</exclude>\r\n                                        <exclude>META-INF/*.DSA</exclude>\r\n                                        <exclude>META-INF/*.RSA</exclude>\r\n                                    </excludes>\r\n                                </filter>\r\n                            </filters>\r\n                        </configuration>\r\n                    </execution>\r\n                </executions>\r\n            </plugin>        \r\n            <plugin>\r\n              <groupId>org.apache.maven.plugins</groupId>\r\n              <artifactId>maven-surefire-plugin</artifactId>\r\n              <version>2.19.1</version>\r\n              <configuration>\r\n                <forkMode>once</forkMode>\r\n                <argLine>-Djava.library.path=${project.basedir}/target/nar/processid-${c2w.version}-amd64-Linux-gpp-jni/lib/amd64-Linux-gpp/jni/</argLine>\r\n              </configuration>\r\n            </plugin>\r\n            <plugin>\r\n                <groupId>com.github.maven-nar</groupId>\r\n                <artifactId>nar-maven-plugin</artifactId>\r\n                <version>${nar.version}</version>\r\n                <extensions>true</extensions>\r\n                <executions>\r\n                    <execution>\r\n                        <id>nar-download</id>\r\n                        <goals>\r\n                            <goal>nar-download</goal>\r\n                        </goals>\r\n                    </execution>\r\n                    <execution>\r\n                        <id>nar-unpack</id>\r\n                        <goals>\r\n                            <goal>nar-unpack</goal>\r\n                        </goals>\r\n                    </execution>\r\n                    <execution>\r\n                        <id>nar-test-unpack</id>\r\n                        <goals>\r\n                            <goal>nar-test-unpack</goal>\r\n                        </goals>\r\n                    </execution>\r\n                    <execution>\r\n                        <id>nar-integration-test</id>\r\n                        <goals>\r\n                            <goal>nar-integration-test</goal>\r\n                        </goals>\r\n                    </execution>\r\n                </executions>\r\n              </plugin>\r\n              <plugin>\r\n                <groupId>org.apache.maven.plugins</groupId>\r\n                <artifactId>maven-compiler-plugin</artifactId>\r\n                <version>3.5.1</version>\r\n                <configuration>\r\n                    <source>1.7</source>\r\n                    <target>1.7</target>\r\n                </configuration>\r\n            </plugin>\r\n        </plugins>\r\n    </build>\r\n\t<profiles>\r\n        <profile>\r\n            <id>${federate.name}</id>\r\n        </profile>\r\n\t\t<profile>\r\n\t\t\t<id>JavaFed</id>\r\n            <build>\r\n\t\t\t\t<plugins>\r\n\t\t\t\t\t<plugin>\r\n\t\t\t\t\t\t<groupId>org.codehaus.mojo</groupId>\r\n\t\t\t\t\t\t<artifactId>exec-maven-plugin</artifactId>\r\n\t\t\t\t\t\t<version>1.4.0</version>\r\n\t\t\t\t\t\t<configuration>\r\n\t\t\t\t\t\t\t<executable>java</executable>\r\n\t\t\t\t\t\t\t<arguments>\r\n\t\t\t\t\t\t\t\t<argument>-Xmx512m</argument>\r\n\t\t\t\t\t\t\t\t<!-- For debugging purposes-->\r\n\t\t\t\t\t\t\t\t<!--argument>-Xdiag</argument-->\r\n\t\t\t\t\t            <argument>-Djava.library.path=${project.basedir}/target/nar/processid-${c2w.version}-amd64-Linux-gpp-jni/lib/amd64-Linux-gpp/jni/</argument>\r\n\t\t\t\t\t            <argument>-Djava.net.preferIPv4Stack=true</argument>\r\n\t\t\t\t\t            <argument>-classpath</argument>\r\n\t\t\t\t\t            <!-- automatically creates the classpath using all project dependencies,\r\n\t\t                 \t\talso adding the project build directory -->\r\n\t\t\t\t\t            <classpath/>\r\n\t\t\t\t\t            <argument>${package.name}.${federate.name}</argument>\r\n\t\t\t\t\t            <argument>${federation.name}</argument>\r\n\t\t\t\t\t            <argument>${federate.name}</argument>\r\n\t\t\t\t\t            <argument>NORMAL</argument>\r\n\t\t\t\t\t    \t</arguments>\r\n\t\t\t\t\t\t    <environmentVariables>\r\n\t\t\t                    <EXEDIR>${project.basedir}/target/${federate.name}</EXEDIR>\r\n\t\t\t                </environmentVariables>\r\n\t\t\t\t\t\t</configuration>\r\n\t\t\t\t\t</plugin>\r\n\t\t\t\t</plugins>\r\n\t\t\t</build>\t\r\n\t\t</profile>\r\n    </profiles>\r\n</project>",
    "federatertifactory.java.ejs": "<% /*federatertifactory( melderpackagename, classname, allinteractiondata, allobjectdata ) ::= <<*/%>\r\npackage <%= melderpackagename %>;\r\n\r\npublic class <%=classname %> {\r\n\r\n\t<%/* allinteractiondata:interfacemember() */%>\r\n\tprivate <%=allinteractiondata.name %>Interface _<%=allinteractiondata.name %>_var;\r\n\t\r\n\t<%/*  allobjectdata:interfacemember() */%>\r\n\tprivate <%=allobjectdata.name %>Interface _<%=allobjectdata.name %>_var;\r\n\t\r\n\t<%/*  allinteractiondata:setinterfacemember() */%>\r\n\tpublic void set_<%= allinteractiondata.name  %>Interface( <%= allinteractiondata.name  %>Interface interface_var ) {\r\n\t\t_<%= allinteractiondata.name %>_var = interface_var;\r\n\t}\r\n\r\n\t<%/*  allobjectdata:setinterfacemember() */%>\r\n\tpublic void set_<%= allobjectdata.name  %>Interface( <%= allobjectdata.name  %>Interface interface_var ) {\r\n\t\t_<%= allobjectdata.name %>_var = interface_var;\r\n\t}\r\n\r\n\t<%/*  allinteractiondata:getinterfacemember() */%>\r\n\tpublic <%= allinteractiondata.name %>Interface get_<%= allinteractiondata.name %>Interface() {\r\n\t\treturn _<%= allinteractiondata.name %>_var;\r\n\t}\r\n\t\r\n\t<%/*  allobjectdata:getinterfacemember() */%>\r\n\tpublic <%= allobjectdata.name %>Interface get_<%= allobjectdata.name %>Interface() {\r\n\t\treturn _<%= allobjectdata.name %>_var;\r\n\t}\r\n}",
    "federate_ver.cpp.ejs": "#include <string>\r\n\r\nstatic const std::string _<%=simname%>_base_version_ = \"<%=version%>\";",
    "interfacecommon.java.ejs": "<% /*interfacecommon(isinteraction,classname,parentclassname,hlaclassname,datamembers,alldatamembers) */ %>\r\n\r\n/**\r\n* Returns the handle (RTI assigned) of this instance's <%=isinteraction?\"interaction\":\"object\"%> class .\r\n* \r\n* @return the handle (RTI assigned) if this instance's <%=isinteraction?\"interaction\":\"object\"%> class\r\n*/\r\npublic int getClassHandle();\r\n\r\n/**\r\n* Returns the fully-qualified (dot-delimited) name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class.\r\n* \r\n* @return the fully-qualified (dot-delimited) name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class\r\n*/\r\npublic String getClassName();\r\n\r\n/**\r\n* Returns the simple name (last name in its fully-qualified dot-delimited name)\r\n* of this instance's <%=isinteraction?\"interaction\":\"object\"%> class.\r\n* \r\n* @return the simple name of this instance's <%=isinteraction?\"interaction\":\"object\"%> class \r\n*/\r\npublic String getSimpleClassName();\r\n\r\n/**\r\n* Returns a set containing the names of all of the non-hidden<%=isinteraction?\"parameter\":\"attribute\"%>s of an\r\n* <%=isinteraction?\"interaction\":\"object\"%> class instance.\r\n*\r\n* @return set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\r\n* <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n*/\r\npublic Set< String > get<%=isinteraction?\"Parameter\":\"Attribute\"%>Names();\r\n\r\n/**\r\n* Returns a set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\r\n* <%=isinteraction?\"interaction\":\"object\"%> class instance.\r\n*\r\n* @return set containing the names of all of the <%=isinteraction?\"parameter\":\"attribute\"%>s of an\r\n* <%=isinteraction?\"interaction\":\"object\"%> class instance\r\n*/\r\npublic Set< String > getAll<%=isinteraction?\"Parameter\":\"Attribute\"%>Names();\r\n\r\n/**\r\n* Publishes the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of the class for a federate.\r\n*\r\n* @param rti handle to the RTI, usu. obtained through the\r\n* {@link SynchronizedFederate#getRTI()} call\r\n*/\r\npublic void publish<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti );\r\n\r\n/**\r\n* Unpublishes the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class for a federate.\r\n*\r\n* @param rti handle to the RTI, usu. obtained through the\r\n* {@link SynchronizedFederate#getRTI()} call\r\n*/\r\npublic void unpublish<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti );\r\n\r\n/**\r\n* Subscribes a federate to the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class.\r\n*\r\n* @param rti handle to the RTI, usu. obtained through the\r\n* {@link SynchronizedFederate#getRTI()} call\r\n*/\r\npublic void subscribe<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti );\r\n\r\n/**\r\n* Unsubscribes a federate from the <%=isinteraction?\"interaction\":\"object\"%> class of this instance of this class.\r\n*\r\n* @param rti handle to the RTI, usu. obtained through the\r\n* {@link SynchronizedFederate#getRTI()} call\r\n*/\r\npublic void unsubscribe<%=isinteraction?\"Interaction\":\"Object\"%>( RTIambassador rti );\r\n\r\n<% if(isinteraction){ %><% }else{ %>\r\n/**\r\n* Returns a data structure containing the handles of all attributes for this object\r\n* class that are currently marked for subscription.  To actually subscribe to these\r\n* attributes, a federate must call <objectclassname>.subscribe( RTIambassador rti ).\r\n*\r\n* @return data structure containing the handles of all attributes for this object\r\n* class that are currently marked for subscription\r\n*/\r\npublic AttributeHandleSet getSubscribedAttributeHandleSet();\r\n<%}%>",
    "interfaceroot.java.ejs": "<% /* classrootinterface(isinteraction)*/ %>\r\npackage c2w.hla;\r\n\r\nimport java.util.*;\r\nimport hla.rti.*;\r\n\r\npublic interface <%=isinteraction?\"Interaction\":\"Object\"%>RootInterface\r\n{\r\n    public int getUniqueID();\r\n\r\n    <%-ejs.render(\r\n        TEMPLATES[\"interfacecommon.java.ejs\"],{\r\n            isinteraction: isinteraction,\r\n            classname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\r\n            parentclassname: \"\",\r\n            hlaclassname: isinteraction?\"InteractionRoot\":\"ObjectRoot\",\r\n            datamembers: [],\r\n            alldatamembers: []\r\n    })%>\r\n\r\n    \r\n<% if(isinteraction){ %><%}else{%>\r\n    /**\r\n    * Requests an attribute update for this object instance from the federate that\r\n    * has modification rights on these attributes.\r\n    *\r\n    * @param rti handle to the RTI, usu. obtained through the\r\n    * {@link SynchronizedFederate#getRTI()} call\r\n    */\r\n    public void requestUpdate( RTIambassador rti );\r\n\r\n    /**\r\n    * Returns the handle (RTI assigned) the corresponds to this object class\r\n    * instance.  This handle is the instance's unique identifier to the RTI.\r\n    *\r\n    * @return the handle (RTI assigned) of this object class instance.\r\n    */\r\n    public int getObjectHandle();\r\n<%}%>\r\n\r\n    /**\r\n    * Returns the timestamp for this <%=isinteraction?\"interaction\":\"object\"%>.  \"receive order\" <%=isinteraction?\"interaction\":\"object\"%>s\r\n    * should have a timestamp of -1.\r\n    *\r\n    * @return timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\r\n    */\r\n    public double getTime();\r\n    \r\n    /**\r\n    * Sets the timestamp of this <%=isinteraction?\"interaction\":\"object\"%> to \"time\".\r\n    *\r\n    * @param time new timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\r\n    */\r\n    public void setTime( double time );\r\n\r\n    /**\r\n    * Sets the timestamp of this <%=isinteraction?\"interaction\":\"object\"%> to \"logicalTime\".\r\n    *\r\n    * @param logicalTime new timestamp for this <%=isinteraction?\"interaction\":\"object\"%>\r\n    */\r\n    public void setTime( LogicalTime logicalTime );\r\n\r\n    /**\r\n    * Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" for this\r\n    * <%=isinteraction?\"interaction\":\"object\"%>.\r\n    *\r\n    * @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value to retrieve\r\n    * @return the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose name is \"datamemberName\"\r\n    */\r\n    public Object get<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName );\r\n\r\n    /**\r\n    * Returns the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose handle is \"datamemberHandle\"\r\n    * (RTI assigned) for this <%=isinteraction?\"interaction\":\"object\"%>.\r\n    *\r\n    * @param datamemberHandle handle (RTI assigned) of <%=isinteraction?\"parameter\":\"attribute\"%> whose\r\n    * value to retrieve\r\n    * @return the value of the <%=isinteraction?\"parameter\":\"attribute\"%> whose handle is \"datamemberHandle\"\r\n    */\r\n    public Object get<%=isinteraction?\"Parameter\":\"Attribute\"%>( int datamemberHandle );\r\n        \r\n    /**\r\n    * Set the values of the <%=isinteraction?\"parameter\":\"attribute\"%>s in this <%=isinteraction?\"interaction\":\"object\"%> using\r\n    * \"datamemberMap\".  \"datamemberMap\" is usually acquired as an argument to\r\n    * an RTI federate callback method such as \"receiveInteraction\".\r\n    *\r\n    * @param datamemberMap  contains new values for the <%=isinteraction?\"parameter\":\"attribute\"%>s of\r\n    * this <%=isinteraction?\"interaction\":\"object\"%>\r\n    */\r\n    public void set<%=isinteraction?\"Parameter\":\"Attribute\"%>s( <%=isinteraction?\"ReceivedInteraction\":\"ReflectedAttributes\"%> datamemberMap );\r\n\r\n    /**\r\n    * Sets the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" to \"value\"\r\n    * in this <%=isinteraction?\"interaction\":\"object\"%>.  \"value\" is converted to data type of \"datamemberName\"\r\n    * if needed.\r\n    * This action can also be affected by calling the set_<datamemberName>( value )\r\n    * method on the <%=isinteraction?\"interaction\":\"object\"%> using a reference to the <%=isinteraction?\"interaction\":\"object\"%>'s actual\r\n    * class.\r\n    *\r\n    * @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be set\r\n    * to \"value\"\r\n    * @param value new value of <%=isinteraction?\"parameter\":\"attribute\"%> called \"datamemberName\"\r\n    */\r\n    public void set<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName, String value );\r\n\r\n    /**\r\n    * Sets the value of the <%=isinteraction?\"parameter\":\"attribute\"%> named \"datamemberName\" to \"value\"\r\n    * in this <%=isinteraction?\"interaction\":\"object\"%>.  \"value\" should have the same data type as that of\r\n    * the \"datamemberName\" <%=isinteraction?\"parameter\":\"attribute\"%>.\r\n    * This action can also be affected by calling the set_<datamemberName>( value )\r\n    * method on the <%=isinteraction?\"interaction\":\"object\"%> using a reference to the <%=isinteraction?\"interaction\":\"object\"%>'s actual\r\n    * class.\r\n    *\r\n    * @param datamemberName name of <%=isinteraction?\"parameter\":\"attribute\"%> whose value is to be set\r\n    * to \"value\"\r\n    * @param value new value of <%=isinteraction?\"parameter\":\"attribute\"%> called \"datamemberName\"\r\n    */\r\n    public void set<%=isinteraction?\"Parameter\":\"Attribute\"%>( String datamemberName, Object value );\r\n\r\n<% if(isinteraction){ %>\r\n    /**\r\n    * Sends this interaction to the RTI, with the specified timestamp \"time\".\r\n    * This method should be used to send interactions that have \"timestamp\"\r\n    * ordering.\r\n    *\r\n    * @param rti handle to the RTI, usu. obtained through the\r\n    * {@link SynchronizedFederate#getRTI()} call\r\n    * @param time timestamp for this interaction.  The timestamp should be no\r\n    * less than the current federation time + the LOOKAHEAD value of the federate\r\n    * sending this interaction.\r\n    */\r\n    public void sendInteraction( RTIambassador rti, double time ) throws Exception;\r\n\r\n    /**\r\n    * Sends this interaction to the RTI (without a timestamp).\r\n    * This method should be used to send interactions that have \"receive\"\r\n    * ordering.\r\n    *\r\n    * @param rti handle to the RTI, usu. obtained through the\r\n    * {@link SynchronizedFederate#getRTI()} call\r\n    */\r\n    public void sendInteraction( RTIambassador rti ) throws Exception ;\r\n<%}else{%>\r\n    /**\r\n    * Registers this object with the RTI.  This method is usually called by a\r\n    * federate who \"owns\" this object, i.e. the federate that created it and\r\n    * has write-privileges to its attributes (so, it is responsible for updating\r\n    * these attribute and conveying their updated values to the RTI).\r\n    *\r\n    * @param rti handle to the RTI, usu. obtained through the\r\n    * {@link SynchronizedFederate#getRTI()} call\r\n    */ \r\n    public void registerObject( RTIambassador rti );\r\n    \r\n    /**\r\n    * Unregisters this object with the RTI.  The RTI will destroy all information\r\n    * it contains regarding this object as a result.  This method is usually\r\n    * called by a federate who \"owns\" this object, i.e. the federate that created\r\n    * it and has write-privileges to its attributes.\r\n    *\r\n    * @param rti handle to the RTI, usu. obtained through the\r\n    * {@link SynchronizedFederate#getRTI()} call\r\n    */ \r\n    public void unregisterObject( RTIambassador rti );\r\n\r\n    /**\r\n    * Broadcasts the attributes of this object and their values to the RTI, where\r\n    * the values have \"time\" as their timestamp.  This call should be used for\r\n    * objects whose attributes have \"timestamp\" ordering.\r\n    *\r\n    * @param rti handle to the RTI, usu. obtained through the\r\n    * {@link SynchronizedFederate#getRTI()} call\r\n    * @param time timestamp on attribute values of this object\r\n    * @param force if \"false\", only the attributes whose values have changed since\r\n    * the last call to \"updateAttributeValues\" will be broadcast to the RTI.  If\r\n    * \"true\", all attributes and their values are broadcast to the RTI.\r\n    */\r\n    public void updateAttributeValues( RTIambassador rti, double time, boolean force );\r\n\r\n    /**\r\n    * Like {@link #updateAttributeValues( RTIambassador rti, double time, boolean force )},\r\n    * except \"force\" is always false.\r\n    *\r\n    * @param rti handle to the RTI, usu. obtained through the\r\n    * {@link SynchronizedFederate#getRTI()} call\r\n    * @param time timestamp on attribute values of this object\r\n    */\r\n    public void updateAttributeValues( RTIambassador rti, double time );\r\n\r\n    /**\r\n    * Broadcasts the attributes of this object and their values to the RTI (with\r\n    * no timestamp).  This call should be used for objects whose attributes have\r\n    * \"receive\" ordering.\r\n    *\r\n    * @param rti handle to the RTI, usu. obtained through the\r\n    * {@link SynchronizedFederate#getRTI()} call\r\n    * @param force if \"false\", only the attributes whose values have changed since\r\n    * the last call to \"updateAttributeValues\" will be broadcast to the RTI.  If\r\n    * \"true\", all attributes and their values are broadcast to the RTI.\r\n    */\r\n    public void updateAttributeValues( RTIambassador rti, boolean force );\r\n\r\n    /**\r\n    * Like {@link #updateAttributeValues( RTIambassador rti, boolean force )},\r\n    * except \"force\" is always false.\r\n    *\r\n    * @param rti handle to the RTI, usu. obtained through the\r\n    * {@link SynchronizedFederate#getRTI()} call\r\n    */\r\n    public void updateAttributeValues( RTIambassador rti );    \r\n<%}%>    \r\n}",
    "log4j2.xml.ejs": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<Configuration status=\"TRACE\">\r\n\t<Appenders>\r\n\t\t<Console name=\"Console\" target=\"SYSTEM_OUT\">\r\n\t\t\t<PatternLayout pattern=\"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\" />\r\n\t\t</Console>\r\n\t\t<File name=\"File\" fileName=\"<%= projectName %>.log\" immediateFlush=\"false\"\r\n\t\t\tappend=\"false\">\r\n\t\t\t<PatternLayout\r\n\t\t\t\tpattern=\"%d{yyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\" />\r\n\t\t</File>\r\n\t</Appenders>\r\n\t<Loggers>\r\n\t\t<Root level=\"TRACE\">\r\n\t\t\t<AppenderRef ref=\"Console\" />\r\n <!--           \r\n \t\t\t<AppenderRef ref=\"File\"/>\r\n-->\t\t\t\r\n\t\t</Root>\r\n\t</Loggers>\r\n</Configuration>",
    "mapperfederate.java.ejs": "<% /*group mapperfederate;\r\n\r\nmapperfederate(\r\n    classname,\r\n\tsimname,\r\n\tstep_size,\r\n\tmappingconnsdata,\r\n\tmappingobjectsdata\r\n) ::= <<*/ -%>\r\n// This code has been generated by the C2W code generator.\r\n// Do not edit manually!\r\n\r\npackage <%=simname%>;\r\n\r\nimport java.util.StringTokenizer;\r\nimport java.util.regex.Pattern;\r\nimport java.util.regex.Matcher;\r\nimport hla.rti.EventRetractionHandle;\r\nimport hla.rti.LogicalTime;\r\nimport hla.rti.ReceivedInteraction;\r\nimport c2w.hla.*;\r\n\r\npublic class <%=classname%> extends <%=classname%>Base {\r\n\r\n    private static Pattern pattern = Pattern.compile( \"[^#]\" );\r\n\r\n\tpublic <%=classname%>(String federationId, String federateId)\r\n\t\t\tthrows Exception {\r\n\t\tsuper(federationId, federateId);\r\n\t}\r\n\r\n    public <%=classname%>( String[] args ) throws Exception {\r\n        super( args );\r\n    }\r\n    \r\n    private static double STEP_EPSILON = 0.000001;\r\n    \r\n    public boolean isMapperFederate() {\r\n        return true;\r\n    }\r\n\r\n    <% /*mappingconnsdata:mappingconnections()*/ %>\r\n    <% mappingconnsdata.forEach(function(mappingconnectiondata){ %>\r\n\t///////////////////////////////////////////////////////////////////////////////////////\r\n\t//\r\n\t// For <% if(mappingconnectiondata.isSimpleConn){ %>Simple<% }else{ %>Complex<% } %>MappingConnection (ID: <%=mappingconnectiondata.uniqueId%>) between interactions:\r\n\t//\r\n\t//         <%=mappingconnectiondata.lHSInteractionName%> --to--> <%=mappingconnectiondata.rHSInteractionName%>\r\n\t//\r\n\t// This <% if(mappingconnectiondata.isSimpleConn){ %>Simple<% }else{ %>Complex<% } %>MappingConnection is located at:\r\n\t//\r\n\t//         <%=mappingconnectiondata.parentPath%>\r\n\t//\r\n\t///////////////////////////////////////////////////////////////////////////////////////\r\n\tpublic boolean isGuardConditionMet_<%=mappingconnectiondata.lHSInteractionName%>_to_<%=mappingconnectiondata.rHSInteractionName%>_<%=mappingconnectiondata.uniqueId%>(<%=mappingconnectiondata.lHSInteractionName%> i1) {\r\n\t\t<%-mappingconnectiondata.guardCondition%>\r\n\t\t<% if(mappingconnectiondata.guardConditionInvalid){ %>return true;<% } %>\r\n\t}\r\n\r\n\r\n\tpublic <%=mappingconnectiondata.rHSInteractionName%> map_<%=mappingconnectiondata.lHSInteractionName%>_to_<%=mappingconnectiondata.rHSInteractionName%>_<%=mappingconnectiondata.uniqueId%>(<%=mappingconnectiondata.lHSInteractionName%> i1) {\r\n\t\t<%=mappingconnectiondata.rHSInteractionName%> o1 = create_<%=mappingconnectiondata.rHSInteractionName%>();\r\n\t\tInteractionRoot o1IR = (InteractionRoot) o1;\r\n\t    <% if(mappingconnectiondata.isMappedInteractionANetworkPacket){ %>\r\n\t\tboolean __NETWORK_PACKET_CORRUPT__ = false;\r\n\t\tInteractionRoot __I1__ = (InteractionRoot) i1;\r\n\t\tif(__I1__ instanceof NetworkPacket ) {\r\n\t    \tint numParams = o1.getParameterNames().size();\r\n\t    \tString __DATA__ = ((NetworkPacket) __I1__).get_data();\r\n\t    \tif(numParams > 0) {\r\n\t\t\t    Matcher matcher = pattern.matcher( __DATA__ );\r\n\t\t\t    if ( !matcher.find() ) {\r\n\t    \t\t\t__NETWORK_PACKET_CORRUPT__ = true;\r\n\t    \t\t\tif(o1IR instanceof NetworkPacket && __DATA__.length() == 0 ) {\r\n\t\t\t    \t\t__NETWORK_PACKET_CORRUPT__ = false;\r\n\t\t\t    \t}\r\n\t    \t\t}\r\n\t    \t} else {\r\n\t    \t\tif(__DATA__.length() > 0) {\r\n\t    \t\t\t__NETWORK_PACKET_CORRUPT__ = true;\r\n\t    \t\t}\r\n\t    \t}\r\n\t\t}\r\n\t\tif(!__NETWORK_PACKET_CORRUPT__) {\r\n\t\t    <% if(mappingconnectiondata.isMappingSpecsNotEmpty){ %>\r\n\t\t\t<%-mappingconnectiondata.mappingSpecs%><%}%>\r\n\t\t}\r\n\t\t<% }else{ %>\r\n\t    <% if(mappingconnectiondata.isMappingSpecsNotEmpty){ %>\r\n\t\t<%-mappingconnectiondata.mappingSpecs%><%}%>\r\n\t\t<%}%>\r\n\r\n\t\to1.set_originFed(i1.get_originFed());\r\n\t\to1.set_actualLogicalGenerationTime(i1.get_actualLogicalGenerationTime());\r\n\r\n\t\treturn o1;\r\n\t}\r\n    <%/*EMPTY*/});%>\r\n    \r\n    <% /*mappingobjectsdata:mappingobjects()*/ %>\r\n    <% mappingobjectsdata.forEach(function(mappingobjectdata){ %><%/*EMPTY*/});%>\r\n    \r\n\r\n\t<% /*execute_method()*/ %>\r\n\tpublic void execute() throws Exception {\r\n\t    double currentTime = 0;\r\n\r\n\t    AdvanceTimeRequest atr = new AdvanceTimeRequest( currentTime );\r\n\t    putAdvanceTimeRequest( atr );\r\n\r\n\t    readyToPopulate();\r\n\t    readyToRun();\r\n\r\n\t    startAdvanceTimeThread(TIME_ADVANCE_MODE.NEXT_EVENT_REQUEST_AVAILABLE);\r\n\r\n\t    while( true ) {\r\n\t    \tSystem.out.print( \"<%=classname%>: Requesting RTI to proceed to (\" + currentTime + \")...\" );\r\n\t    \t\r\n\t        atr.requestSyncStart();\r\n\t        currentTime = atr.getCurrentTime();\r\n\r\n\t        System.out.println( \"granted!\" );\r\n\r\n\t        InteractionRoot interactionRoot;\r\n\r\n\t        System.out.println(\"Now waiting to receive an interaction...\");\r\n\t        while(  ( interactionRoot = getNextInteractionNoWait() ) != null ) {\r\n\t            \t\r\n\t\t\t\tSystem.out.println( \"<%=classname%>: received interaction: \\\"\" + interactionRoot + \"\\\" at time: \" + getCurrentTime() );\r\n\r\n\t\t\t\tboolean interactionMapped = false;\t\t\t\r\n\t\t\t\t<% /*mappingconnsdata:mappingCheck()*/ %>\r\n\t\t\t\t<% mappingconnsdata.forEach(function(mappingconnectiondata){%>\r\n\t\t\t\tif( interactionRoot instanceof <%=mappingconnectiondata.lHSInteractionName%> ) {\r\n\t\t\t\t\t<%=mappingconnectiondata.lHSInteractionName%> i1 = (<%=mappingconnectiondata.lHSInteractionName%>) interactionRoot;\r\n\t\t\t\t\t\r\n\t\t\t\t\t\tif(  !(interactionRoot instanceof NetworkPacket) || \"<%=mappingconnectiondata.rHSInteractionName%>\".equals(((NetworkPacket) interactionRoot).get_packetType())  ) {\r\n\t\r\n\t\t\t\t\t\t\tif( isGuardConditionMet_<%=mappingconnectiondata.lHSInteractionName%>_to_<%=mappingconnectiondata.rHSInteractionName%>_<%=mappingconnectiondata.uniqueId%>(i1) ) {\r\n\t\t\t\t\t\t\t\t<%=mappingconnectiondata.rHSInteractionName%> o1 = map_<%=mappingconnectiondata.lHSInteractionName%>_to_<%=mappingconnectiondata.rHSInteractionName%>_<%=mappingconnectiondata.uniqueId%>(i1);\r\n\t\t\t\t\t\t\t\tSystem.out.println( \"<%=classname%>: Sending interaction: \" + o1 );\r\n\t\t\t\t\t\t\t\to1.sendInteraction( getRTI(), getMinTSOTimestamp() );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tinteractionMapped = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\t<% if(mappingconnectiondata.areBothEndsOfMappingANetworkPacket){ %>\r\n\t\t\t\t\t\t// Or, if it is a mapping from an interaction type to itself then only check the guard condition\r\n\t\t\t\t\t\tif ( interactionRoot instanceof NetworkPacket && \"<%=mappingconnectiondata.lHSInteractionName%>\".equals(\"<%=mappingconnectiondata.rHSInteractionName%>\") ) {\r\n\t\t\t\t\t\t\tif( isGuardConditionMet_NetworkPacket_to_NetworkPacket_<%=mappingconnectiondata.uniqueId%>(i1) ) {\r\n\t\t\t\t\t\t\t\tNetworkPacket o1 = map_NetworkPacket_to_NetworkPacket_<%=mappingconnectiondata.uniqueId%>(i1);\r\n\t\t\t\t\t\t\t\tSystem.out.println( \"<%=classname%>: Sending interaction: \" + o1 );\r\n\t\t\t\t\t\t\t\to1.sendInteraction( getRTI(), getMinTSOTimestamp() );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\tinteractionMapped = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t<% } %>\r\n\t\t\t\t}<%});%>\r\n\r\n\t\t\t\tif( !interactionMapped ) {\r\n\t          \t\tSystem.out.println( \"<%=classname%>: Received unknown interaction: \" + interactionRoot );\r\n\t           \t}\r\n\t        }\r\n\r\n\t        currentTime = getCurrentTime() + <%=step_size%> + STEP_EPSILON;\r\n\t        AdvanceTimeRequest newATR = new AdvanceTimeRequest( currentTime );\r\n\t        putAdvanceTimeRequest( newATR );\r\n\t        \r\n\t        atr.requestSyncEnd();\r\n\t        atr = newATR;\r\n\t    }\r\n\t}\r\n\r\n\t<% /*main_method()*/ %>\r\n\t/**\r\n\t * @param args\r\n\t */\r\n\tpublic static void main(String[] args) {\r\n\t    System.out.println( \"<%=classname%> federate starting\" );\r\n\t    try {\r\n\t    \t<%=classname%> mapperFed = new <%=classname%>( args );\r\n\t        mapperFed.execute();\r\n\t    } catch ( Exception e ) {\r\n\t        System.err.println( \"Exception caught: \" + e.getMessage() );\r\n\t        e.printStackTrace();\r\n\t    }\r\n\t}\r\n\r\n}\r\n",
    "omnetfilter.cpp.ejs": "<% /*FilterInitSource( projectname, subscribedinteractiondata ) ::= << */ %>\r\n/*\r\n * Copyright (c) 2016, Institute for Software Integrated Systems, Vanderbilt University\r\n * All rights reserved.\r\n *\r\n * Permission to use, copy, modify, and distribute this software and its\r\n * documentation for any purpose, without fee, and without written agreement is\r\n * hereby granted, provided that the above copyright notice, the following\r\n * two paragraphs and the author appear in all copies of this software.\r\n *\r\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\r\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\r\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\r\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\r\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\r\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\r\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\r\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\r\n *\r\n * @author Himanshu Neema\r\n */\r\n\r\n#include \"<%=projectname%>FilterInit.h\"\r\n#include \"OmnetFOMInteractions.h\"\r\n//#include \"<%=projectname%>NonOmnetNonGenericSources.hpp\"\r\n\r\nvoid <%=projectname%>FilterInit::execute( SubscribedInteractionFilter &subscribedInteractionFilter ) {\r\n\t<% /*subscribedinteractiondata:initInteractionFilter()*/ %>\r\n\t<% subscribedinteractiondata.forEach(function(subscribedinteractiondata){%>\r\n\tsubscribedInteractionFilter.setFedFilters( <%=subscribedinteractiondata.name%>::get_handle(), SubscribedInteractionFilter::<%=subscribedinteractiondata.originFedFilter()%>, SubscribedInteractionFilter::<%=subscribedinteractiondata.srcFedFilter()%> );<%});%>\r\n\r\n}\r\n\r\nstatic bool init( void ) {\r\n    SubscribedInteractionFilter::get_singleton().setFilterInit( <%=projectname%>FilterInit::create() );\r\n    return true;\r\n}\r\n\r\nstatic bool static_init = init();\r\n\r\n\r\n",
    "omnetfilter.hpp.ejs": "<% /* FilterInitHeader( projectname, subscribedinteractiondata ) ::= << */ %>\r\n/*\r\n * Copyright (c) 2016, Institute for Software Integrated Systems, Vanderbilt University\r\n * All rights reserved.\r\n *\r\n * Permission to use, copy, modify, and distribute this software and its\r\n * documentation for any purpose, without fee, and without written agreement is\r\n * hereby granted, provided that the above copyright notice, the following\r\n * two paragraphs and the author appear in all copies of this software.\r\n *\r\n * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR\r\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\r\n * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT\r\n * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,\r\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\r\n * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\r\n * ON AN \"AS IS\" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO\r\n * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\r\n *\r\n * @author Himanshu Neema\r\n */\r\n#ifndef _ISIS_<%=projectname%>_H_\r\n#define _ISIS_<%=projectname%>_H_\r\n\r\n#include \"SubscribedInteractionFilter.hpp\"\r\n\r\nstruct <%=projectname%>FilterInit : public SubscribedInteractionFilter::FilterInit {\r\n    static SP create( void ) { return SP( new <%=projectname%>FilterInit() ); }\r\n\r\n    virtual void execute( SubscribedInteractionFilter &subscribedInteractionFilter );\r\n};\r\n\r\n#endif\r\n"
}});