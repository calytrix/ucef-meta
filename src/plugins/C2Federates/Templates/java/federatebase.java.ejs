<% /* ////////////////////////////////////////////////////////////////////////////////////// */ -%>
<% /* This template generates the Java code for the implementation of the federate           */ -%>
<% /* "helper" class located in the "base" package of the generated file set, as indicated   */ -%>
<% /* by the item marked with '*****' below                                                  */ -%>
<% /*                                                                                        */ -%>
<% /*     [top]                                                                              */ -%>
<% /*         base                                                                           */ -%>
<% /*             _SomeFederate.java     *****                                               */ -%>
<% /*         interactions                                                                   */ -%>
<% /*             SomeInteractionA.java                                                      */ -%>
<% /*             SomeInteractionB.java                                                      */ -%>
<% /*             ...                                                                        */ -%>
<% /*         reflections                                                                    */ -%>
<% /*             SomeReflectionA.java                                                       */ -%>
<% /*             SomeReflectionB.java                                                       */ -%>
<% /*             ...                                                                        */ -%>
<% /*         SomeFederate.java                                                              */ -%>
<% /* ////////////////////////////////////////////////////////////////////////////////////// */ -%>
<%/* group federate;
federate(
        simname,
        melderpackagename,
        classname,
        isnonmapperfed,
        timeconstrained,
        timeregulating,
        asynchronousdelivery,
        publishedinteractiondata,
        subscribedinteractiondata,
        allinteractiondata,
        publishedobjectdata,
        subscribedobjectdata,
        allobjectdata
) ::= <<
*/ -%>
/*
 * This software is contributed as a public service by The National Institute of Standards
 * and Technology (NIST) and is not subject to U.S. Copyright
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this
 * software and associated documentation files (the "Software"), to deal in the Software
 * without restriction, including without limitation the rights to use, copy, modify,
 * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above NIST contribution notice and this permission and disclaimer notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
 * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. THE AUTHORS OR COPYRIGHT HOLDERS SHALL
 * NOT HAVE ANY OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 * MODIFICATIONS.
 */
package <%= groupId %>.<%= classname.toLowerCase() %>.base;

import gov.nist.ucef.hla.base.HLAInteraction;
import gov.nist.ucef.hla.base.HLAObject;
import gov.nist.ucef.hla.ucef.NoOpFederate;

<% if( subscribedinteractiondata.length ){ subscribedinteractiondata.map(x=>x.name).sort().forEach( function ( className, idx ) { -%>
import <%= groupId %>.interactions.<%= className %>;
<% }); } -%>
<% if( subscribedinteractiondata.length ){ subscribedobjectdata.map(x=>x.name).sort().forEach( function ( className, idx ) { -%>
import <%= groupId %>.reflections.<%= className %>;
<% }); } -%>

/**
 *                    ___
 *                  _/   \_     _     _
 *                 / \   / \   / \   / \
 *                ( U )─( C )─( E )─( F )
 *                 \_/   \_/   \_/   \_/
 *                <─┴─> <─┴─────┴─────┴─>
 *               Universal CPS Environment
 *                     for Federation
 */
public abstract class _<%= classname %> extends NoOpFederate
{
    //----------------------------------------------------------
    //                   STATIC VARIABLES
    //----------------------------------------------------------

    //----------------------------------------------------------
    //                   INSTANCE VARIABLES
    //----------------------------------------------------------

    //----------------------------------------------------------
    //                      CONSTRUCTORS
    //----------------------------------------------------------
    public _<%= classname %>()
    {
        super();
    }

    //----------------------------------------------------------
    //                    INSTANCE METHODS
    //----------------------------------------------------------

    ////////////////////////////////////////////////////////////////////////////////////////////
    /////////////////////////////////// RTI Callback Methods ///////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////
<% if( subscribedinteractiondata.length > 0 ) { -%>
    @Override
    public void receiveInteraction( HLAInteraction hlaInteraction )
    {
        String interactionClassName = hlaInteraction.getInteractionClassName();
        <% subscribedinteractiondata.map(x=>x.name).forEach( function ( className, idx ) { -%>
<% if( idx > 0 ) { -%>else <% } -%>if( <%= className %>.interactionClassName().equals( interactionClassName ) )

        {
            receive<%= className %>Interaction( new <%= className %>( hlaInteraction ) );
        }
<% }); -%>
        else
        {
            // this is unexpected - we shouldn't receive any thing we didn't subscribe to
            System.err.println( String.format( "Received an unexpected interaction of type '%s'",
                                                interactionClassName ) );
        }
    }
<% } -%>

<% if( subscribedobjectdata.length > 0 ) { -%>
    @Override
    public void receiveAttributeReflection( HLAObject hlaObject )
    {
        String objectClassName = hlaObject.getObjectClassName();
        <% subscribedobjectdata.map(x=>x.name).forEach( function ( className, idx ) { -%>
<% if( idx > 0 ) { %>else <% } %>if( <%= className %>.objectClassName().equals( objectClassName ) )
        {
            receive<%= className %>Update( new <%= className %>( hlaObject ) );
        }
<%}); -%>
        else
        {
            // this is unexpected - we shouldn't receive any thing we didn't subscribe to
            System.err.println( String.format( "Received an unexpected attribute reflection of type '%s'",
                                                objectClassName ) );
        }
    }
<% } -%>

    ////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////// Internal Utility Methods /////////////////////////////////
    ////////////////////////////////////////////////////////////////////////////////////////////
<% if( subscribedobjectdata.length > 0 ) { subscribedobjectdata.forEach( function ( objectData, idx ) { -%>
    protected <%= objectData.name %> register( <%= objectData.name %> <%= objectData.name.toLowerCase() %> ) { return (<%= objectData.name %>)super.register( <%= objectData.name.toLowerCase() %> ); }
<% }); } -%>

<% if( subscribedinteractiondata.length > 0 ) { subscribedinteractiondata.map(x=>x.name).forEach( function ( objClassName, idx ) { var objParamName = objClassName.charAt(0).toLowerCase()+objClassName.substr(1); -%>
    /**
    * Handle receipt of a {@link <%= objClassName %>} interaction.
    *
    * @param <%= objParamName %> the interaction to handle
    */
    protected abstract void receive<%= objClassName %>Interaction( <%= objClassName %> <%= objParamName %> );
<% }); } -%>

<% if( subscribedobjectdata.length > 0 ) { subscribedobjectdata.map(x=>x.name).forEach( function ( objClassName, idx ) { var objParamName = objClassName.charAt(0).toLowerCase()+objClassName.substr(1); -%>
    /**
    * Handle receipt of a {@link <%= objClassName %>} object attribute reflection.
    *
    * @param <%= objParamName %> the object attribute reflection to handle
    */
    protected abstract void receive<%= objClassName %>Update( <%= objClassName %> <%= objParamName %> );
<% }); } -%>
}
